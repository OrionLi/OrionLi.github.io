<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>编程入门</title>
    <url>/blog/2023/07/06/0%E5%9F%BA%E7%A1%80%E5%B0%8F%E7%99%BD%E6%80%8E%E6%A0%B7%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>本文章更适合准大一的同学观看</p>
</blockquote>
<h1 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h1><p>想必很多报考计算机类志愿的高考生在填写志愿的唯一想法就是——<del>我要狠狠赚一笔</del>我对计算机&#x2F;编程感兴趣</p>
<p>当然，绝大多数人在初高中可能从来没接触过编程。那么，对于一个0基础的纯小白来说，常常会有以下问题：</p>
<ul>
<li><p>语言好多啊，我要学哪种，能不能多开</p>
</li>
<li><p>我应该怎么学习编程</p>
</li>
<li><p>我应该选择什么 IDE</p>
</li>
<li><p>有什么推荐的学习工具吗</p>
</li>
</ul>
<p>笔者一年前作为一位同样是0基础，同样有这些想法的小白，在摸索的过程踩了一堆坑，这里进行一些分享</p>
<h1 id="我要学什么语言"><a href="#我要学什么语言" class="headerlink" title="我要学什么语言"></a>我要学什么语言</h1><p>翻阅知乎，哔哩哔哩，你可能会看到以下言论：</p>
<ul>
<li><p>人生苦短，我选 Python</p>
</li>
<li><p>Java 岗位多，薪资也高，现在不学 Java，以后就没机会了，趁着现在的红利，先狠狠赚一笔(手动狗头)</p>
</li>
<li><p>嵌入式才是风口，要学就学C</p>
</li>
<li><p>PHP是最好的语言！</p>
</li>
<li><p>……</p>
</li>
</ul>
<p>在这里，笔者首先推荐学C语言</p>
<h2 id="为什么是C语言？"><a href="#为什么是C语言？" class="headerlink" title="为什么是C语言？"></a>为什么是C语言？</h2><ol>
<li><p>简单易学：C 语言相对于 Java、和 C++ 而言，语法较为简单，没有过多的高级特性和复杂的概念。</p>
</li>
<li><p>Python 和 Java 都是基于C语言开发的，C++ 是基于 C 语言的扩展，在编程语言基础语法相差不大的前提下，用 C 语言作为编程入门语言是一个好选择</p>
</li>
<li><p>在 C 和 C++ 中，可以直接使用指针进行编程。理解指针可以帮助你更深入地理解编程语言和计算机底层的工作原理。因为在其他编程语言中或多或少都有指针的概念。</p>
<blockquote>
<p>现在你只需要明白指针的作用很重要就可以了</p>
</blockquote>
</li>
<li><p>使用过面向过程的C语言，学习Java、C++等面向对象的语言可以更好的理解面向对象的优势（各种语言专长的领域不同，没有孰优孰劣之分）</p>
</li>
<li><p>C&#x2F;C++算法题的题解多</p>
<blockquote>
<p>因为C&#x2F;C++性能高、运行时间短、内存占用小，所以大多数算法比赛的选手更倾向于选择C&#x2F;C++</p>
</blockquote>
</li>
<li><p>开发环境最容易安装（专指 Visual Studio ）</p>
</li>
</ol>
<h1 id="我要选择什么软件来学习C语言"><a href="#我要选择什么软件来学习C语言" class="headerlink" title="我要选择什么软件来学习C语言"></a>我要选择什么软件来学习C语言</h1><p>首先要明确的一点是，我们写C语言常说的 <code>VS (Visual Studio)</code> 和 <code>VS Code (Visual Studio Code)</code> 是完全不同的两个软件</p>
<ul>
<li><p>VS Code 属于编辑器，本质来说就是一个增强的记事本，只不过微软提供了插件可以让你使用它来实现部分 IDE 的功能。尽管它占用内存相对IDE来说小一些，但需要配置环境（配置环境对初学者来说就是噩梦），对小白来说开发体验会比 IDE 差很多，而且学习成本高一些</p>
</li>
<li><p>VS 属于 IDE，IDE（Integrated Development Environment，集成开发环境）简单来说就是把对应语言的开发所需的工具和环境都集成好了，好处就是开箱即用，配置简单，而且使用方便</p>
</li>
<li><p>所以C语言个人推荐VS：<a href="https://www.bilibili.com/video/BV1Xt411g7jT/?share_source=copy_web&vd_source=a509fb44c892c9c55cbccbacad6d249b">VS2022安装教程</a></p>
</li>
<li><p>当然，VS软件本身体积比较大，想节省硬盘空间的同学也可以考虑devc++</p>
</li>
</ul>
<h1 id="怎么做笔记"><a href="#怎么做笔记" class="headerlink" title="怎么做笔记"></a>怎么做笔记</h1><p>拜托，都学计算机了，总不能还手写笔记吧，增删改查知识不累吗</p>
<h2 id="使用-Markdown-语言"><a href="#使用-Markdown-语言" class="headerlink" title="使用 Markdown 语言"></a>使用 Markdown 语言</h2><p>Markdown 简单易上手，很多文档和博客（比如这篇）都会使用 Markdown 语言书写</p>
<p>Markdown 学习可以看这篇：<a href="https://orionli.gitee.io/blog/2023/07/06/Markdown%20%E8%AF%AD%E8%A8%80%E6%8C%87%E5%8D%97/">Markdown 语言指南 | OrionLi’s Blog</a></p>
<h2 id="使用-Typora-记录"><a href="#使用-Typora-记录" class="headerlink" title="使用 Typora 记录"></a>使用 Typora 记录</h2><ol>
<li><a href="https://www.123pan.com/s/HQeA-UX1Sh">点击链接，选择<code>typora_64bit_v1.6.6.0_setup.zip</code>下载压缩包</a></li>
<li>解压后，运行<code>typora_64bit_v1.6.6.0_setup.exe</code></li>
<li>安装完成后把压缩包下的<code>Crack</code>文件夹下的<code>winmm.dll</code>复制到<code>Typora</code>安装目录</li>
<li>完成</li>
</ol>
<h1 id="怎么学习编程"><a href="#怎么学习编程" class="headerlink" title="怎么学习编程"></a>怎么学习编程</h1><h2 id="从哪里学"><a href="#从哪里学" class="headerlink" title="从哪里学"></a>从哪里学</h2><p><strong>绝大多数情况下，视频比书籍更适合小白入门，文档和示例比视频更适合开发者学习</strong></p>
<ul>
<li><p>C语言入门视频推荐翁凯的C语言课程：<a href="https://www.bilibili.com/video/BV1d7411L7jZ/?share_source=copy_web&vd_source=a509fb44c892c9c55cbccbacad6d249b">浙江大学 翁恺C语言入门</a>。最后四集可以不用看，只拿C语言当入门语言的话看完结构体就差不多够了</p>
</li>
<li><p>书籍（尤其是入门的书籍）可以当作工具辅助书。预习、复习和查阅的时候使用是最好的</p>
</li>
<li><p>先把谭浩强的《C程序设计》扔了。这本书在那个时代是好书，但现在来看，代码规范和讲解烂爆了</p>
</li>
<li><p>一个方面<strong>最多</strong>买一本书就行了，不要傻不拉几的买好几本，然后放在角落吃灰</p>
</li>
<li><p>远离清华大学出版社等xx大学出版社出版的书，绝大部分质量极差</p>
</li>
<li><p>推荐异步图书、图灵系列的图书，推荐人民邮电出版社和机械工业出版的图书，推荐外国的书</p>
</li>
</ul>
<h2 id="语言是不是学的越多越好"><a href="#语言是不是学的越多越好" class="headerlink" title="语言是不是学的越多越好"></a>语言是不是学的越多越好</h2><ul>
<li><p>我们前面已经讨论过了<a href="https://orionli.gitee.io/blog/2023/07/06/0%E5%9F%BA%E7%A1%80%E5%B0%8F%E7%99%BD%E6%80%8E%E6%A0%B7%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFC%E8%AF%AD%E8%A8%80%EF%BC%9F">为什么要先学C</a></p>
</li>
<li><p>我们学习语言，是因为要用语言对应的技术去开发产品。就目前而言：</p>
<ul>
<li><p>AI方面的基本都使用Python</p>
</li>
<li><p>嵌入式开发使用C语言</p>
<blockquote>
<p>嵌入式系统开发是对于除了电脑之外的所有电子设备上操作系统的开发，开发对象有手机，掌上电脑，机电系统等 (from 百度百科)</p>
</blockquote>
</li>
<li><p>前端先学HTML、CSS、JavaScript三大件(现在还要学TypeScript)，然后vue或react。</p>
</li>
<li><p>后端绝大多数为Java，少量大公司如字节跳动、哔哩哔哩、知乎等用Go，也有公司是用Python，不过相对更少。游戏服务器几乎都是C++</p>
</li>
<li><p>大数据领域，Java和Python平分秋色，开发者主要是使用它们来调用另一种语言——SQL。</p>
</li>
</ul>
<p>各方向的详细介绍和分流我们会在团队笔试完进行，到时会有专门的宣讲会进行讲解，在这里只是做简单的介绍。</p>
</li>
<li><p>在你学习语言和目标岗位门当户对的情况下，<code>HR并不会单纯因为你会的技术栈多而招你</code>。技术栈并不是关键，<strong>业务的解决方案才是最重要的</strong>。换言之，知道什么场景下怎么开发业务才是最重要的，你要明白<strong>语言只是个工具</strong>，基础语法都相差不大。</p>
<blockquote>
<p>库、框架、技术等统称技术栈，学习语言的主要目的就是要使用这些库、框架、技术来开发软件。现阶段很难给小白解释这些词的含义，你可以简单把他们理解为是工具。开发软件所使用的技术栈不是绝对的，而是相对的。换言之，没有万能解法。业务决定了你要使用的技术栈</p>
</blockquote>
</li>
<li><p>人不是因为学了一门新的语言和新的技术才能进大厂。而是先进大厂，你才能有机会用一些新的技术。有些人反过来了，认为学了一些新的语言很厉害，结果毕业之后就失业了，为什么？因为只有大厂才招，而这些人要是进不去那就完蛋了</p>
</li>
<li><p>综上，最好先专精某个语言再考虑其他的，<strong>起码要保证能让你找到工作</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习路线</category>
      </categories>
      <tags>
        <tag>学习路线</tag>
      </tags>
  </entry>
  <entry>
    <title>(一)Go基本语法</title>
    <url>/blog/2023/07/25/Go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><h3 id="显式声明"><a href="#显式声明" class="headerlink" title="显式声明"></a>显式声明</h3><ul>
<li><p>如果我们未为一个变量初始化，则必须显式指定变量类型</p>
</li>
<li><p>如果声明时不指定具体的值，则会被赋值为默认值。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="type">string</span> <span class="comment">// str的值为&quot;&quot;(空字符串)</span></span><br><span class="line"><span class="keyword">var</span> num <span class="type">int</span>    <span class="comment">// num的值为0</span></span><br></pre></td></tr></table></figure>

<h3 id="快速声明赋值"><a href="#快速声明赋值" class="headerlink" title="快速声明赋值"></a>快速声明赋值</h3><ul>
<li><p>Go 支持变量类型自动推断，也就是说，当我们立即为一个变量进行初始化时，其类型是可以省略的</p>
</li>
<li><p>可以通过 <code>:=</code> 符号以一种简单的方式（也是实际上最常用的方式）声明一个变量</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a, b := <span class="number">1</span>, <span class="number">2</span><span class="comment">// Go 支持多个变量在同一行同时声明</span></span><br><span class="line">str := <span class="string">&quot;我是字符串。&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="常量声明"><a href="#常量声明" class="headerlink" title="常量声明"></a>常量声明</h2><p>可以使用 <code>const</code> 关键字代替 <code>var</code> 关键字来创建一个常量（不可变变量）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str <span class="type">string</span> = <span class="string">&quot;我是字符串&quot;</span></span><br><span class="line"><span class="keyword">const</span> num <span class="type">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"></span><br><span class="line">num = <span class="number">2</span> <span class="comment">// 若更改会报错</span></span><br></pre></td></tr></table></figure>

<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><ul>
<li><code>Go</code>的<code>if</code>语句和<code>C、Java</code>类似，只不过<code>if</code>后面没有括号，但是加上括号也能正确运行</li>
<li><code>if</code>后面的开始大括号必须跟if在同一行，不能换行(会报错)。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">num1, num2 := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> num1 &lt; num2 &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;num1 &lt; num2&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;num1 &gt;= num2&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if</code>语句后面也可以定义变量，但只能用一个分号。也支持<code>if-else-if</code>语句。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> num1, num2 := <span class="number">1</span>, <span class="number">2</span>; num1 &lt; num2 &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;num1 &lt; num2&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> num1 &gt; num2 &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;num1 &lt; num2&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;num1 = num2&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>在<code>Go</code>里没有<code>while</code>和<code>do-while</code>循环，只有<code>for</code>循环。<code>Go</code>的<code>for</code>循环包含了<code>for</code>和<code>while</code>的功能。</p>
<p>用<code>for</code>定义死循环，相当于<code>while(true)</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;loop&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p><code>switch</code>语句也和<code>C、Java</code>的&#96;&#96;switch<code>语句类似，只不过</code>switch<code>后面不需要加括号，</code>case<code>里也不需要加</code>break<code>，</code>Go<code>的</code>switch <code>默认情况下 </code>case<code>最后自带</code>break<code>语句，匹配成功后就不会执行其他</code>case<code>，如果我们需要执行后面的 </code>case<code>，可以使用 </code>fallthrough&#96; 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">num := <span class="number">2</span></span><br><span class="line"><span class="keyword">switch</span> num &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;one&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">3</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;two or three&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;other&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Go</code>的<code>switch</code>可以匹配任意类型，也可以实现<code>if-else</code>的功能，在<code>switch</code>后面不加匹配条件，可以在<code>case</code>里进行匹配。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t := time.Now()</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;It&#x27;s before noon&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;It&#x27;s after noon&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个长度为5的数组</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">a[<span class="number">4</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(<span class="string">&quot;get:&quot;</span>, a[<span class="number">2</span>])</span><br><span class="line">fmt.Println(<span class="string">&quot;len:&quot;</span>, <span class="built_in">len</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明并初始化</span></span><br><span class="line">b := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(b)</span><br></pre></td></tr></table></figure>

<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> twoD [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">        twoD[i][j] = i + j</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;2d: &quot;</span>, twoD)</span><br></pre></td></tr></table></figure>

<h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><ul>
<li><p>有点像<code>Java</code>的<code>List</code></p>
</li>
<li><p>切片声明需要通过<code>make</code>来进行，需要指定切片的类型以及长度</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个空切片，长度为3，容量为10</span></span><br><span class="line">s1 := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// 声明并初始化</span></span><br><span class="line">s2 :=[] <span class="type">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125; </span><br></pre></td></tr></table></figure>

<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>对切片元素的操作，可以像数组一样操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">3</span>)</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&quot;a&quot;</span></span><br><span class="line">s[<span class="number">1</span>] = <span class="string">&quot;b&quot;</span></span><br><span class="line">s[<span class="number">2</span>] = <span class="string">&quot;c&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><p>可以通过<code>append</code>方法向切片中添加元素，因为切片会涉及到扩容，所以需要一个变量来接收返回值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s = <span class="built_in">append</span>(s, <span class="string">&quot;d&quot;</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>可以通过<code>copy</code>方法对切片进行复制，复制后是两个独立的切片，更改元素值相互不影响。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>复制代码c := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(s))</span><br><span class="line"><span class="built_in">copy</span>(c, s)</span><br><span class="line">fmt.Println(c) <span class="comment">// [a b c d e f]</span></span><br></pre></td></tr></table></figure>

<h2 id="切片-1"><a href="#切片-1" class="headerlink" title="切片"></a>切片</h2><p>相当于<code>Java</code>中的<code>substring</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>复制代码<span class="comment">// 返回下标2到4的值</span></span><br><span class="line">fmt.Println(s[<span class="number">2</span>:<span class="number">5</span>]) <span class="comment">// [c d e]</span></span><br><span class="line"><span class="comment">// 返回下标0到4的值</span></span><br><span class="line">fmt.Println(s[:<span class="number">5</span>])  <span class="comment">// [a b c d e]</span></span><br><span class="line"><span class="comment">// 返回下标2到最后一个元素</span></span><br><span class="line">fmt.Println(s[<span class="number">2</span>:])  <span class="comment">// [c d e f]</span></span><br></pre></td></tr></table></figure>

<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>无序</p>
<h2 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h2><p>声明一个<code>key</code>为<code>string</code>，<code>value</code>为<code>int</code>的空<code>Map</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>声明的同时对其进行初始化操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>, <span class="string">&quot;two&quot;</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="访问和操作"><a href="#访问和操作" class="headerlink" title="访问和操作"></a>访问和操作</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span></span><br><span class="line">m[<span class="string">&quot;two&quot;</span>] = <span class="number">2</span></span><br><span class="line">fmt.Println(m[<span class="string">&quot;one&quot;</span>])    <span class="comment">// 1</span></span><br><span class="line">fmt.Println(m[<span class="string">&quot;unknow&quot;</span>]) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p><code>Go</code>在查询<code>key</code>时返回了两个值，一个是<code>value</code>，另一个是<code>bool</code>类型的值代表是否存在</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r, ok := m[<span class="string">&quot;unknow&quot;</span>]</span><br><span class="line">fmt.Println(r, ok) <span class="comment">// 0 false</span></span><br></pre></td></tr></table></figure>

<p>可以使用<code>delete</code>函数来删除<code>Map</code>中的键值对</p>
<p><code>Goland</code>中可以通过<code>map.delete</code>快速生成</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;one&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="range"><a href="#range" class="headerlink" title="range"></a>range</h1><p>有点像<code>JavaScript</code>的解构赋值</p>
<p>数组、切片、<code>Map</code>都可以使用<code>range</code>来遍历，通过<code>range</code>可以得到索引和对应的值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="comment">// 遍历切片</span></span><br><span class="line"><span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;index:&quot;</span>, i, <span class="string">&quot;num:&quot;</span>, num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历Map</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;A&quot;</span>, <span class="string">&quot;b&quot;</span>: <span class="string">&quot;B&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Println(k, v) <span class="comment">// b 8; a A</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只获取key</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;key&quot;</span>, k) <span class="comment">// key a; key b</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只获取value</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;value&quot;</span>, v) <span class="comment">// value A; value B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><code>Go</code>函数不同于<code>Java</code>，<strong>返回值写在最后面</strong>，而且可以同时<strong>返回多个值</strong></p>
<p>一般来说，第一个是函数的返回值，第二个是错误信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exists</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, k <span class="type">string</span>)</span></span> (v <span class="type">string</span>, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    v, ok = m[k]</span><br><span class="line">    <span class="keyword">return</span> v, ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p><code>Go</code>支持指针，相对于<code>C语言</code>，<code>Go</code>的指针功能十分简单，当然功能也很有限，主要用途就是对函数传入的参数进行修改。</p>
<p>默认情况下，<code>Go</code>函数的参数传参是值传递，也就是拷贝了一个副本，对其修改不会影响原来的值，如果要对原来的值也要变的话，需要使用指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add2</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n += <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add2ptr</span><span class="params">(n *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    *n += <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n := <span class="number">5</span></span><br><span class="line">    add2(n)</span><br><span class="line">    fmt.Println(n) <span class="comment">// 5</span></span><br><span class="line">    add2ptr(&amp;n)</span><br><span class="line">    fmt.Println(n) <span class="comment">// 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h2 id="结构体变量"><a href="#结构体变量" class="headerlink" title="结构体变量"></a>结构体变量</h2><p>和<code>C</code>语法差不多，相当于<code>Java</code>的对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    name     <span class="type">string</span></span><br><span class="line">    password <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体的初始化，可以指定字段初始化，也可以全部初始化。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := user&#123;name: <span class="string">&quot;wang&quot;</span>, password: <span class="string">&quot;1024&quot;</span>&#125;</span><br><span class="line">b := user&#123;<span class="string">&quot;wang&quot;</span>, <span class="string">&quot;1024&quot;</span>&#125;</span><br><span class="line">c := user&#123;name: <span class="string">&quot;wang&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>对于结构体内部成员的访问可以通过<code>.</code>操作符来进行访问或赋值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d user</span><br><span class="line">d.name = <span class="string">&quot;wang&quot;</span></span><br><span class="line">d.password = <span class="string">&quot;1024&quot;</span></span><br><span class="line">fmt.Println(d.password)</span><br></pre></td></tr></table></figure>

<h2 id="结构体方法"><a href="#结构体方法" class="headerlink" title="结构体方法"></a>结构体方法</h2><p>相当于<code>Java</code>类的成员函数</p>
<p>在一个普通方法的<code>func</code>关键字后面加上对应结构体信息，就代表这个方法是属于结构体的。</p>
<p>为<code>user</code>结构体添加一个检查密码的函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span></span> checkPassword(password <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> u.password == password</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为<code>user</code>结构体添加一个重置密码的函数，因为要修改结构体内部的值，所以要使用指针类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span></span> resetPassword(password <span class="type">string</span>) &#123;</span><br><span class="line">    u.password = password</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体方法的调用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := user&#123;name: <span class="string">&quot;wang&quot;</span>, password: <span class="string">&quot;1024&quot;</span>&#125;</span><br><span class="line">a.resetPassword(<span class="string">&quot;2048&quot;</span>)</span><br><span class="line">fmt.Println(a.checkPassword(<span class="string">&quot;2048&quot;</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p><code>Go</code>内置的错误接口提供了非常简单的错误处理机制，<code>error</code>类型是一个接口类型，其定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Go</code>函数可以返回多个值，通常函数的最后一个值用来代表错误信息，在函数内部可以使用<code>errors.New </code>可返回一个错误信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findUser</span><span class="params">(users []user, name <span class="type">string</span>)</span></span> (v *user, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> _, u := <span class="keyword">range</span> users &#123;</span><br><span class="line">        <span class="keyword">if</span> u.name == name &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;u, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;not found&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果函数不出现错误的话，可以直接返回<code>nil</code>。</p>
<p>在调用函数的时候，需要用多个变量来接收函数的返回值，我们可以通过函数的返回值来判断是否发生了异常。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">u, err := findUser([]user&#123;&#123;<span class="string">&quot;wang&quot;</span>, <span class="string">&quot;1024&quot;</span>&#125;&#125;, <span class="string">&quot;wang&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><p><code>Go</code>内置了非常丰富的标准库工具，包括字符串操作、字符串格式化、<code>json</code>处理、时间处理等</p>
<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment">// 是否包含</span></span><br><span class="line">fmt.Println(strings.Contains(a, <span class="string">&quot;ll&quot;</span>))                <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 字符统计</span></span><br><span class="line">fmt.Println(strings.Count(a, <span class="string">&quot;l&quot;</span>))                    <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 判断字符串开头</span></span><br><span class="line">fmt.Println(strings.HasPrefix(a, <span class="string">&quot;he&quot;</span>))               <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 判断字符串结尾</span></span><br><span class="line">fmt.Println(strings.HasSuffix(a, <span class="string">&quot;llo&quot;</span>))              <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 查找字符串</span></span><br><span class="line">fmt.Println(strings.Index(a, <span class="string">&quot;ll&quot;</span>))                   <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 字符串拼接</span></span><br><span class="line">fmt.Println(strings.Join([]<span class="type">string</span>&#123;<span class="string">&quot;he&quot;</span>, <span class="string">&quot;llo&quot;</span>&#125;, <span class="string">&quot;-&quot;</span>)) <span class="comment">// he-llo</span></span><br><span class="line"><span class="comment">// 复制字符串指定次数</span></span><br><span class="line">fmt.Println(strings.Repeat(a, <span class="number">2</span>))                     <span class="comment">// hellohello</span></span><br><span class="line"><span class="comment">// 字符串替换</span></span><br><span class="line">fmt.Println(strings.Replace(a, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="number">-1</span>))         <span class="comment">// hEllo</span></span><br><span class="line"><span class="comment">// 字符串分割</span></span><br><span class="line">fmt.Println(strings.Split(<span class="string">&quot;a-b-c&quot;</span>, <span class="string">&quot;-&quot;</span>))              <span class="comment">// [a b c]</span></span><br><span class="line"><span class="comment">// 转为小写</span></span><br><span class="line">fmt.Println(strings.ToLower(a))                       <span class="comment">// hello</span></span><br><span class="line"><span class="comment">// 转为大写</span></span><br><span class="line">fmt.Println(strings.ToUpper(a))                       <span class="comment">// HELLO</span></span><br><span class="line"><span class="comment">// 字符串长度</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(a))                                   <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p><code>Println</code>最为常用作用为打印并换行，<code>Printf</code>可以按指定格式打印字符串。</p>
<p><code>+v</code>可以打印字段和值详细信息。</p>
<p><code>#v</code>可以打印出整个结构体的构造以及详细信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>复制代码s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">n := <span class="number">123</span></span><br><span class="line">p := point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(s, n) <span class="comment">// hello 123</span></span><br><span class="line">fmt.Println(p)    <span class="comment">// &#123;1 2&#125;</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;s=%v\n&quot;</span>, s)  <span class="comment">// s=hello</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;n=%v\n&quot;</span>, n)  <span class="comment">// n=123</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p=%v\n&quot;</span>, p)  <span class="comment">// p=&#123;1 2&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p=%+v\n&quot;</span>, p) <span class="comment">// p=&#123;x:1 y:2&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p=%#v\n&quot;</span>, p) <span class="comment">// p=main.point&#123;x:1, y:2&#125;</span></span><br><span class="line"></span><br><span class="line">f := <span class="number">3.141592653</span></span><br><span class="line">fmt.Println(f)          <span class="comment">// 3.141592653</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%.2f\n&quot;</span>, f) <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure>

<h3 id="json处理"><a href="#json处理" class="headerlink" title="json处理"></a>json处理</h3><p><code>Go</code>在处理json时十分简单，只需要将结构体中的字段第一个字母变成大写就能用内置的<code>JSON</code>工具进行处理。</p>
<p><code>Go</code>中一些特殊的类型，比如<code>Channel</code>、<code>complex</code>、<code>function</code>是不能被解析成<code>JSON</code>的。</p>
<p><code>Go</code>中<code>JSON</code>对象只支持<code>string</code>作为<code>key</code>，对于<code>map</code>，那么必须是<code>map[string]T</code>这种类型，<code>T</code>可以是<code>Go</code>语言中任意的类型。</p>
<p><code>Go</code>的<code>json</code>处理是通过<code>Marshal</code>、<code>Unmarshal</code>方法来进行处理的。</p>
<p><code>Marshal</code> 用于自定义编码<code>json</code>的方法，也就是将变量、对象转成<code>json</code>，转换之后需要用<code>string</code>方法强转一下，否则会打印出的是16进制字符串。</p>
<p><code>Unmarshal</code>用于自定义解码<code>json</code>方法，也就是将<code>json</code>转为对象。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> userInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="type">string</span></span><br><span class="line">    Age   <span class="type">int</span> <span class="string">`json:&quot;age&quot;`</span> <span class="comment">// 自定义json输出的字段</span></span><br><span class="line">    Hobby []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := userInfo&#123;Name: <span class="string">&quot;wang&quot;</span>, Age: <span class="number">18</span>, Hobby: []<span class="type">string</span>&#123;<span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;TypeScript&quot;</span>&#125;&#125;</span><br><span class="line">    buf, err := json.Marshal(a)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(buf)         <span class="comment">// [123 34 78 97...]</span></span><br><span class="line">    fmt.Println(<span class="type">string</span>(buf)) <span class="comment">// &#123;&quot;Name&quot;:&quot;wang&quot;,&quot;age&quot;:18,&quot;Hobby&quot;:[&quot;Golang&quot;,&quot;TypeScript&quot;]&#125;</span></span><br><span class="line"></span><br><span class="line">    buf, err = json.MarshalIndent(a, <span class="string">&quot;&quot;</span>, <span class="string">&quot;\t&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="type">string</span>(buf))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> b userInfo</span><br><span class="line">    err = json.Unmarshal(buf, &amp;b)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, b) <span class="comment">// main.userInfo&#123;Name:&quot;wang&quot;, Age:18, Hobby:[]string&#123;&quot;Golang&quot;, &quot;TypeScript&quot;&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h3><p><code>Go</code>提供了很多常用的时间处理函数，例如Now、解析字符串、转字符串、获取时间戳等。在操作时间相关的方法时，需要导入<code>time</code>包。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前时间</span></span><br><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now) <span class="comment">// 2022-03-27 18:04:59.433297 +0800 CST m=+0.000087933</span></span><br><span class="line">t := time.Date(<span class="number">2022</span>, <span class="number">3</span>, <span class="number">27</span>, <span class="number">1</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">0</span>, time.UTC)</span><br><span class="line">t2 := time.Date(<span class="number">2022</span>, <span class="number">3</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">30</span>, <span class="number">36</span>, <span class="number">0</span>, time.UTC)</span><br><span class="line">fmt.Println(t)                                                  <span class="comment">// 2022-03-27 01:25:36 +0000 UTC</span></span><br><span class="line"><span class="comment">// 获取时间的年月日</span></span><br><span class="line">fmt.Println(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute()) <span class="comment">// 2022 March 27 1 25</span></span><br><span class="line"><span class="comment">// 时间转字符串</span></span><br><span class="line">fmt.Println(t.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))                    <span class="comment">// 2022-03-27 01:25:36</span></span><br><span class="line"><span class="comment">// 获取时间差</span></span><br><span class="line">diff := t2.Sub(t)</span><br><span class="line">fmt.Println(diff)                           <span class="comment">// 1h5m0s</span></span><br><span class="line">fmt.Println(diff.Minutes(), diff.Seconds()) <span class="comment">// 65 3900</span></span><br><span class="line"><span class="comment">// 解析字符串</span></span><br><span class="line">t3, err := time.Parse(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, <span class="string">&quot;2022-03-27 01:25:36&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(t3 == t)    <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 获取时间戳</span></span><br><span class="line">fmt.Println(now.Unix()) <span class="comment">// 1648738080</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>以Java视角学Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>字节跳动青训营</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 虚拟机</title>
    <url>/blog/2023/05/16/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<p>注：栈内存、堆内存诊断都没学</p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>java二进制字节码的运行环境</p>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul>
<li><p>一次编写，到处运行 </p>
</li>
<li><ul>
<li>消除了字节码和底层操作系统之间的的差异 </li>
<li>对外提供了一个一致的运行环境 </li>
<li>jvm可以用解释的方法来执行二进制字节码来达到代码的平台无关性</li>
</ul>
</li>
<li><p>自动内存管理，垃圾回收功能 </p>
</li>
<li><p>数组下标越界越界检查 </p>
</li>
<li><ul>
<li>不会覆盖其他代码的内存</li>
</ul>
</li>
<li><p>多态 </p>
</li>
<li><ul>
<li>提升扩展性</li>
<li>使用虚方法表的方式实现</li>
</ul>
</li>
</ul>
<h2 id="概念对比"><a href="#概念对比" class="headerlink" title="概念对比"></a>概念对比</h2><p>JVM: Java虚拟机</p>
<p>JRE: Java的运行时环境 &lt;&#x3D; JVM + 基础类库</p>
<p>JDK: JRE基础上加上一些javac，javap，内存监测工具什么的 &lt;&#x3D; JVM + 基础类库 + 编译工具</p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>先通过类加载器加载到JVM内存结构</p>
<p>JVM内存结构包括：</p>
<ul>
<li><code>方法区</code>： 存放类</li>
<li><code>堆</code>：存放类的实例对象</li>
<li><code>虚拟机栈</code>：实例对象调用方法时用到</li>
<li><code>程序计数器</code>：实例对象调用方法时用到</li>
<li><code>本地方法栈</code>：实例对象调用方法时用到</li>
</ul>
<p>接下来到了执行引擎：</p>
<ul>
<li>方法执行时，每行代码由<code>解释器</code>进行逐行执行 </li>
<li>方法内的热点代码，也就是被频繁调用的代码，会被<code>即时编译器</code>进行编译。</li>
</ul>
<p>可以竟是看做为优化代码</p>
<ul>
<li><code>GC垃圾回收</code>将<code>堆</code>里面不再被引用的模块进行垃圾回收</li>
</ul>
<p>还有一些是Java代码无法实现，需要调用底层代码的功能：</p>
<ul>
<li>通过<code>本地方法接口</code>调用操作系统的一些功能方法</li>
</ul>
<h1 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h1><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>JVM指令 &#x3D;&gt; 解释器 &#x3D;&gt; 机器码 &#x3D;&gt; CPU</p>
<ul>
<li>Java源代码经过编译，成为<code>二进制字节码(JVM指令)</code>，所有平台下都是一致的 </li>
<li>接下来每一条<code>JVM指令</code>都被<code>解释器</code>(java虚拟机执行引擎的一个组件)解释成一条<code>机器码</code> </li>
<li>CPU拿着<code>机器码</code>执行命令</li>
</ul>
<p>CPU只认机器码</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>程序计数器负责在一些JVM指令的执行过程中，记住下一条JVM指令的执行地址</p>
<p>当JVM指令最后变成机器码被CPU执行后，解释器就去程序计数器找要执行的指令地址</p>
<p>在<strong>物理上</strong>程序计数器是通过一个叫<strong>寄存器</strong>的东西实现的，程序计数器是对寄存器的一些屏蔽和抽象</p>
<p>寄存器是整个CPU读取速度最快的单元(因为读取非常频繁)</p>
<p>使用Java虚拟机在手机的时候，就将CPU的寄存器作为程序计数器来存储地址</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>线程私有</li>
</ul>
<p>在多个线程运行的时候，CPU会有一个调度器组件来给每个线程分配时间片</p>
<p>如果线程1的代码在时间片内没有执行完，线程1的代码就会被暂存，CPU资源切换到线程2</p>
<p>线程2的时间片用完了再切换</p>
<p>在线程切换的改成中，如果要记住下一条指令执行到哪里了，就要用到程序计数器</p>
<p>程序计数器现在就属于被暂存的线程</p>
<p>每个线程都有自己的程序计数器()因为各自执行的地址是不一样的</p>
<ul>
<li>JVM规范中唯一一个不会存在内存溢出的区</li>
</ul>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ul>
<li>每个线程运行时所需要的内存，称为虚拟机栈</li>
</ul>
<p>一个栈内由多个栈帧组成</p>
<p>一个栈帧对应一次方法的调用</p>
<p>线程执行代码，代码由多个方法组成，每个方法运行需要的内存就是栈帧</p>
<p>栈帧的内存存着方法参数，局部变量，返回地址</p>
<p>方法1被调用，分配栈帧1，栈帧1入栈；方法1调用方法2，分配栈帧2，栈帧2入栈…方法2执行完，栈帧2出栈。出栈就是释放内存</p>
<ul>
<li>每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存 </li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li>
</ul>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li><p>出栈自动回收内存，不需要用到GC，GC是堆用的</p>
</li>
<li><p>栈内存Linux、macOS、Oracle Solaris默认1m</p>
</li>
<li><p>栈内存不是越大越好，因为物理内存是固定的，单个栈内存大了，可以容纳的线程数量就少了</p>
</li>
<li><p>局部变量是线程安全的，因为俩线程调用一个方法，各自都有各自的局部变量</p>
</li>
<li><p>但是全局变量(<code>static</code>)对各个方法是共享的。静态变量值的改变发生在方法调用完毕之后。当方法内部进行静态变量的修改时，实际上只是修改了该方法中对静态变量的局部变量，这并不会影响在内存中存储的静态变量值。当方法执行完毕后，再次访问该静态变量时，才能看到被更改的值。因此，静态变量值的改变情况都发生在方法调用完毕之后。</p>
</li>
<li><p>判断方法内局部变量是否线程安全：</p>
</li>
<li><ul>
<li>没有进出：不是通过参数引用进来，没有return出去</li>
<li>基本类型当然是线程安全的</li>
</ul>
</li>
</ul>
<h3 id="栈内存溢出的场景"><a href="#栈内存溢出的场景" class="headerlink" title="栈内存溢出的场景"></a>栈内存溢出的场景</h3><ul>
<li>栈帧过多，只入不出(错误的递归调用)</li>
</ul>
<p>比方说一个部门类和员工类，部门类有一个员工类的List，员工类有一个自己所属部门的属性</p>
<p>转换成json时便会出现循环依赖</p>
<p>此时可以在员工类的部门字段上加上<code>@JsonIgnore</code>来忽略这个属性</p>
<ul>
<li>栈帧过大(理论上才会存在？)</li>
</ul>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>分配给不是由Java编写的代码</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>通过new关键字，创建对象都会使用堆内存</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>它是线程共享的，堆中对象都需要考虑线程安全的问题</li>
<li>有垃圾回收机制</li>
</ul>
<h3 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h3><ul>
<li>集合内元素在集合作用范围内无法被垃圾回收，如果元素过多过大会导致堆内存溢出</li>
<li>垃圾回收后，内存占用仍然很高</li>
</ul>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>存储类的信息</p>
<h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><ul>
<li>1.8以前会导致永久代内存溢出</li>
<li>1.8之后会导致元空间内存溢出</li>
</ul>
]]></content>
      <categories>
        <category>Java 八股文</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 备忘清单</title>
    <url>/blog/2023/07/13/Golang%20%E5%A4%87%E5%BF%98%E6%B8%85%E5%8D%95/</url>
    <content><![CDATA[<blockquote>
<p>本文为转载</p>
<p>原出处：<a href="http://bbs.laoleng.vip/reference/docs/golang.html">http://bbs.laoleng.vip/reference/docs/golang.html</a></p>
<p>仓库地址：<a href="https://github.com/jaywcjlove/reference">https://github.com/jaywcjlove/reference</a></p>
</blockquote>
<p>该备忘单提供了帮助您使用 <a href="https://golang.org/">Golang</a> 的基本语法和方法。</p>
<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h2 id="hello-go"><a href="#hello-go" class="headerlink" title="hello.go"></a>hello.go</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go run hello.go</span></span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<p>或者在 <a href="https://repl.it/languages/go">Go repl</a> 中尝试一，<code>go</code> 命令<a href="#go-%E5%91%BD%E4%BB%A4">参考</a></p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 <span class="type">string</span></span><br><span class="line">s1 = <span class="string">&quot;Learn Go!&quot;</span></span><br><span class="line"><span class="comment">// 一次声明多个变量</span></span><br><span class="line"><span class="keyword">var</span> b, c <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 匿名赋值</span></span><br><span class="line">_ , e = <span class="number">10</span>, <span class="number">20</span> </span><br></pre></td></tr></table></figure>

<p>简短声明</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := <span class="string">&quot;Learn Go!&quot;</span>        <span class="comment">// string</span></span><br><span class="line">b, c := <span class="number">1</span>, <span class="number">2</span>             <span class="comment">// int</span></span><br><span class="line">d := <span class="literal">true</span>                <span class="comment">// bool</span></span><br></pre></td></tr></table></figure>

<p>参见：<a href="#golang-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B">基本类型</a></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// 程序的入口点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">  say(<span class="string">&quot;Hello Go!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(message <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;You said: &quot;</span>, message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参见：<a href="#golang-%E5%87%BD%E6%95%B0">函数(Functions)</a></p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"><span class="comment">/* 这是</span></span><br><span class="line"><span class="comment">多行注释 */</span></span><br></pre></td></tr></table></figure>

<h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Yes!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参见：<a href="#golang-%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6">条件控制</a></p>
<h1 id="Golang-基本类型"><a href="#Golang-基本类型" class="headerlink" title="Golang 基本类型"></a>Golang 基本类型</h1><h2 id="字符串-Strings"><a href="#字符串-Strings" class="headerlink" title="字符串 Strings"></a>字符串 Strings</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := <span class="string">&quot;Hello&quot;</span> + <span class="string">&quot;World&quot;</span></span><br><span class="line">s2 := <span class="string">`A &quot;raw&quot; string literal</span></span><br><span class="line"><span class="string">can include line breaks.`</span></span><br><span class="line"><span class="comment">// 输出：10</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s1))</span><br><span class="line"><span class="comment">// 输出：Hello</span></span><br><span class="line">fmt.Println(<span class="type">string</span>(s1[<span class="number">0</span>:<span class="number">5</span>]))</span><br></pre></td></tr></table></figure>

<p>字符串的类型为 <code>字符串</code></p>
<h2 id="数字-Numbers"><a href="#数字-Numbers" class="headerlink" title="数字 Numbers"></a>数字 Numbers</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">num := <span class="number">3</span>             <span class="comment">// int</span></span><br><span class="line">num := <span class="number">3.</span>            <span class="comment">// float64</span></span><br><span class="line">num := <span class="number">3</span> + <span class="number">4i</span>        <span class="comment">// complex128</span></span><br><span class="line">num := <span class="type">byte</span>(<span class="string">&#x27;a&#x27;</span>)     <span class="comment">// byte (alias: uint8)</span></span><br><span class="line"><span class="keyword">var</span> u <span class="type">uint</span> = <span class="number">7</span>       <span class="comment">// uint (unsigned)</span></span><br><span class="line"><span class="keyword">var</span> p <span class="type">float32</span> = <span class="number">22.7</span>  <span class="comment">// 32-bit float</span></span><br></pre></td></tr></table></figure>

<h3 id="操作符-Operators"><a href="#操作符-Operators" class="headerlink" title="操作符 Operators"></a>操作符 Operators</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="number">5</span></span><br><span class="line">x++</span><br><span class="line">fmt.Println(<span class="string">&quot;x + 4 =&quot;</span>, x + <span class="number">4</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;x * 4 =&quot;</span>, x * <span class="number">4</span>) </span><br></pre></td></tr></table></figure>

<p>参见：<a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E6%A0%87%E7%82%B9%E7%AC%A6%E5%8F%B7">更多操作符</a></p>
<h2 id="布尔值-Booleans"><a href="#布尔值-Booleans" class="headerlink" title="布尔值 Booleans"></a>布尔值 Booleans</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">isTrue   := <span class="literal">true</span></span><br><span class="line">isFalse  := <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="literal">true</span> &amp;&amp; <span class="literal">true</span>)   <span class="comment">// true </span></span><br><span class="line">fmt.Println(<span class="literal">true</span> &amp;&amp; <span class="literal">false</span>)  <span class="comment">// false</span></span><br><span class="line">fmt.Println(<span class="literal">true</span> || <span class="literal">true</span>)   <span class="comment">// true</span></span><br><span class="line">fmt.Println(<span class="literal">true</span> || <span class="literal">false</span>)  <span class="comment">// true</span></span><br><span class="line">fmt.Println(!<span class="literal">true</span>)          <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>参见：<a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E6%A0%87%E7%82%B9%E7%AC%A6%E5%8F%B7">更多操作符</a></p>
<h2 id="数组-Arrays"><a href="#数组-Arrays" class="headerlink" title="数组 Arrays"></a>数组 Arrays</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">┌────┬────┬────┬────┬─────┬─────┐</span><br><span class="line">| <span class="number">2</span>  | <span class="number">3</span>  | <span class="number">5</span>  | <span class="number">7</span>  | <span class="number">11</span>  | <span class="number">13</span>  |</span><br><span class="line">└────┴────┴────┴────┴─────┴─────┘</span><br><span class="line">  <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span>    <span class="number">3</span>     <span class="number">4</span>     <span class="number">5</span></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">primes := [...]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(primes)) <span class="comment">// =&gt; 6</span></span><br><span class="line"><span class="comment">// 输出：[2 3 5 7 11 13]</span></span><br><span class="line">fmt.Println(primes)</span><br><span class="line"><span class="comment">// 与 [:3] 相同，输出：[2 3 5]</span></span><br><span class="line">fmt.Println(primes[<span class="number">0</span>:<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">2</span>]<span class="type">string</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">&quot;World&quot;</span></span><br><span class="line">fmt.Println(a[<span class="number">0</span>], a[<span class="number">1</span>]) <span class="comment">//=&gt; Hello World</span></span><br><span class="line">fmt.Println(a)   <span class="comment">// =&gt; [Hello World]</span></span><br></pre></td></tr></table></figure>

<h3 id="2d-array"><a href="#2d-array" class="headerlink" title="2d array"></a>2d array</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> twoDimension [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">        twoDimension[i][j] = i + j</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; 2d:  [[0 1 2] [1 2 3]]</span></span><br><span class="line">fmt.Println(<span class="string">&quot;2d: &quot;</span>, twoDimension)</span><br></pre></td></tr></table></figure>

<h2 id="指针-Pointers"><a href="#指针-Pointers" class="headerlink" title="指针(Pointers)"></a>指针(Pointers)</h2><!--rehype:wrap-class=col-span-2-->

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  b := *getPointer()</span><br><span class="line">  fmt.Println(<span class="string">&quot;Value is&quot;</span>, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getPointer</span> <span class="params">()</span></span> (myPointer *<span class="type">int</span>) &#123;</span><br><span class="line">  a := <span class="number">234</span></span><br><span class="line">  <span class="keyword">return</span> &amp;a</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//申明指针的时候，如果没有指向某个变量，默认值为nil</span></span><br><span class="line"><span class="comment">//不能直接进行操作，包括读写</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="type">int</span></span><br><span class="line">*p = <span class="number">123</span>      <span class="comment">// panic   nil pointer</span></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//而用new返回的是有默认值的指针, 为数据类型的默认值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//有一块内存存放了10，它的地址由系统自动分配，别名是a</span></span><br><span class="line">  a := <span class="number">10</span></span><br><span class="line">  <span class="comment">//内存存放的10变成了20</span></span><br><span class="line">  a = <span class="number">20</span></span><br><span class="line">  <span class="keyword">var</span> p *<span class="type">int</span></span><br><span class="line">  p = &amp;a   <span class="comment">//或者直接写 p := &amp;a</span></span><br><span class="line">  <span class="comment">//上面的p是一个指针，通过 *p 的方式同样可以访问 变量a指向 的内存</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*当你动态申请内存的时候，指针的存在意义之一就被体现出来了*/</span> </span><br><span class="line">  ptr := <span class="built_in">new</span>(<span class="type">int</span>)   </span><br><span class="line">  <span class="comment">//申请了一块内存空间，没有办法指定别名，new()返回内存地址，用指针接收</span></span><br><span class="line">  <span class="comment">//此时并没有变量能直接指向这块内存，所以只能通过内存地址来访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参见：<a href="https://tour.golang.org/moretypes/1">指针(Pointers)</a></p>
<h2 id="切片-Slices"><a href="#切片-Slices" class="headerlink" title="切片(Slices)"></a>切片(Slices)</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">3</span>)</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&quot;a&quot;</span></span><br><span class="line">s[<span class="number">1</span>] = <span class="string">&quot;b&quot;</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">&quot;d&quot;</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Println(s[<span class="number">1</span>])</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s))</span><br><span class="line">fmt.Println(s[<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>

<p>另见：<a href="https://gobyexample.com/slices">切片示例</a></p>
<h2 id="常量-Constants"><a href="#常量-Constants" class="headerlink" title="常量(Constants)"></a>常量(Constants)</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s <span class="type">string</span> = <span class="string">&quot;constant&quot;</span></span><br><span class="line"><span class="keyword">const</span> Phi = <span class="number">1.618</span></span><br><span class="line"><span class="keyword">const</span> n = <span class="number">500000000</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="number">3e20</span> / n</span><br></pre></td></tr></table></figure>

<p>常量声明可以使用 iota常量生成器 初始化，它用于<br>生成一组以相似规则初始化的常量，但是不用每行都<br>写一遍初始化表达式。<br>注意：</p>
<ol>
<li>在一个const声明语句中，在第一个声明的常量所在的行，iota被置为0，然后在每一个有常量声明的行加一。</li>
<li>写在同一行的值是相同的</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span></span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">)</span><br><span class="line"><span class="comment">// a = 0, b = 1, c = 2</span></span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>Go语言中不允许隐式转换，所有类型转换必须显式声明（强制转换），而且转换只能发生在两种相互兼容的类型之间。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">90</span></span><br><span class="line">f := <span class="type">float64</span>(i)</span><br><span class="line">u := <span class="type">uint</span>(i)</span><br><span class="line"><span class="comment">// 将等于字符Z</span></span><br><span class="line">s := <span class="type">string</span>(i)</span><br></pre></td></tr></table></figure>

<h3 id="如何获取int字符串？"><a href="#如何获取int字符串？" class="headerlink" title="如何获取int字符串？"></a>如何获取int字符串？</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">90</span></span><br><span class="line"><span class="comment">// 需要导入“strconv”</span></span><br><span class="line">s := strconv.Itoa(i)</span><br><span class="line">fmt.Println(s) <span class="comment">// Outputs: 90</span></span><br></pre></td></tr></table></figure>

<h1 id="Golang-字符串"><a href="#Golang-字符串" class="headerlink" title="Golang 字符串"></a>Golang 字符串</h1><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        s <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/* 需要将字符串导入为 s */</span></span><br><span class="line">        fmt.Println(s.Contains(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;e&quot;</span>))</span><br><span class="line">    <span class="comment">/* 内置 */</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(<span class="string">&quot;hello&quot;</span>))  <span class="comment">// =&gt; 5</span></span><br><span class="line">    <span class="comment">// 输出: 101</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;hello&quot;</span>[<span class="number">1</span>])</span><br><span class="line">    <span class="comment">// 输出: e</span></span><br><span class="line">        fmt.Println(<span class="type">string</span>(<span class="string">&quot;hello&quot;</span>[<span class="number">1</span>]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="fmt-Printf"><a href="#fmt-Printf" class="headerlink" title="fmt.Printf"></a>fmt.Printf</h2><!--rehype:wrap-class=row-span-2 col-span-2-->

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> point <span class="keyword">struct</span> &#123;</span><br><span class="line">        x, y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        p := point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, p)                        <span class="comment">// =&gt; &#123;1 2&#125;</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, p)                       <span class="comment">// =&gt; &#123;x:1 y:2&#125;</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p)                       <span class="comment">// =&gt; main.point&#123;x:1, y:2&#125;</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p)                        <span class="comment">// =&gt; main.point</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%t\n&quot;</span>, <span class="literal">true</span>)                     <span class="comment">// =&gt; TRUE</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, <span class="number">123</span>)                      <span class="comment">// =&gt; 123</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%b\n&quot;</span>, <span class="number">14</span>)                       <span class="comment">// =&gt; 1110</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%c\n&quot;</span>, <span class="number">33</span>)                       <span class="comment">// =&gt; !</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, <span class="number">456</span>)                      <span class="comment">// =&gt; 1c8</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%f\n&quot;</span>, <span class="number">78.9</span>)                     <span class="comment">// =&gt; 78.9</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%e\n&quot;</span>, <span class="number">123400000.0</span>)              <span class="comment">// =&gt; 1.23E+08</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%E\n&quot;</span>, <span class="number">123400000.0</span>)              <span class="comment">// =&gt; 1.23E+08</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;\&quot;string\&quot;&quot;</span>)             <span class="comment">// =&gt; &quot;string&quot;</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, <span class="string">&quot;\&quot;string\&quot;&quot;</span>)             <span class="comment">// =&gt; &quot;\&quot;string\&quot;&quot;</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, <span class="string">&quot;hex this&quot;</span>)               <span class="comment">// =&gt; 6.86578E+15</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;p)                       <span class="comment">// =&gt; 0xc00002c040</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;|%6d|%6d|\n&quot;</span>, <span class="number">12</span>, <span class="number">345</span>)           <span class="comment">// =&gt; |    12|   345|</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;|%6.2f|%6.2f|\n&quot;</span>, <span class="number">1.2</span>, <span class="number">3.45</span>)     <span class="comment">// =&gt; |  1.20|  3.45|</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;|%-6.2f|%-6.2f|\n&quot;</span>, <span class="number">1.2</span>, <span class="number">3.45</span>)   <span class="comment">// =&gt; |1.20  |3.45  |</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;|%6s|%6s|\n&quot;</span>, <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;b&quot;</span>)        <span class="comment">// =&gt; |   foo|     b|</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;|%-6s|%-6s|\n&quot;</span>, <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;b&quot;</span>)      <span class="comment">// =&gt; |foo   |b     |</span></span><br><span class="line">        s := fmt.Sprintf(<span class="string">&quot;a %s&quot;</span>, <span class="string">&quot;string&quot;</span>)</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">&quot;an %s\n&quot;</span>, <span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另见：<a href="https://golang.org/pkg/fmt/">fmt</a></p>
<h2 id="函数实例"><a href="#函数实例" class="headerlink" title="函数实例"></a>函数实例</h2><table>
<thead>
<tr>
<th>实例</th>
<th>Result</th>
</tr>
</thead>
<tbody><tr>
<td>Contains(“test”, “es”)</td>
<td>true</td>
</tr>
<tr>
<td>Count(“test”, “t”)</td>
<td>2</td>
</tr>
<tr>
<td>HasPrefix(“test”, “te”)</td>
<td>true</td>
</tr>
<tr>
<td>HasSuffix(“test”, “st”)</td>
<td>true</td>
</tr>
<tr>
<td>Index(“test”, “e”)</td>
<td>1</td>
</tr>
<tr>
<td>Join([]string{“a”, “b”}, “-“)</td>
<td>a-b</td>
</tr>
<tr>
<td>Repeat(“a”, 5)</td>
<td>aaaaa</td>
</tr>
<tr>
<td>Replace(“foo”, “o”, “0”, -1)</td>
<td>f00</td>
</tr>
<tr>
<td>Replace(“foo”, “o”, “0”, 1)</td>
<td>f0o</td>
</tr>
<tr>
<td>Split(“a-b-c-d-e”, “-“)</td>
<td>[a b c d e]</td>
</tr>
<tr>
<td>ToLower(“TEST”)</td>
<td>test</td>
</tr>
<tr>
<td>ToUpper(“test”)</td>
<td>TEST</td>
</tr>
</tbody></table>
<h1 id="Golang-条件控制"><a href="#Golang-条件控制" class="headerlink" title="Golang 条件控制"></a>Golang 条件控制</h1><h2 id="有条件的"><a href="#有条件的" class="headerlink" title="有条件的"></a>有条件的</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">20</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> a &lt; <span class="number">20</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;&lt;&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;=&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="if-中的语句"><a href="#if-中的语句" class="headerlink" title="if 中的语句"></a>if 中的语句</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="string">&quot;hello go!&quot;</span></span><br><span class="line"><span class="keyword">if</span> count := <span class="built_in">len</span>(x); count &gt; <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Yes&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, err := doThing(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Uh oh&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="number">42.0</span></span><br><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>:</span><br><span class="line">      fmt.Println(<span class="string">&quot;Multiple matches&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="number">42</span>:   <span class="comment">// Don&#x27;t &quot;fall through&quot;.</span></span><br><span class="line">      fmt.Println(<span class="string">&quot;reached&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="number">43</span>:</span><br><span class="line">      fmt.Println(<span class="string">&quot;Unreached&quot;</span>)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">      fmt.Println(<span class="string">&quot;Optional&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参见：<a href="https://github.com/golang/go/wiki/Switch">Switch</a></p>
<h2 id="For-loop"><a href="#For-loop" class="headerlink" title="For loop"></a>For loop</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;i: &quot;</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对于-Range-循环"><a href="#对于-Range-循环" class="headerlink" title="对于 Range 循环"></a>对于 Range 循环</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">  sum += num</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;sum:&quot;</span>, sum)</span><br></pre></td></tr></table></figure>

<h2 id="For-循环"><a href="#For-循环" class="headerlink" title="For 循环"></a>For 循环</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i &lt;= <span class="number">3</span> &#123;</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">  i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Continue-关键字"><a href="#Continue-关键字" class="headerlink" title="Continue 关键字"></a>Continue 关键字</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Break-关键字"><a href="#Break-关键字" class="headerlink" title="Break 关键字"></a>Break 关键字</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;loop&quot;</span>)</span><br><span class="line">  <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Golang-结构和Maps"><a href="#Golang-结构和Maps" class="headerlink" title="Golang 结构和Maps"></a>Golang 结构和Maps</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><!--rehype:wrap-class=row-span-2-->

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">        X <span class="type">int</span></span><br><span class="line">        Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">        v.X = <span class="number">4</span></span><br><span class="line">        fmt.Println(v.X, v.Y) <span class="comment">// =&gt; 4 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参见：<a href="https://tour.golang.org/moretypes/2">结构(Structs)</a></p>
<h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v := Vertex&#123;X: <span class="number">1</span>, Y: <span class="number">2</span>&#125;</span><br><span class="line"><span class="comment">// Field names can be omitted</span></span><br><span class="line">v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="comment">// Y is implicit</span></span><br><span class="line">v := Vertex&#123;X: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>您还可以输入字段名</p>
<h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><!--rehype:wrap-class=row-span-2-->

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">m[<span class="string">&quot;k1&quot;</span>] = <span class="number">7</span></span><br><span class="line">m[<span class="string">&quot;k2&quot;</span>] = <span class="number">13</span></span><br><span class="line">fmt.Println(m) <span class="comment">// =&gt; map[k1:7 k2:13]</span></span><br><span class="line">v1 := m[<span class="string">&quot;k1&quot;</span>]</span><br><span class="line">fmt.Println(v1)     <span class="comment">// =&gt; 7</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(m)) <span class="comment">// =&gt; 2</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;k2&quot;</span>)</span><br><span class="line">fmt.Println(m) <span class="comment">// =&gt; map[k1:7]</span></span><br><span class="line">_, prs := m[<span class="string">&quot;k2&quot;</span>]</span><br><span class="line">fmt.Println(prs) <span class="comment">// =&gt; false</span></span><br><span class="line">n := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;foo&quot;</span>: <span class="number">1</span>, <span class="string">&quot;bar&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(n) <span class="comment">// =&gt; map[bar:2 foo:1]</span></span><br></pre></td></tr></table></figure>

<h2 id="指向结构的指针"><a href="#指向结构的指针" class="headerlink" title="指向结构的指针"></a>指向结构的指针</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v := &amp;Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">v.X = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>Doing <code>v.X</code> is the same as doing <code>(*v).X</code>, when <code>v</code> is a pointer.</p>
<h1 id="Golang-函数"><a href="#Golang-函数" class="headerlink" title="Golang 函数"></a>Golang 函数</h1><h2 id="多个参数"><a href="#多个参数" class="headerlink" title="多个参数"></a>多个参数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plus</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plusPlus</span><span class="params">(a, b, c <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(plus(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">fmt.Println(plusPlus(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<h2 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">vals</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>, <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line">a, b := vals()</span><br><span class="line">fmt.Println(a)    <span class="comment">// =&gt; 3</span></span><br><span class="line">fmt.Println(b)    <span class="comment">// =&gt; 7</span></span><br></pre></td></tr></table></figure>

<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r1, r2 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line">    x := []<span class="type">string</span>&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">0</span>], x[<span class="number">1</span>]</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// =&gt; hello world</span></span><br><span class="line">fmt.Println(r1, r2)</span><br></pre></td></tr></table></figure>

<h2 id="命名返回值"><a href="#命名返回值" class="headerlink" title="命名返回值"></a>命名返回值</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="type">int</span>)</span></span> (x, y <span class="type">int</span>) &#123;</span><br><span class="line">  x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">  y = sum - x</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">x, y := split(<span class="number">17</span>)</span><br><span class="line">fmt.Println(x)   <span class="comment">// =&gt; 7</span></span><br><span class="line">fmt.Println(y)   <span class="comment">// =&gt; 10</span></span><br></pre></td></tr></table></figure>

<h2 id="可变参数函数"><a href="#可变参数函数" class="headerlink" title="可变参数函数"></a>可变参数函数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums ...<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  fmt.Print(nums, <span class="string">&quot; &quot;</span>)</span><br><span class="line">  total := <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">      total += num</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(total)</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>)     <span class="comment">// =&gt; [1 2] 3</span></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment">// =&gt; [1 2 3] 6</span></span><br><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">sum(nums...)  <span class="comment">// =&gt; [1 2 3 4] 10</span></span><br><span class="line"><span class="comment">// 不定参在内存中是连续存储的</span></span><br><span class="line"><span class="comment">// 不定参内部再传递的时候，参数也要是不定的</span></span><br></pre></td></tr></table></figure>

<h2 id="初始化函数"><a href="#初始化函数" class="headerlink" title="初始化函数"></a>初始化函数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> --&gt; <span class="keyword">const</span> --&gt; <span class="keyword">var</span> --&gt; init()</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = setNumber()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setNumber</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  num = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(num) <span class="comment">// =&gt; 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 将函数赋给名称</span></span><br><span class="line">  add := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a + b</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 使用名称调用函数</span></span><br><span class="line">  fmt.Println(add(<span class="number">3</span>, <span class="number">4</span>)) <span class="comment">// =&gt; 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><!--rehype:wrap-class=col-span-2 row-span-2-->

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">outer</span><span class="params">()</span></span> (<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    outer_var := <span class="number">2</span></span><br><span class="line">    inner := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        outer_var += <span class="number">99</span></span><br><span class="line">        <span class="keyword">return</span> outer_var</span><br><span class="line">    &#125;</span><br><span class="line">    inner()</span><br><span class="line">    <span class="keyword">return</span> inner, outer_var</span><br><span class="line">&#125;</span><br><span class="line">inner, val := outer()</span><br><span class="line">fmt.Println(val)</span><br><span class="line"><span class="comment">// =&gt; 101</span></span><br><span class="line">fmt.Println(inner())</span><br><span class="line"><span class="comment">// =&gt; 200，这里涉及到golang中闭包和内存逃逸的概念，inner()实际上执行了两次，outer()中一次，fmt又一次，</span></span><br><span class="line"><span class="comment">//但为什么是200呢，编译器不能确定outer_var在后续会不会使用，</span></span><br><span class="line"><span class="comment">//所以outer_var不会随着outer()结束而释放它的栈（Stack）空间，</span></span><br><span class="line"><span class="comment">//而会‘逃逸到’堆（Heap）上，那么第二次的inner()中outer_var就会是101。</span></span><br></pre></td></tr></table></figure>

<h2 id="关闭-1"><a href="#关闭-1" class="headerlink" title="关闭 1"></a>关闭 1</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scope</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span>&#123;</span><br><span class="line">  outer_var := <span class="number">2</span></span><br><span class="line">  foo := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;<span class="keyword">return</span> outer_var&#125;</span><br><span class="line">  <span class="keyword">return</span> foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Outpus: 2</span></span><br><span class="line">fmt.Println(scope()())</span><br></pre></td></tr></table></figure>

<h1 id="Golang-包-Packages"><a href="#Golang-包-Packages" class="headerlink" title="Golang 包(Packages)"></a>Golang 包(Packages)</h1><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><!--rehype:wrap-class=row-span-2-->

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math/rand&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="等同于"><a href="#等同于" class="headerlink" title="等同于"></a>等同于</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span>        <span class="comment">// 给 fmt.Println</span></span><br><span class="line">  <span class="string">&quot;math/rand&quot;</span>  <span class="comment">// 给 rand.Intn</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>另见：<a href="https://tour.golang.org/basics/1">导入</a></p>
<h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><!--rehype:wrap-class=row-span-2-->

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> r <span class="string">&quot;math/rand&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    r <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.Intn()</span><br></pre></td></tr></table></figure>

<h2 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">// 一个内部包只能被另一个包导入</span></span><br><span class="line"><span class="comment">// 那是在以内部目录的父级为根的树内</span></span><br><span class="line"><span class="keyword">package</span> internal</span><br></pre></td></tr></table></figure>

<p>另见：<a href="https://go.dev/doc/go1.4#internalpackages">内部包</a></p>
<h2 id="导出名称"><a href="#导出名称" class="headerlink" title="导出名称"></a>导出名称</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以大写字母开头</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另见：<a href="https://tour.golang.org/basics/3">导出的名称</a></p>
<h1 id="Golang-并发"><a href="#Golang-并发" class="headerlink" title="Golang 并发"></a>Golang 并发</h1><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><!--rehype:wrap-class=row-span-2-->

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(from <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">            fmt.Println(from, <span class="string">&quot;:&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f(<span class="string">&quot;direct&quot;</span>)</span><br><span class="line">    <span class="keyword">go</span> f(<span class="string">&quot;goroutine&quot;</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">            fmt.Println(msg)</span><br><span class="line">    &#125;(<span class="string">&quot;going&quot;</span>)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参见：<a href="https://tour.golang.org/concurrency/1">Goroutines</a>, <a href="https://tour.golang.org/concurrency/2">Channels</a></p>
<h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h2><!--rehype:wrap-class=row-span-2-->

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">w</span><span class="params">(id <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d starting\n&quot;</span>, id)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d done\n&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">            wg.Add(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">go</span> w(i, &amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参见：<a href="https://golang.org/pkg/sync/#WaitGroup">WaitGroup</a></p>
<h2 id="Closing-channels"><a href="#Closing-channels" class="headerlink" title="Closing channels"></a>Closing channels</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line">ch &lt;- <span class="number">3</span></span><br><span class="line"><span class="built_in">close</span>(ch) <span class="comment">// 关闭频道</span></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代通道直到关闭</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ch &#123;</span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Closed if `ok == false`</span></span><br><span class="line">v, ok := &lt;- ch</span><br></pre></td></tr></table></figure>

<p>参见：<a href="https://tour.golang.org/concurrency/4">范围和关闭</a></p>
<h2 id="缓冲通道"><a href="#缓冲通道" class="headerlink" title="缓冲通道"></a>缓冲通道</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line">ch &lt;- <span class="number">3</span></span><br><span class="line"><span class="comment">// 致命错误：</span></span><br><span class="line"><span class="comment">// 所有 goroutine 都处于休眠状态 - 死锁</span></span><br></pre></td></tr></table></figure>

<p>参见：<a href="https://tour.golang.org/concurrency/3">缓冲通道</a></p>
<h1 id="Golang-错误控制"><a href="#Golang-错误控制" class="headerlink" title="Golang 错误控制"></a>Golang 错误控制</h1><h2 id="延迟函数"><a href="#延迟函数" class="headerlink" title="延迟函数"></a>延迟函数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">  &#125;()</span><br><span class="line">  fmt.Println(<span class="string">&quot;Working...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lambda-defer"><a href="#Lambda-defer" class="headerlink" title="Lambda defer"></a>Lambda defer</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(d *<span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;&amp; %v Unix Sec\n&quot;</span>, *d)</span><br><span class="line">  &#125;(&amp;d)</span><br><span class="line">  fmt.Print(<span class="string">&quot;Done &quot;</span>)</span><br><span class="line">  d = time.Now().Unix()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>defer</code> 函数使用当前值<code>d</code>，除非我们使用指针在 <code>main</code> 末尾获取最终值</p>
<h2 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a>Defer</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">  fmt.Println(<span class="string">&quot;Working...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参见：<a href="https://blog.golang.org/defer-panic-and-recover">Defer, panic and recover</a></p>
<h1 id="Golang-方法-Methods"><a href="#Golang-方法-Methods" class="headerlink" title="Golang 方法(Methods)"></a>Golang 方法(Methods)</h1><!--rehype:body-class=cols-2-->

<h2 id="接收器"><a href="#接收器" class="headerlink" title="接收器"></a>接收器</h2><!--rehype:wrap-class=row-span-2-->

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Go语言中的方法（Method）是一种作用于特定类型变量的函数。</span></span><br><span class="line"><span class="comment">//这种特定类型变量叫做接收者（Receiver）。</span></span><br><span class="line"><span class="comment">//接收者的概念就类似于其他语言中的 this 或者 self。</span></span><br><span class="line"><span class="comment">//方法的定义格式如下：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span></span> 方法名(参数列表) (返回参数) &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其中，</span></span><br><span class="line"><span class="comment">//     1.接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名</span></span><br><span class="line"><span class="comment">//的第一个小写字母，而不是self、this之类的命名。例如，Person类型的接收者变量</span></span><br><span class="line"><span class="comment">// 应该命名为 p，Connector类型的接收者变量应该命名为c等。</span></span><br><span class="line"><span class="comment">//     2.接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</span></span><br><span class="line"><span class="comment">//     3.方法名、参数列表、返回参数：具体格式与函数定义相同。</span></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">  X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> math.Sqrt(v.X * v.X + v.Y * v.Y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> valuechange() <span class="type">float64</span> &#123;</span><br><span class="line">  v.X += <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> v.X</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> pointerchange() <span class="type">float64</span> &#123;</span><br><span class="line">  v.X += <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> v.X</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">  v.Abs()</span><br><span class="line"></span><br><span class="line">  v = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">  fmt.Println(v.valuechange())  <span class="comment">// 2</span></span><br><span class="line">  fmt.Println(v)                <span class="comment">// &#123;1 2&#125;</span></span><br><span class="line"></span><br><span class="line">  v = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">  fmt.Println(v.pointerchange())<span class="comment">// 2</span></span><br><span class="line">  fmt.Println(v)                <span class="comment">// &#123;2 2&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果在方法里修改receiver的值要对caller生效，使用 pointer receiver。</span></span><br></pre></td></tr></table></figure>

<p>参见：<a href="https://tour.golang.org/methods/1">Methods</a>，<a href="https://tour.golang.org/methods/4">指针接收器</a></p>
<h2 id="方法表达式"><a href="#方法表达式" class="headerlink" title="方法表达式"></a>方法表达式</h2><p>方法表达式相当于提供一种语法将类型方法调用显式地转换为函数调用，接收者(receiver)必须显式地传递进去。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> Get()&#123;</span><br><span class="line">    <span class="keyword">return</span> t.a</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> Set(i <span class="type">int</span>)&#123;</span><br><span class="line">    t.a = i</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//表达式`T.Get`和`(*T).Set`被称为方法表达式，</span></span><br><span class="line"><span class="comment">//需要注意的是在方法表达式中编译器不会做自动转换。</span></span><br><span class="line"><span class="comment">//值调用会自动转换，表达式调用则不会，例如：</span></span><br><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Data)</span></span> TestValue () &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Data)</span></span> TestPointer () &#123;&#125; </span><br><span class="line"><span class="comment">//声明一个类型变量a</span></span><br><span class="line"><span class="keyword">var</span> a Data= <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="comment">//表达式调用编译器不会进行自动转换</span></span><br><span class="line">Data.TestValue(a) </span><br><span class="line"><span class="comment">//Data.TestValue(&amp;a) </span></span><br><span class="line">(*Data).TestPointer (&amp;a) </span><br><span class="line"><span class="comment">//Data.TestPointer(&amp;a) //type Data has no method TestPointer </span></span><br><span class="line"><span class="comment">//值调用编译器会进行自动转换</span></span><br><span class="line">y : = (&amp;a).TestValue <span class="comment">//编译器帮助转换a.TestValue</span></span><br><span class="line">g : = a.TestPointer <span class="comment">//会转换为(&amp;a).TestPointer </span></span><br></pre></td></tr></table></figure>

<h3 id="组合结构的方法集"><a href="#组合结构的方法集" class="headerlink" title="组合结构的方法集"></a>组合结构的方法集</h3><p>内嵌字段的访问不需要使用全路径，只要保证命名是唯一的就可以，尽量避免同名。如果外层字段和内层字段有相同的方法，则使用简化模式访问外层方法会覆盖内层的方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x : = X&#123;a: <span class="number">1</span>&#125; </span><br><span class="line">y : = Y&#123; </span><br><span class="line">    X : x , </span><br><span class="line">    b : <span class="number">2</span> , </span><br><span class="line">&#125;</span><br><span class="line">z : = z &#123; </span><br><span class="line">    Y : y , </span><br><span class="line">    c : <span class="number">3</span> ,</span><br><span class="line">&#125;<span class="comment">//组合结构，内嵌字段</span></span><br></pre></td></tr></table></figure>

<p>组合结构的方法集有如下规则：</p>
<ul>
<li>若类型 T 包含匿名字段 S ，则 T 的方法集包含S的方法集</li>
<li>若类型 T 包含匿名字段 <em>S ，则 T 的方法集包含 S 和</em>S方法集</li>
<li>不管类型 T 中嵌入的匿名字段是 S 还是 <em>S ，</em>T 方法集总是包含 S 和 *S 方法集</li>
</ul>
<h1 id="Golang-接口-Interfaces"><a href="#Golang-接口-Interfaces" class="headerlink" title="Golang 接口(Interfaces)"></a>Golang 接口(Interfaces)</h1><!--rehype:body-class=cols-2-->

<h2 id="基本接口-Interfaces"><a href="#基本接口-Interfaces" class="headerlink" title="基本接口(Interfaces)"></a>基本接口(Interfaces)</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Shape <span class="keyword">interface</span> &#123;</span><br><span class="line">  Area() <span class="type">float64</span></span><br><span class="line">  Perimeter() <span class="type">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构-Struct"><a href="#结构-Struct" class="headerlink" title="结构(Struct)"></a>结构(Struct)</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">  Length, Width <span class="type">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构 <code>Rectangle</code> 通过实现其所有方法隐式实现接口 <code>Shape</code></p>
<h2 id="方法-Methods"><a href="#方法-Methods" class="headerlink" title="方法(Methods)"></a>方法(Methods)</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span></span> Area() <span class="type">float64</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> r.Length * r.Width</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span></span> Perimeter() <span class="type">float64</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * (r.Length + r.Width)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>Shape</code> 中定义的方法在<code>Rectangle</code>中实现</p>
<h2 id="接口实例"><a href="#接口实例" class="headerlink" title="接口实例"></a>接口实例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> r Shape = Rectangle&#123;Length: <span class="number">3</span>, Width: <span class="number">4</span>&#125;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;Type of r: %T, Area: %v, Perimeter: %v.&quot;</span>, r, r.Area(), r.Perimeter())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--rehype:className=wrap-text -->

<h1 id="Golang-Embed-Go-version-1-16"><a href="#Golang-Embed-Go-version-1-16" class="headerlink" title="Golang Embed (Go version &gt;&#x3D; 1.16)"></a>Golang Embed (Go version &gt;&#x3D; 1.16)</h1><h2 id="嵌入为string"><a href="#嵌入为string" class="headerlink" title="嵌入为string"></a>嵌入为string</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">&quot;embed&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:embed version.txt</span></span><br><span class="line"><span class="keyword">var</span> version <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;version %q\n&quot;</span>, version)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="嵌入为-byte"><a href="#嵌入为-byte" class="headerlink" title="嵌入为[]byte"></a>嵌入为[]byte</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">&quot;embed&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:embed version.txt</span></span><br><span class="line"><span class="keyword">var</span> versionByte []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;version %q\n&quot;</span>, <span class="type">string</span>(versionByte))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="嵌入为embed-FS"><a href="#嵌入为embed-FS" class="headerlink" title="嵌入为embed.FS"></a>嵌入为embed.FS</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:embed hello.txt</span></span><br><span class="line"><span class="keyword">var</span> f embed.FS</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  data, _ := f.ReadFile(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">  fmt.Println(<span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="嵌入多个文件"><a href="#嵌入多个文件" class="headerlink" title="嵌入多个文件"></a>嵌入多个文件</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:embed hello.txt</span></span><br><span class="line"><span class="comment">//go:embed hello2.txt</span></span><br><span class="line"><span class="keyword">var</span> f embed.FS</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  data, _ := f.ReadFile(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">  fmt.Println(<span class="type">string</span>(data))</span><br><span class="line">  data, _ = f.ReadFile(<span class="string">&quot;hello2.txt&quot;</span>)</span><br><span class="line">  fmt.Println(<span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="嵌入子文件夹下的文件"><a href="#嵌入子文件夹下的文件" class="headerlink" title="嵌入子文件夹下的文件"></a>嵌入子文件夹下的文件</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:embed p/hello.txt p/hello2.txt</span></span><br><span class="line"><span class="keyword">var</span> f embed.FS</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  data, _ := f.ReadFile(<span class="string">&quot;p/hello.txt&quot;</span>)</span><br><span class="line">  fmt.Println(<span class="type">string</span>(data))</span><br><span class="line">  data, _ = f.ReadFile(<span class="string">&quot;p/hello2.txt&quot;</span>)</span><br><span class="line">  fmt.Println(<span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="同一个文件嵌入为多个变量"><a href="#同一个文件嵌入为多个变量" class="headerlink" title="同一个文件嵌入为多个变量"></a>同一个文件嵌入为多个变量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:embed hello.txt</span></span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line"><span class="comment">//go:embed hello.txt</span></span><br><span class="line"><span class="keyword">var</span> s2 <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(s)</span><br><span class="line">  fmt.Println(s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:embed p/*</span></span><br><span class="line"><span class="keyword">var</span> f embed.FS</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  data, _ := f.ReadFile(<span class="string">&quot;p/.hello.txt&quot;</span>)</span><br><span class="line">  fmt.Println(<span class="type">string</span>(data))</span><br><span class="line">  data, _ = f.ReadFile(<span class="string">&quot;p/q/.hi.txt&quot;</span>) <span class="comment">// 没有嵌入 p/q/.hi.txt</span></span><br><span class="line">  fmt.Println(<span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Golang-泛型-Go-version-1-18"><a href="#Golang-泛型-Go-version-1-18" class="headerlink" title="Golang 泛型 (Go version &gt;&#x3D; 1.18)"></a>Golang 泛型 (Go version &gt;&#x3D; 1.18)</h1><h2 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h2><!--rehype:wrap-class=row-span-1-->

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">type S[T int|float32|float64 ] []T</span><br><span class="line">       ┬  ────────┬──────── </span><br><span class="line">       ┆          ╰─── 2. 类型约束</span><br><span class="line">       ╰────────────── 1. 类型形参</span><br></pre></td></tr></table></figure>

<!--rehype:className=wrap-text -->

<p>可以使用类型实参 int 或 string 实例化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyMap[K <span class="type">int</span>|<span class="type">string</span>, V <span class="type">float32</span> | <span class="type">float64</span>] <span class="keyword">map</span>[K]V</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a MyMap[<span class="type">string</span>, <span class="type">float64</span>] = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">float64</span>&#123;</span><br><span class="line">    <span class="string">&quot;jack_score&quot;</span>: <span class="number">9.6</span>,</span><br><span class="line">    <span class="string">&quot;bob_score&quot;</span>:  <span class="number">8.4</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--rehype:className=wrap-text -->

<ul>
<li><strong>匿名结构体不支持泛型</strong><!--rehype:style=color: #b43c29;--></li>
<li><strong>匿名函数不支持泛型</strong><!--rehype:style=color: #b43c29;--></li>
</ul>
<h2 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h2><!--rehype:wrap-class=row-span-1-->

<p>任意类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(a,b T)</span></span> T &#123;</span><br><span class="line">    <span class="keyword">return</span>  a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对类型进行约束</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span>[<span class="title">T</span> <span class="title">string</span> | <span class="title">int</span> | <span class="title">int8</span>]<span class="params">(a,b T)</span></span> T &#123;</span><br><span class="line">    <span class="keyword">return</span>  a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型嵌套</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WowStruct[T <span class="type">int</span> | <span class="type">float32</span>, S []T] <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data     S</span><br><span class="line">    MaxValue T</span><br><span class="line">    MinValue T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ws WowStruct[<span class="type">int</span>, []<span class="type">int</span>]  </span><br></pre></td></tr></table></figure>

<!--rehype:className=wrap-text -->

<p>泛型函数中进行类型声明 (go version &gt;&#x3D; 1.20)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span>[<span class="title">T1</span> <span class="title">any</span>]<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">type</span> x <span class="keyword">struct</span>&#123;&#125; </span><br><span class="line">    <span class="keyword">type</span> y = x      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><!--rehype:wrap-class=row-span-2-->

<p>通过接口实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Addable <span class="keyword">interface</span>&#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="type">int</span>, <span class="type">int8</span>, <span class="type">int16</span>, <span class="type">int32</span>, <span class="type">int64</span>, <span class="type">uint</span>, <span class="type">uint8</span>, <span class="type">uint16</span>, <span class="type">uint32</span>, <span class="type">uint64</span>, <span class="type">uintptr</span>, <span class="type">float32</span>, <span class="type">float64</span>, <span class="type">complex64</span>, <span class="type">complex128</span>, <span class="type">string</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span>[<span class="title">T</span> <span class="title">Addable</span>]<span class="params">(a,b T)</span></span> T &#123;</span><br><span class="line">    <span class="keyword">return</span>  a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--rehype:className=wrap-text -->

<p>使用 ~ 符号</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Int <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">int</span> | ~<span class="type">int8</span> | ~<span class="type">int16</span> | ~<span class="type">int32</span> | ~<span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Uint <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Float <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">float32</span> | ~<span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slice[T Int | Uint | Float] []T </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s Slice[<span class="type">int</span>] <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> s2 Slice[MyInt]  <span class="comment">// MyInt底层类型是int，所以可以用于实例化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyMyInt MyInt</span><br><span class="line"><span class="keyword">var</span> s3 Slice[MyMyInt]  <span class="comment">// 正确。MyMyInt 虽然基于 MyInt ，但底层类型也是int，所以也能用于实例化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat32 <span class="type">float32</span>  <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> s4 Slice[MyFloat32]</span><br></pre></td></tr></table></figure>

<!--rehype:className=wrap-text -->

<p>使用 ~ 时的限制：</p>
<!--rehype:style=color: #b43c29;-->

<ol>
<li><p>~后面的类型不能为接口</p>
</li>
<li><p>~后面的类型必须为基本类型</p>
<!--rehype:style=color: #b43c29;--></li>
</ol>
<h2 id="泛型-Receiver"><a href="#泛型-Receiver" class="headerlink" title="泛型 Receiver"></a>泛型 Receiver</h2><!--rehype:wrap-class=row-span-1-->

<p>定义普通类型支持泛型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MySlice[T <span class="type">int</span> | <span class="type">float32</span>] []T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s MySlice[T])</span></span> Sum() T &#123;</span><br><span class="line">    <span class="keyword">var</span> sum T</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> s &#123;</span><br><span class="line">        sum += value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--rehype:className=wrap-text -->

<p>结构体支持泛型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A[T <span class="type">int</span> | <span class="type">float32</span> | <span class="type">float64</span>] <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver A[T])</span></span> Add(a T, b T) T &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--rehype:className=wrap-text -->

<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><!--rehype:wrap-class=row-span-1-->

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Uint <span class="keyword">interface</span> &#123; <span class="comment">// 接口 Uint 中有类型，所以是一般接口</span></span><br><span class="line">    ~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;  <span class="comment">// ReadWriter 接口既有方法也有类型，所以是一般接口</span></span><br><span class="line">    ~<span class="type">string</span> | ~[]<span class="type">rune</span></span><br><span class="line"></span><br><span class="line">    Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">    Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--rehype:className=wrap-text -->

<p>一般接口类型不能用来定义变量，只能用于泛型的类型约束中</p>
<!--rehype:style=color: #b43c29;-->

<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="关键字-Keywords"><a href="#关键字-Keywords" class="headerlink" title="关键字(Keywords)"></a>关键字(Keywords)</h2><ul>
<li><p>break</p>
</li>
<li><p>default</p>
</li>
<li><p>func</p>
</li>
<li><p>interface</p>
</li>
<li><p>select</p>
</li>
<li><p>case</p>
</li>
<li><p>defer</p>
</li>
<li><p>go</p>
</li>
<li><p>map</p>
</li>
<li><p>struct</p>
</li>
<li><p>chan</p>
</li>
<li><p>else</p>
</li>
<li><p>goto</p>
</li>
<li><p>package</p>
</li>
<li><p>switch</p>
</li>
<li><p>const</p>
</li>
<li><p>fallthrough</p>
</li>
<li><p>if</p>
</li>
<li><p>range</p>
</li>
<li><p>type</p>
</li>
<li><p>continue</p>
</li>
<li><p>for</p>
</li>
<li><p>import</p>
</li>
<li><p>return</p>
</li>
<li><p>var</p>
<!--rehype:className=cols-3 style-none--></li>
</ul>
<h2 id="运算符和标点符号"><a href="#运算符和标点符号" class="headerlink" title="运算符和标点符号"></a>运算符和标点符号</h2><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td><code>&amp;</code></td>
<td><code>+=</code></td>
<td><code>&amp;=</code></td>
<td><code>&amp;&amp;</code></td>
<td><code>==</code></td>
<td><code>!=</code></td>
<td><code>(</code></td>
<td><code>)</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td><code>|</code></td>
<td><code>-=</code></td>
<td><code>|=</code></td>
<td><code>||</code></td>
<td><code>&lt;</code></td>
<td><code>&lt;=</code></td>
<td><code>[</code></td>
<td><code>]</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td><code>^</code></td>
<td><code>*=</code></td>
<td><code>^=</code></td>
<td><code>&lt;-</code></td>
<td><code>&gt;</code></td>
<td><code>&gt;=</code></td>
<td><code>&#123;</code></td>
<td><code>&#125;</code></td>
</tr>
<tr>
<td><code>/</code></td>
<td><code>&lt;&lt;</code></td>
<td><code>/=</code></td>
<td><code>&lt;&lt;=</code></td>
<td><code>++</code></td>
<td><code>=</code></td>
<td><code>:=</code></td>
<td><code>,</code></td>
<td><code>;</code></td>
</tr>
<tr>
<td><code>%</code></td>
<td><code>&gt;&gt;</code></td>
<td><code>%=</code></td>
<td><code>&gt;&gt;=</code></td>
<td><code>--</code></td>
<td><code>!</code></td>
<td><code>...</code></td>
<td><code>.</code></td>
<td><code>:</code></td>
</tr>
<tr>
<td></td>
<td><code>&amp;^</code></td>
<td><code>&amp;^=</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="Go-命令"><a href="#Go-命令" class="headerlink" title="Go 命令"></a>Go 命令</h1><h2 id="Go-编译器命令"><a href="#Go-编译器命令" class="headerlink" title="Go 编译器命令"></a>Go 编译器命令</h2><table>
<thead>
<tr>
<th align="left">:-</th>
<th>–</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>go command [参数]</code></td>
<td>go 命令 [参数]</td>
</tr>
<tr>
<td align="left"><code>go build</code></td>
<td>编译包和依赖包</td>
</tr>
<tr>
<td align="left"><code>go clean</code></td>
<td>移除对象和缓存文件</td>
</tr>
<tr>
<td align="left"><code>go doc</code></td>
<td>显示包的文档</td>
</tr>
<tr>
<td align="left"><code>go env</code></td>
<td>打印go的环境变量信息</td>
</tr>
<tr>
<td align="left"><code>go bug</code></td>
<td>报告bug</td>
</tr>
<tr>
<td align="left"><code>go fix</code></td>
<td>更新包使用新的api</td>
</tr>
<tr>
<td align="left"><code>go fmt</code></td>
<td>格式规范化代码</td>
</tr>
<tr>
<td align="left"><code>go generate</code></td>
<td>通过处理资源生成go文件</td>
</tr>
<tr>
<td align="left"><code>go get</code></td>
<td>下载并安装包及其依赖</td>
</tr>
<tr>
<td align="left"><code>go install</code></td>
<td>编译和安装包及其依赖</td>
</tr>
<tr>
<td align="left"><code>go list</code></td>
<td>列出所有包</td>
</tr>
<tr>
<td align="left"><code>go run</code></td>
<td>编译和运行go程序</td>
</tr>
<tr>
<td align="left"><code>go test</code></td>
<td>测试</td>
</tr>
<tr>
<td align="left"><code>go tool</code></td>
<td>运行给定的go工具</td>
</tr>
<tr>
<td align="left"><code>go version</code></td>
<td>显示go当前版本</td>
</tr>
<tr>
<td align="left"><code>go vet</code></td>
<td>发现代码中可能的错误</td>
</tr>
</tbody></table>
<h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h2><table>
<thead>
<tr>
<th align="left">:-</th>
<th>–</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>GOOS</code></td>
<td>编译系统</td>
</tr>
<tr>
<td align="left"><code>GOARCH</code></td>
<td>编译arch</td>
</tr>
<tr>
<td align="left"><code>GO111MODULE</code></td>
<td>gomod开关</td>
</tr>
<tr>
<td align="left"><code>GOPROXY</code></td>
<td>go代理 <a href="https://goproxy.io/">https://goproxy.io</a>  <a href="https://goproxy.cn/">https://goproxy.cn</a>  <a href="https://mirrors.aliyun.com/goproxy/">https://mirrors.aliyun.com/goproxy/</a></td>
</tr>
<tr>
<td align="left"><code>GOSSAFUNC</code></td>
<td>生成 <code>SSA.html</code> 文件，展示代码优化的每一步 <code>GOSSAFUNC=func_name go build</code></td>
</tr>
</tbody></table>
<!--rehype:className=style-list-arrow-->

<h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><table>
<thead>
<tr>
<th align="left">:-</th>
<th>–</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>go mod init</code></td>
<td>初始化当前文件夹，创建go.mod文件</td>
</tr>
<tr>
<td align="left"><code>go mod download</code></td>
<td>下载依赖的module到本地</td>
</tr>
<tr>
<td align="left"><code>go mod tidy</code></td>
<td>增加缺少的module，删除无用的module</td>
</tr>
<tr>
<td align="left"><code>go mod vendor</code></td>
<td>将依赖复制到vendor下</td>
</tr>
<tr>
<td align="left">文件 <code>go.mod</code></td>
<td>依赖列表和版本约束</td>
</tr>
<tr>
<td align="left">文件 <code>go.sum</code></td>
<td>记录 <code>module</code> 文件 <code>hash</code> 值，用于安全校验</td>
</tr>
</tbody></table>
<!--rehype:className=style-list-arrow-->

<h1 id="另见"><a href="#另见" class="headerlink" title="另见"></a>另见</h1><ul>
<li><a href="https://devhints.io/go">Devhints</a> <em>(devhints.io)</em></li>
<li><a href="https://tour.golang.org/welcome/1">A tour of Go</a> <em>(tour.golang.org)</em></li>
<li><a href="https://github.com/golang/go/wiki/">Golang wiki</a> <em>(github.com)</em></li>
<li><a href="https://golang.org/doc/effective_go.html">Effective Go</a> <em>(golang.org)</em></li>
<li><a href="https://gobyexample.com/">Go by Example</a> <em>(gobyexample.com)</em></li>
<li><a href="https://awesome-go.com/">Awesome Go</a> <em>(awesome-go.com)</em></li>
<li><a href="https://www.youtube.com/channel/UC_BzFbxG2za3bp5NRRRXJSw">JustForFunc Youtube</a> <em>(youtube.com)</em></li>
<li><a href="https://github.com/golang/go/wiki/CodeReviewComments">Style Guide</a> <em>(github.com)</em></li>
</ul>
]]></content>
      <categories>
        <category>语言指南</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Lombok常用注解</title>
    <url>/blog/2023/07/06/Lombok/</url>
    <content><![CDATA[<h1 id="RequiredArgsConstructor"><a href="#RequiredArgsConstructor" class="headerlink" title="@RequiredArgsConstructor"></a><code>@RequiredArgsConstructor</code></h1><p><code>@RequiredArgsConstructor</code> 注解是 Lombok 提供的一个功能注解，它可以为包含 <code>final</code> 或 <code>@NonNull</code> 修饰的字段生成构造函数参数。</p>
<p>使用 <code>@RequiredArgsConstructor</code> 注解时，Lombok 会根据类中的字段自动生成一个构造函数，该构造函数只接受被修饰字段作为参数，并将这些参数用于初始化对象的对应字段。通过自动生成的构造函数，可以方便地为带有 <code>final</code> 或 <code>@NonNull</code> 修饰的字段赋值，避免了手动编写构造函数的繁琐工作。</p>
<p>需要注意的是，<code>@RequiredArgsConstructor</code> 注解不会为非 <code>final</code> 或无 <code>@NonNull</code> 修饰的字段生成构造函数参数，也不会为静态字段生成构造函数参数。</p>
<p>以下是使用 <code>@RequiredArgsConstructor</code> 注解的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ID: &quot;</span> + id);</span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;Age: &quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动生成的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，使用 <code>@RequiredArgsConstructor</code> 注解后，自动生成了一个构造函数，接受 <code>id</code> 和 <code>name</code> 字段作为参数，并将它们赋值给相应的字段。</p>
<p>需要注意的是，为了正确使用 <code>@RequiredArgsConstructor</code> 注解，请确保类中的字段被声明为实例变量，并且具有 <code>final</code> 或 <code>@NonNull</code> 修饰。</p>
<h1 id="EqualsAndHashCode-callSuper-true"><a href="#EqualsAndHashCode-callSuper-true" class="headerlink" title="@EqualsAndHashCode(callSuper = true)"></a><code>@EqualsAndHashCode(callSuper = true)</code></h1><p><code>@EqualsAndHashCode(callSuper = true)</code> 和不加 <code>callSuper</code> 的区别在于生成的 <code>equals()</code> 和 <code>hashCode()</code> 方法是否包含父类的字段。</p>
<p>当你在一个子类中使用 <code>@EqualsAndHashCode</code> 注解时，默认情况下只会生成处理当前类的字段的 <code>equals()</code> 和 <code>hashCode()</code> 方法。这意味着父类的字段不会被考虑在内。</p>
<p>然而，如果你将 <code>callSuper</code> 参数设置为 <code>true</code>，生成的方法将会调用父类中的对应方法，并包括父类的字段。这样做可以确保生成的方法同时包含父类和子类的字段。</p>
<p>下面是一个示例来说明两者之间的区别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> parentId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter, setter, 其他方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> childId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter, setter, 其他方法...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">// 手动编写 equals() 方法，不调用父类方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Child</span> <span class="variable">child</span> <span class="operator">=</span> (Child) o;</span><br><span class="line">        <span class="keyword">return</span> childId == child.childId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 手动编写 hashCode() 方法，不调用父类方法</span></span><br><span class="line">        <span class="keyword">return</span> Objects.hash(childId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>Child</code> 类手动编写了 <code>equals()</code> 和 <code>hashCode()</code> 方法，并且只考虑了子类的字段 <code>childId</code>。父类的字段 <code>parentId</code> 没有被包含在内。</p>
<p>相比之下，在使用 <code>@EqualsAndHashCode(callSuper = true)</code> 注解的情况下，生成的方法将同时处理父类和子类的字段。</p>
<p>总结来说，<code>@EqualsAndHashCode(callSuper = true)</code> 会自动生成的 <code>equals()</code> 和 <code>hashCode()</code> 方法将同时包含父类和子类的字段；而默认情况下不带 <code>callSuper</code> 的 <code>@EqualsAndHashCode</code> 注解只会处理当前类的字段。</p>
]]></content>
      <categories>
        <category>实用工具</category>
      </categories>
      <tags>
        <tag>Lombok</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/blog/2023/07/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h1><ul>
<li><p><strong>创建型模式</strong></p>
<p>用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。</p>
</li>
<li><p><strong>结构型模式</strong></p>
<p>用于描述如何将类或对象按某种布局组成更大的结构，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。</p>
</li>
<li><p><strong>行为型模式</strong></p>
<p>用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。</p>
</li>
</ul>
<h1 id="创建型-单例模式-Singleton-pattern"><a href="#创建型-单例模式-Singleton-pattern" class="headerlink" title="创建型-单例模式(Singleton pattern)"></a>创建型-单例模式(Singleton pattern)</h1><blockquote>
<p>单例模式(Singleton pattern)确保一个类只有一个实例，并提供该实例的全局访问点</p>
</blockquote>
<p>通过单例的创建时机分类，可分为懒汉式和饿汉式</p>
<table>
<thead>
<tr>
<th>实现类型</th>
<th>单例创建时机</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>饿汉式</td>
<td>- 不可控，类加载时自动创建单例</td>
<td>初始化时就需要创建单例，希望单例对象初始化速度快，适合占用内存小的单例</td>
</tr>
<tr>
<td>懒汉式</td>
<td>可控，有需要时才手动创建单例</td>
<td>按需、延迟创建单例，单例初始化时间长，希望后续再加载此单例以提高服务启动速度，单例占用内存高</td>
</tr>
</tbody></table>
<h2 id="饿汉式最佳实践-枚举类"><a href="#饿汉式最佳实践-枚举类" class="headerlink" title="饿汉式最佳实践-枚举类"></a>饿汉式最佳实践-枚举类</h2><p><strong>枚举类的特点是：</strong></p>
<ul>
<li>不可被继承（final）</li>
</ul>
<ul>
<li><p>线程安全，每个枚举元素都是类静态常量，只会被装载一次</p>
</li>
<li><p>枚举元素都通过静态代码块来进行初始化</p>
</li>
<li><p>默认构造方法是私有的</p>
</li>
<li><p>大部分方法都是final</p>
</li>
</ul>
<p><strong>通过枚举类型实现优点是：</strong></p>
<ul>
<li><p>线程安全</p>
</li>
<li><p>自由序列化</p>
</li>
<li><p>实现更加简单、简洁</p>
</li>
</ul>
<p>唯一缺点就是饿汉式的缺点：创建时机不可控</p>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    uniqueInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="懒汉式最佳实现-静态内部类"><a href="#懒汉式最佳实现-静态内部类" class="headerlink" title="懒汉式最佳实现-静态内部类"></a>懒汉式最佳实现-静态内部类</h2><p>当 Singleton 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 <code>getUniqueInstance()</code> 方法从而触发 <code>SingletonHolder.INSTANCE</code> 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例。</p>
<p>这种方式不仅具有延迟初始化的好处，而且由虚拟机提供了对线程安全的支持。</p>
<p><strong>优点：</strong></p>
<ul>
<li><p>线程安全</p>
</li>
<li><p>节省资源（不需要过多同步开销）</p>
</li>
<li><p>实现简单</p>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="创建型-简单工厂-Simple-Factory"><a href="#创建型-简单工厂-Simple-Factory" class="headerlink" title="创建型-简单工厂(Simple Factory)"></a>创建型-简单工厂(Simple Factory)</h1><blockquote>
<p>工厂模式是在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口</p>
<p><strong>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程</strong></p>
</blockquote>
<p>把实例化的操作单独放到一个类中，这个类就成为简单工厂类</p>
<p>让简单工厂类来决定应该用哪个具体子类来实例化，这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类</p>
<p>简单工厂模式适用于以下场景：</p>
<ol>
<li>当需要创建的对象只有一个具体产品类时；</li>
<li>创建对象的逻辑较为简单，不需要涉及复杂的业务逻辑；</li>
<li>不需要频繁地添加新的产品种类。</li>
</ol>
<h2 id="示例：啥咖啡都有的咖啡店"><a href="#示例：啥咖啡都有的咖啡店" class="headerlink" title="示例：啥咖啡都有的咖啡店"></a>示例：啥咖啡都有的咖啡店</h2><blockquote>
<p>简单工厂模式适用于只需要创建单一种类的产品的情况。如果你只需要某一种产品，而且不涉及到多个产品族的情况，可以选择简单工厂模式。简单工厂模式通过一个工厂类，根据传入的参数或条件来创建不同的产品。</p>
</blockquote>
<p>根据咖啡店需求的咖啡类型，咖啡工厂提供对应的咖啡</p>
<p><strong>咖啡类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义抽象产品Coffee</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    String <span class="title function_">serve</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具体产品AmericanCoffee</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AmericanCoffee</span> <span class="keyword">implements</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;美式咖啡&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具体产品Espresso</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Espresso</span> <span class="keyword">implements</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;意式浓缩咖啡&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>咖啡工厂类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单咖啡工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleCoffeeFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Coffee <span class="title function_">createCoffee</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;American&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanCoffee</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Espresso&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Espresso</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;不支持的咖啡类型：&quot;</span> + type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用简单工厂创建咖啡</span></span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee1</span> <span class="operator">=</span> SimpleCoffeeFactory.createCoffee(<span class="string">&quot;American&quot;</span>);</span><br><span class="line">        System.out.println(coffee1.serve()); <span class="comment">// 输出：美式咖啡</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee2</span> <span class="operator">=</span> SimpleCoffeeFactory.createCoffee(<span class="string">&quot;Espresso&quot;</span>);</span><br><span class="line">        System.out.println(coffee2.serve()); <span class="comment">// 输出：意式浓缩咖啡</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="创建型-工厂方法-Factory-Method"><a href="#创建型-工厂方法-Factory-Method" class="headerlink" title="创建型-工厂方法(Factory Method)"></a>创建型-工厂方法(Factory Method)</h1><blockquote>
<p>工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态，工厂方法模式保持了简单工厂模式的优点，而且遵守了开闭原则</p>
<p><strong>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则</strong></p>
</blockquote>
<p>我们可以定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类</p>
<p>工厂方法模式的主要角色：</p>
<ul>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</li>
<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li>
</ul>
<h2 id="示例：美式咖啡店"><a href="#示例：美式咖啡店" class="headerlink" title="示例：美式咖啡店"></a>示例：美式咖啡店</h2><blockquote>
<p>如果需要某一类产品下的几个产品分支，可以选择工厂方法模式。每个具体工厂类负责创建自己特定的产品，从而实现了产品的扩展和变化</p>
</blockquote>
<p>现在，美式咖啡厂专供美式咖啡店，意式咖啡厂专供意式咖啡店</p>
<p><strong>咖啡类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义抽象产品Coffee</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    String <span class="title function_">serve</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具体产品AmericanCoffee</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AmericanCoffee</span> <span class="keyword">implements</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;美式咖啡&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具体产品Espresso</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Espresso</span> <span class="keyword">implements</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;意式浓缩咖啡&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>工厂类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义抽象咖啡工厂</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">    Coffee <span class="title function_">createCoffee</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体咖啡工厂实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AmericanCoffeeFactory</span> <span class="keyword">implements</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanCoffee</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ItalianCoffeeFactory</span> <span class="keyword">implements</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Espresso</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建具体咖啡工厂</span></span><br><span class="line">        <span class="type">CoffeeFactory</span> <span class="variable">coffeeFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AmericanCoffeeFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用工厂创建咖啡</span></span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> coffeeFactory.createCoffee();</span><br><span class="line">        System.out.println(coffee.serve()); <span class="comment">// 输出：美式咖啡</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切换到意式咖啡工厂</span></span><br><span class="line">        coffeeFactory = <span class="keyword">new</span> <span class="title class_">ItalianCoffeeFactory</span>();</span><br><span class="line">        coffee = coffeeFactory.createCoffee();</span><br><span class="line">        System.out.println(coffee.serve()); <span class="comment">// 输出：意式浓缩咖啡</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="创建型-抽象工厂-Abstract-Factory"><a href="#创建型-抽象工厂-Abstract-Factory" class="headerlink" title="创建型-抽象工厂(Abstract Factory)"></a>创建型-抽象工厂(Abstract Factory)</h1><blockquote>
<p>抽象工厂模式适用于需要创建多个相关产品族的情况。如果每个产品分支都需要对应的配套产品，可以选择抽象工厂模式。抽象工厂模式通过定义抽象工厂接口和多个工厂方法来创建不同产品族的产品，确保这些产品相互配合使用</p>
</blockquote>
<p>当多个工厂同时生产不同种类的东西，而不是专职生产同种类产品时，那抽象工厂比工厂方法更加适用。换句话说，当工厂要生产一个带有配套产品的产品而不是单品时，抽象工厂更为合适。</p>
<h2 id="示例：有甜点的美式咖啡店"><a href="#示例：有甜点的美式咖啡店" class="headerlink" title="示例：有甜点的美式咖啡店"></a>示例：有甜点的美式咖啡店</h2><p>和上个示例相比，现在我们的咖啡店不只是卖咖啡，还卖甜点。只不过美式咖啡厅卖美式甜点，意式咖啡店卖意式甜点。与此同时，我们的工厂现在是意式工厂和美式工厂。</p>
<p><strong>咖啡类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义抽象产品Coffee</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    String <span class="title function_">serve</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具体产品AmericanCoffee</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AmericanCoffee</span> <span class="keyword">implements</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;美式咖啡&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具体产品Espresso</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Espresso</span> <span class="keyword">implements</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;意式浓缩咖啡&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>甜品类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义抽象产品Dessert</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dessert</span> &#123;</span><br><span class="line">    String <span class="title function_">serve</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具体产品AmericanDessert</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AmericanDessert</span> <span class="keyword">implements</span> <span class="title class_">Dessert</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;美式甜点&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具体产品ItalianDessert</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ItalianDessert</span> <span class="keyword">implements</span> <span class="title class_">Dessert</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;意式甜点&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>工厂类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义抽象工厂CoffeeFactory</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">    Coffee <span class="title function_">createCoffee</span><span class="params">()</span>;</span><br><span class="line">    Dessert <span class="title function_">createDessert</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具体工厂AmericanCoffeeFactory</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AmericanCoffeeFactory</span> <span class="keyword">implements</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanCoffee</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Dessert <span class="title function_">createDessert</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanDessert</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具体工厂ItalianCoffeeFactory</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ItalianCoffeeFactory</span> <span class="keyword">implements</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Espresso</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Dessert <span class="title function_">createDessert</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ItalianDessert</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建意式咖啡店工厂</span></span><br><span class="line">        <span class="type">CoffeeFactory</span> <span class="variable">italianFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ItalianCoffeeFactory</span>();</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">espresso</span> <span class="operator">=</span> italianFactory.createCoffee();</span><br><span class="line">        <span class="type">Dessert</span> <span class="variable">italianDessert</span> <span class="operator">=</span> italianFactory.createDessert();</span><br><span class="line">        System.out.println(espresso.serve()); <span class="comment">// 输出：意式浓缩咖啡</span></span><br><span class="line">        System.out.println(italianDessert.serve()); <span class="comment">// 输出：意式甜点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建美式咖啡店工厂</span></span><br><span class="line">        <span class="type">CoffeeFactory</span> <span class="variable">americanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AmericanCoffeeFactory</span>();</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">americano</span> <span class="operator">=</span> americanFactory.createCoffee();</span><br><span class="line">        <span class="type">Dessert</span> <span class="variable">americanDessert</span> <span class="operator">=</span> americanFactory.createDessert();</span><br><span class="line">        System.out.println(americano.serve()); <span class="comment">// 输出：美式咖啡</span></span><br><span class="line">        System.out.println(americanDessert.serve()); <span class="comment">// 输出：美式甜点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="创建型-建造者模式-Builder"><a href="#创建型-建造者模式-Builder" class="headerlink" title="创建型-建造者模式(Builder)"></a>创建型-建造者模式(Builder)</h1><blockquote>
<p>将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。换言之，当某个对象的属性构建过程复杂，但属性注入的程序固定</p>
</blockquote>
<p>以一台计算机为例，使用建造者模式建造可以：</p>
<ul>
<li>分离计算机部件的构造(由Builder来负责)和装配(由Director负责)。 计算机各个零件生产复杂，但装配各个部件的程序是一样的。</li>
<li>由于实现了构建和装配的解耦。不同的计算机硬件构建器，相同的装配，也可以做出不同的计算机对象；相同的计算机硬件构建器，不同的装配顺序也可以做出不同的计算机对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。</li>
<li>建造者模式可以将计算机部件和其组装过程分开，一步一步创建一个复杂的计算机对象。用户只需要指定想要哪个装机套餐就可以得到该计算机对象，而无须知道其各零件的具体构造细节。</li>
</ul>
<h2 id="含有指挥者的示例："><a href="#含有指挥者的示例：" class="headerlink" title="含有指挥者的示例："></a>含有指挥者的示例：</h2><p>生产自行车是一个复杂的过程，它包含了车架，车座等组件的生产。而车架又有碳纤维，铝合金等材质的，车座有橡胶，真皮等材质。对于自行车的生产就可以使用建造者模式。指挥者类 <code>Director</code> 在建造者模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类</p>
<p><strong>自行车及其生成器：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 产品类 - 自行车</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bicycle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String frame;</span><br><span class="line">    <span class="keyword">private</span> String seat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象生成器 - 自行车生成器</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">BicycleBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildFrame</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildSeat</span><span class="params">()</span>;</span><br><span class="line">    Bicycle <span class="title function_">getBicycle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体生成器 - 碳纤维自行车生成器</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarbonFiberBicycleBuilder</span> <span class="keyword">implements</span> <span class="title class_">BicycleBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Bicycle bicycle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CarbonFiberBicycleBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bicycle = <span class="keyword">new</span> <span class="title class_">Bicycle</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildFrame</span><span class="params">()</span> &#123;</span><br><span class="line">        bicycle.setFrame(<span class="string">&quot;Carbon Fiber Frame&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildSeat</span><span class="params">()</span> &#123;</span><br><span class="line">        bicycle.setSeat(<span class="string">&quot;Rubber Seat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Bicycle <span class="title function_">getBicycle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bicycle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体生成器 - 铝合金自行车生成器</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AluminumBicycleBuilder</span> <span class="keyword">implements</span> <span class="title class_">BicycleBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Bicycle bicycle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AluminumBicycleBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bicycle = <span class="keyword">new</span> <span class="title class_">Bicycle</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildFrame</span><span class="params">()</span> &#123;</span><br><span class="line">        bicycle.setFrame(<span class="string">&quot;Aluminum Frame&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildSeat</span><span class="params">()</span> &#123;</span><br><span class="line">        bicycle.setSeat(<span class="string">&quot;Leather Seat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Bicycle <span class="title function_">getBicycle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bicycle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>指挥者：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BicycleDirector</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BicycleBuilder bicycleBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BicycleDirector</span><span class="params">(BicycleBuilder bicycleBuilder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bicycleBuilder = bicycleBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Bicycle <span class="title function_">construct</span><span class="params">()</span> &#123;</span><br><span class="line">        bicycleBuilder.buildFrame();</span><br><span class="line">        bicycleBuilder.buildSeat();</span><br><span class="line">        <span class="keyword">return</span> bicycleBuilder.getBicycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BicycleDirector</span> <span class="variable">bicycleDirector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BicycleDirector</span>(<span class="keyword">new</span> <span class="title class_">CarbonFiberBicycleBuilder</span>());</span><br><span class="line">        <span class="type">Bicycle</span> <span class="variable">carbonFiberBicycle</span> <span class="operator">=</span> bicycleDirector.construct();</span><br><span class="line">        System.out.println(<span class="string">&quot;Carbon Fiber Bicycle:&quot;</span>);</span><br><span class="line">        System.out.println(carbonFiberBicycle);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        bicycleDirector = <span class="keyword">new</span> <span class="title class_">BicycleDirector</span>(<span class="keyword">new</span> <span class="title class_">AluminumBicycleBuilder</span>());</span><br><span class="line">        <span class="type">Bicycle</span> <span class="variable">aluminumBicycle</span> <span class="operator">=</span> bicycleDirector.construct();</span><br><span class="line">        System.out.println(<span class="string">&quot;Aluminum Bicycle:&quot;</span>);</span><br><span class="line">        System.out.println(aluminumBicycle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不含指挥者的示例："><a href="#不含指挥者的示例：" class="headerlink" title="不含指挥者的示例："></a>不含指挥者的示例：</h2><p>当系统结构相对简单且复杂对象的构建过程比较固定时，比方说我们造的自行车都是碳纤维的，那么可以将指挥者类与抽象生成器进行结合，从而简化系统结构。</p>
<p><strong>自行车及其生成器：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 产品类 - 自行车</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bicycle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String frame;</span><br><span class="line">    <span class="keyword">private</span> String seat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象生成器 - 自行车生成器</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">BicycleBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildFrame</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildSeat</span><span class="params">()</span>;</span><br><span class="line">    Bicycle <span class="title function_">getBicycle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体生成器 - 碳纤维自行车生成器</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarbonFiberBicycleBuilder</span> <span class="keyword">implements</span> <span class="title class_">BicycleBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Bicycle bicycle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CarbonFiberBicycleBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bicycle = <span class="keyword">new</span> <span class="title class_">Bicycle</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildFrame</span><span class="params">()</span> &#123;</span><br><span class="line">        bicycle.setFrame(<span class="string">&quot;Carbon Fiber Frame&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildSeat</span><span class="params">()</span> &#123;</span><br><span class="line">        bicycle.setSeat(<span class="string">&quot;Rubber Seat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Bicycle <span class="title function_">getBicycle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bicycle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BicycleBuilder</span> <span class="variable">bicycleBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CarbonFiberBicycleBuilder</span>();</span><br><span class="line"></span><br><span class="line">        bicycleBuilder.buildFrame();</span><br><span class="line">        bicycleBuilder.buildSeat();</span><br><span class="line">        <span class="type">Bicycle</span> <span class="variable">bicycle</span> <span class="operator">=</span> bicycleBuilder.getBicycle();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Carbon Fiber Bicycle:&quot;</span>);</span><br><span class="line">        System.out.println(bicycle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="创建型-原型模式-Prototype"><a href="#创建型-原型模式-Prototype" class="headerlink" title="创建型-原型模式(Prototype)"></a>创建型-原型模式(Prototype)</h1><blockquote>
<p>原型模式适用于在需要大量创建相似对象时使用。它通过复制现有对象的方式来创建新对象，而无需重复进行初始化和构建过程</p>
</blockquote>
<p>如果我们拥有一批构建好的不同种类的模板，且需要大量输出相同或相似的产品，那么可以使用原型模式把对应模板进行批量复制输出</p>
<p>这种方式特别适合于创建成本较高、创建过程复杂或者需要频繁创建的对象。通过复制现有的对象，我们可以节省创建对象的开销，并且可以方便地对克隆出的对象进行个性化定制。</p>
<h2 id="示例：复制成品"><a href="#示例：复制成品" class="headerlink" title="示例：复制成品"></a>示例：复制成品</h2><p>假设我们有一个简单的图形类 <code>Shape</code>，它有一个 <code>draw()</code> 方法用于绘制图形。我们希望能够复制已有的图形对象，而无需知道具体的图形类型。</p>
<p>首先，我们需要创建一个抽象的原型接口 <code>CloneableShape</code>，它包含一个 <code>clone()</code> 方法用于复制图形对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CloneableShape</span> <span class="keyword">extends</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CloneableShape <span class="title function_">clone</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们实现具体的图形类，这里以矩形和圆形为例。它们都需要实现 <code>CloneableShape</code> 接口，并且在 <code>clone()</code> 方法中进行对象的复制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">CloneableShape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> width;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制矩形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CloneableShape <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="built_in">this</span>.width, <span class="built_in">this</span>.height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">CloneableShape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">int</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制圆形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CloneableShape <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="built_in">this</span>.radius);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们可以创建一个图形缓存类 <code>ShapeCache</code>，用于存储已有的图形对象。在该类中，我们使用一个 <code>HashMap</code> 来存储图形对象，其中键为图形类型，值为对应的原型对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, CloneableShape&gt; shapeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CloneableShape <span class="title function_">getShape</span><span class="params">(String shapeId)</span> &#123;</span><br><span class="line">        <span class="type">CloneableShape</span> <span class="variable">cachedShape</span> <span class="operator">=</span> shapeMap.get(shapeId);</span><br><span class="line">        <span class="keyword">return</span> (CloneableShape) cachedShape.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadCache</span><span class="params">()</span> &#123;</span><br><span class="line">        shapeMap.put(<span class="string">&quot;rectangle&quot;</span>, <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">        shapeMap.put(<span class="string">&quot;circle&quot;</span>, <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">30</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们可以使用原型模式来复制图形对象，而无需知道具体的图形类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ShapeCache.loadCache();</span><br><span class="line"></span><br><span class="line">        <span class="type">CloneableShape</span> <span class="variable">clonedShape1</span> <span class="operator">=</span> ShapeCache.getShape(<span class="string">&quot;rectangle&quot;</span>);</span><br><span class="line">        clonedShape1.draw(); <span class="comment">// 输出：绘制矩形</span></span><br><span class="line"></span><br><span class="line">        <span class="type">CloneableShape</span> <span class="variable">clonedShape2</span> <span class="operator">=</span> ShapeCache.getShape(<span class="string">&quot;circle&quot;</span>);</span><br><span class="line">        clonedShape2.draw(); <span class="comment">// 输出：绘制圆形</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="结构型-外观-Facade"><a href="#结构型-外观-Facade" class="headerlink" title="结构型-外观(Facade)"></a>结构型-外观(Facade)</h1><blockquote>
<p>提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用</p>
</blockquote>
<p>在外观模式中，子系统负责各自的功能实现，并且将其封装在具体的类中。<strong>外观类</strong>则作为一个集合器或者接口提供者，<strong>集中收集了子系统的操作</strong>，并且将其封装成简单易用的方法。</p>
<p>用户使用外观类时，只需要调用外观类提供的方法，而不需要关心底层子系统的复杂性和细节。外观类内部会根据用户的操作调用子系统的相应方法，完成一系列的操作。这样，外观类提供了一个简化的接口给用户，让用户可以更加方便地使用整个系统。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>不符合开闭原则，修改很麻烦</li>
</ul>
<h2 id="示例：一键看电视"><a href="#示例：一键看电视" class="headerlink" title="示例：一键看电视"></a>示例：一键看电视</h2><p>在下面代码示例中，可能会有人觉得外观模式和责任链模式目的是相似的，但是它们的目的和应用场景却是不同的。</p>
<blockquote>
<p>外观模式更倾向于分类接口来方便调用，而责任链模式更倾向于让一串任务开始执行的开关</p>
</blockquote>
<p>通过语音直接控制智能家电的开启和关闭：</p>
<ul>
<li><p>打开灯、打开电视、打开空调</p>
</li>
<li><p>关闭灯、关闭电视、关闭空调</p>
</li>
</ul>
<p><strong>子系统：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子系统：灯</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOn</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;灯已打开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOff</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;灯已关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统：电视</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TV</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOn</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电视已打开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOff</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电视已关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统：空调</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AirConditioner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOn</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;空调已打开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOff</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;空调已关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>外观类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外观类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmartHomeFacade</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Light light;                          <span class="comment">// 灯子系统</span></span><br><span class="line">    <span class="keyword">private</span> TV tv;                                <span class="comment">// 电视子系统</span></span><br><span class="line">    <span class="keyword">private</span> AirConditioner airConditioner;        <span class="comment">// 空调子系统</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmartHomeFacade</span><span class="params">()</span> &#123;</span><br><span class="line">        light = <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line">        tv = <span class="keyword">new</span> <span class="title class_">TV</span>();</span><br><span class="line">        airConditioner = <span class="keyword">new</span> <span class="title class_">AirConditioner</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打开所有智能家电</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOnAllDevices</span><span class="params">()</span> &#123;</span><br><span class="line">        light.turnOn();                           <span class="comment">// 打开灯</span></span><br><span class="line">        tv.turnOn();                              <span class="comment">// 打开电视</span></span><br><span class="line">        airConditioner.turnOn();                  <span class="comment">// 打开空调</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭所有智能家电</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOffAllDevices</span><span class="params">()</span> &#123;</span><br><span class="line">        light.turnOff();                          <span class="comment">// 关闭灯</span></span><br><span class="line">        tv.turnOff();                             <span class="comment">// 关闭电视</span></span><br><span class="line">        airConditioner.turnOff();                 <span class="comment">// 关闭空调</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoiceControlDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SmartHomeFacade</span> <span class="variable">smartHome</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmartHomeFacade</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过语音控制打开智能家电</span></span><br><span class="line">        smartHome.turnOnAllDevices();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过语音控制关闭智能家电</span></span><br><span class="line">        smartHome.turnOffAllDevices();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="结构型-适配器-Adapter"><a href="#结构型-适配器-Adapter" class="headerlink" title="结构型-适配器(Adapter)"></a>结构型-适配器(Adapter)</h1><blockquote>
<p>适配器模式(Adapter pattern)可以将一个类的接口, 转换成客户期望的另一个接口。 适配器让原本接口不兼容的类可以合作无间。 对象适配器使用组合, 类适配器使用多重继承。我们一般用对象适配器</p>
</blockquote>
<h2 id="示例：TF卡转SD卡"><a href="#示例：TF卡转SD卡" class="headerlink" title="示例：TF卡转SD卡"></a>示例：TF卡转SD卡</h2><p>现有一台电脑只能读取SD卡，而要读取TF卡中的内容的话就需要使用到适配器模式。创建一个读卡器，将TF卡中的内容读取出来</p>
<p><strong>SD卡接口和实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SD卡的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line">    <span class="comment">//读取SD卡方法</span></span><br><span class="line">    String <span class="title function_">readSD</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//写入SD卡功能</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SD卡实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDCardImpl</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;sd card read a msg :hello word SD&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sd card write msg : &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>电脑类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">(SDCard sdCard)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sdCard == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;sd card null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sdCard.readSD();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>TF卡接口和实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TF卡接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TFCard</span> &#123;</span><br><span class="line">    <span class="comment">//读取TF卡方法</span></span><br><span class="line">    String <span class="title function_">readTF</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//写入TF卡功能</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeTF</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TF卡实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TFCardImpl</span> <span class="keyword">implements</span> <span class="title class_">TFCard</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readTF</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;tf card read msg : hello word tf card&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeTF</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;tf card write a msg : &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>适配器类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建适配器对象（SD兼容TF）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDAdapterTF</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TFCard tfCard;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SDAdapterTF</span><span class="params">(TFCard tfCard)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tfCard = tfCard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter read tf card &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> tfCard.readTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter write tf card&quot;</span>);</span><br><span class="line">        tfCard.writeTF(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">SDCard</span> <span class="variable">sdCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDCardImpl</span>();</span><br><span class="line">        System.out.println(computer.readSD(sdCard));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">TFCard</span> <span class="variable">tfCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TFCardImpl</span>();</span><br><span class="line">        <span class="type">SDAdapterTF</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDAdapterTF</span>(tfCard);</span><br><span class="line">        System.out.println(computer.readSD(adapter));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="结构型-桥接-Bridge"><a href="#结构型-桥接-Bridge" class="headerlink" title="结构型-桥接(Bridge)"></a>结构型-桥接(Bridge)</h1><blockquote>
<p>桥接模式主要是为了解决两个维度的东西使用继承方式配对时造成的继承爆炸</p>
</blockquote>
<p>现在有一个需求，需要创建不同的图形，并且每个图形都有可能会有不同的颜色。我们可以利用继承的方式来设计类的关系。但使用继承的话，后续不断的添加子类就会造成继承爆炸（子类过多）</p>
<p>颜色和形状是两个维度的东西。试想，在一个有多种可能会变化的维度的系统中，用继承方式会造成类爆炸，扩展起来不灵活。每次在一个维度上新增一个具体实现都要增加多个子类。为了更加灵活的设计系统，我们此时可以考虑使用桥接模式。</p>
<p>现在你大概理解了我们为什么要使用桥接，用正规的术语来描述使用场景，就是：</p>
<ul>
<li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</li>
<li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</li>
<li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li>
</ul>
<h2 id="示例：不同系统播不同格式视频"><a href="#示例：不同系统播不同格式视频" class="headerlink" title="示例：不同系统播不同格式视频"></a>示例：不同系统播不同格式视频</h2><p>需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了两个维度，适合使用桥接模式</p>
<p>在操作系统抽象类中不提供默认实现的原因是，父类无法确定子类应该如何具体实现播放操作。不同的操作系统版本可能会有特定的实现细节和环境差异，因此需要交给子类去实现</p>
<p><strong>视频接口：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">VideoFile</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(String fileName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不同格式的视频实现类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// avi文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AVIFile</span> <span class="keyword">implements</span> <span class="title class_">VideoFile</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;avi视频文件：&quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rmvb文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">REVBBFile</span> <span class="keyword">implements</span> <span class="title class_">VideoFile</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;rmvb文件：&quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>抽象的操作系统：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OperatingSystemVersion</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> VideoFile videoFile;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OperatingSystemVersion</span><span class="params">(VideoFile videoFile)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.videoFile = videoFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不同的操作系统子类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Windows系统</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Windows</span> <span class="keyword">extends</span> <span class="title class_">OperatingSystemVersion</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Windows</span><span class="params">(VideoFile videoFile)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(videoFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        videoFile.decode(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mac系统</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mac</span> <span class="keyword">extends</span> <span class="title class_">OperatingSystemVersion</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mac</span><span class="params">(VideoFile videoFile)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(videoFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        videoFile.decode(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OperatingSystem</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Windows</span>(<span class="keyword">new</span> <span class="title class_">AVIFile</span>());</span><br><span class="line">        os.play(<span class="string">&quot;三体&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么是抽象类对接口？"><a href="#为什么是抽象类对接口？" class="headerlink" title="为什么是抽象类对接口？"></a>为什么是抽象类对接口？</h2><p><strong>我们来重温一下接口和抽象类的区别：</strong></p>
<p>抽象类和接口在设计上有不同的用途和特点，选择使用抽象类或接口取决于你的设计需求。</p>
<ol>
<li><p>抽象类：</p>
<ul>
<li><strong>抽象类可以包含成员变量、非抽象方法和抽象方法。</strong></li>
<li>抽象类可以提供默认实现，并且子类可以通过继承来复用这些实现。</li>
<li>抽象类适合用于拥有共享代码和行为的相关类之间的继承关系。</li>
</ul>
</li>
<li><p>接口：</p>
<ul>
<li>接口只能包含常量和抽象方法。接口中的方法没有默认实现，需要在实现时进行具体实现。</li>
<li>类可以实现多个接口，从而具备多个接口定义的行为。这种多继承的特性使得接口在实现类的灵活性上更加强大。</li>
<li>接口适合用于描述一组相似的行为，并且这些行为可以被不同的类实现。</li>
</ul>
</li>
</ol>
<p>因此，当你需要定义一组行为，并希望多个类实现这些行为时，使用接口是一个不错的选择。接口更加灵活并且支持类的多继承。</p>
<p>在代码片段中，<code>VideoFile</code>是一个接口，描述了视频文件的解码行为。<code>OperatingSystemVersion</code>是一个抽象类，提供了操作系统版本的通用行为，并将具体的视频文件解码行为委托给了实现了<code>VideoFile</code>接口的具体类。这样设计的好处是，可以通过定义不同的视频文件实现类来支持不同格式的视频文件解码，而不需要修改操作系统版本类。</p>
<p>总结来说，抽象类适用于共享代码和行为的继承关系，而接口适用于描述一组相似行为并让多个类实现。在特定的设计场景中，你可以选择使用抽象类、接口或二者的结合，以满足你的需求。</p>
<h1 id="结构型-组合-Composite"><a href="#结构型-组合-Composite" class="headerlink" title="结构型 - 组合(Composite)"></a>结构型 - 组合(Composite)</h1><blockquote>
<p>组合模式主要用来解决树形结构和嵌套结构的问题。它通过将对象组织成树状结构，使得我们可以统一处理单个对象和对象组合，从而简化对树形结构的操作和管理</p>
</blockquote>
<p>组合模式主要包含三种角色：</p>
<ul>
<li>抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。</li>
<li>树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。</li>
<li>叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。</li>
</ul>
<h2 id="示例：软件菜单"><a href="#示例：软件菜单" class="headerlink" title="示例：软件菜单"></a>示例：软件菜单</h2><p>如下图，我们在访问别的一些管理系统时，经常可以看到类似的菜单。一个菜单可以包含菜单项（菜单项是指不再包含其他内容的菜单条目），也可以包含带有其他菜单项的菜单，因此使用组合模式描述菜单就很恰当，我们的需求是针对一个菜单，打印出其包含的所有菜单以及菜单项的名称</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 主菜单</span><br><span class="line"><span class="bullet">    -</span> 子菜单 1</span><br><span class="line"><span class="bullet">        -</span> 菜单项 1.1</span><br><span class="line"><span class="bullet">        -</span> 菜单项 1.2</span><br><span class="line"><span class="bullet">    -</span> 子菜单 2</span><br><span class="line"><span class="bullet">        -</span> 菜单项 2.1</span><br><span class="line"><span class="bullet">        -</span> 菜单项 2.2</span><br><span class="line"><span class="bullet">        -</span> 菜单项 2.3</span><br><span class="line"><span class="bullet">    -</span> 子菜单 3</span><br></pre></td></tr></table></figure>

<p>不管是菜单还是菜单项，都应该继承自统一的接口，这里姑且将这个统一的接口称为菜单组件。</p>
<p>这里的MenuComponent定义为抽象类，因为有一些共有的属性和行为要在该类中实现。Menu和MenuItem类就可以只覆盖自己感兴趣的方法，而不用搭理不需要或者不感兴趣的方法。</p>
<p>举例来说，Menu类可以包含子菜单，因此需要覆盖add()、remove()、getChild()方法，但是MenuItem就不应该有这些方法。这里给出的默认实现是抛出异常，也可以根据自己的需要改写默认实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//菜单组件  不管是菜单还是菜单项，都应该继承该类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MenuComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加菜单</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(MenuComponent menuComponent)</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除菜单</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(MenuComponent menuComponent)</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取指定的子菜单</span></span><br><span class="line">    <span class="keyword">public</span> MenuComponent <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取菜单名称</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Menu类已经实现了除了getName方法的其他所有方法，因为Menu类具有添加菜单，移除菜单和获取子菜单的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Menu</span> <span class="keyword">extends</span> <span class="title class_">MenuComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuComponent&gt; menuComponentList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Menu</span><span class="params">(String name,<span class="type">int</span> level)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        menuComponentList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;MenuComponent&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(MenuComponent menuComponent)</span> &#123;</span><br><span class="line">        menuComponentList.add(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(MenuComponent menuComponent)</span> &#123;</span><br><span class="line">        menuComponentList.remove(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MenuComponent <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> menuComponentList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="keyword">for</span> (MenuComponent menuComponent : menuComponentList) &#123;</span><br><span class="line">            menuComponent.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MenuItem是菜单项，不能再有子菜单，所以添加菜单，移除菜单和获取子菜单的功能并不能实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MenuItem</span> <span class="keyword">extends</span> <span class="title class_">MenuComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MenuItem</span><span class="params">(String name,<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="结构型-装饰-Decorator"><a href="#结构型-装饰-Decorator" class="headerlink" title="结构型 - 装饰(Decorator)"></a>结构型 - 装饰(Decorator)</h1><blockquote>
<p>指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。简单来说，装饰者模式是为插件设计而生</p>
</blockquote>
<h2 id="示例：添加配菜"><a href="#示例：添加配菜" class="headerlink" title="示例：添加配菜"></a>示例：添加配菜</h2><p>快餐店有炒面、炒饭这些快餐，可以额外附加鸡蛋、火腿、培根这些配菜，当然加配菜需要额外加钱，每个配菜的价钱通常不太一样，那么计算总价就会显得比较麻烦。使用继承方式实现的话扩展性差，且会造成继承爆炸。现在我们用装饰者模式实现</p>
<p><strong>快餐接口：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> price;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取价格</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>快餐实现类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//炒饭</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedRice</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FriedRice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">10</span>, <span class="string">&quot;炒饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//炒面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedNoodles</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FriedNoodles</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">12</span>, <span class="string">&quot;炒面&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配菜抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Garnish</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FastFood fastFood;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Garnish</span><span class="params">(FastFood fastFood, <span class="type">float</span> price, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(price, desc);</span><br><span class="line">        <span class="built_in">this</span>.fastFood = fastFood;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配菜实现类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//鸡蛋配料</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Egg</span> <span class="keyword">extends</span> <span class="title class_">Garnish</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Egg</span><span class="params">(FastFood fastFood)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(fastFood, <span class="number">1</span>, <span class="string">&quot;鸡蛋&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice() + getFastFood().getPrice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDesc() + getFastFood().getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//培根配料</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bacon</span> <span class="keyword">extends</span> <span class="title class_">Garnish</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bacon</span><span class="params">(FastFood fastFood)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(fastFood, <span class="number">2</span>, <span class="string">&quot;培根&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice() + getFastFood().getPrice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDesc() + getFastFood().getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//点一份炒饭</span></span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRice</span>();</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food.getDesc() + <span class="string">&quot; &quot;</span> + food.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//点一份加鸡蛋的炒饭</span></span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRice</span>();</span><br><span class="line">        food1 = <span class="keyword">new</span> <span class="title class_">Egg</span>(food1);</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food1.getDesc() + <span class="string">&quot; &quot;</span> + food1.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//点一份加培根的炒面</span></span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedNoodles</span>();</span><br><span class="line">        food2 = <span class="keyword">new</span> <span class="title class_">Bacon</span>(food2);</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food2.getDesc() + <span class="string">&quot; &quot;</span> + food2.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="结构型-享元-Flyweight"><a href="#结构型-享元-Flyweight" class="headerlink" title="结构型 - 享元(Flyweight)"></a>结构型 - 享元(Flyweight)</h1><blockquote>
<p>我们可以将单例对象放到一个对象池中给大家共享，这样可以极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能</p>
</blockquote>
<p>享元模式中的外部状态相对独立，且不影响内部状态</p>
<p>但同时，也有缺点：为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂</p>
<h2 id="示例：俄罗斯方块"><a href="#示例：俄罗斯方块" class="headerlink" title="示例：俄罗斯方块"></a>示例：俄罗斯方块</h2><p>下面的图片是众所周知的俄罗斯方块中的一个个方块，如果在俄罗斯方块这个游戏中，每个不同的方块都是一个实例对象，这些对象就要占用很多的内存空间，下面利用享元模式进行实现。</p>
<p><img src="http://notes.xiyankt.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97.jpeg" alt="俄罗斯方块"></p>
<p>俄罗斯方块有不同的形状，我们可以对这些形状向上抽取出AbstractBox，用来定义共性的属性和行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getShape</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方块形状：&quot;</span> + <span class="built_in">this</span>.getShape() + <span class="string">&quot; 颜色：&quot;</span> + color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是定义不同的形状了，IBox类、LBox类、OBox类等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;L&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;O&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提供了一个工厂类（BoxFactory），用来管理享元对象（也就是AbstractBox子类对象），该工厂类对象只需要一个，所以可以使用单例模式。并给工厂类提供一个获取形状的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoxFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, AbstractBox&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BoxFactory <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">BoxFactory</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BoxFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BoxFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, AbstractBox&gt;();</span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">iBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IBox</span>();</span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">lBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LBox</span>();</span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">oBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OBox</span>();</span><br><span class="line">        map.put(<span class="string">&quot;I&quot;</span>, iBox);</span><br><span class="line">        map.put(<span class="string">&quot;L&quot;</span>, lBox);</span><br><span class="line">        map.put(<span class="string">&quot;O&quot;</span>, oBox);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AbstractBox <span class="title function_">getBox</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDK源码示例：Integer"><a href="#JDK源码示例：Integer" class="headerlink" title="JDK源码示例：Integer"></a>JDK源码示例：Integer</h2><blockquote>
<p> <code>Integer</code> 默认先创建并缓存 <code>-128 ~ 127</code> 之间数的 <code>Integer</code> 对象，当调用 <code>valueOf</code> 时如果参数在 <code>-128 ~ 127</code> 之间则计算下标并从缓存中返回，否则创建一个新的 <code>Integer</code> 对象</p>
</blockquote>
<p>对于下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;i1和i2对象是否是同一个对象？&quot;</span> + (i1 == i2)); <span class="comment">// 输出true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;i3和i4对象是否是同一个对象？&quot;</span> + (i3 == i4)); <span class="comment">// 输出false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> Integer.valueOf((<span class="type">int</span>)<span class="number">127</span>);</span><br><span class="line">        Integer i2 Integer.valueOf((<span class="type">int</span>)<span class="number">127</span>);</span><br><span class="line">        System.out.println((String)<span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append((String)<span class="string">&quot;i1\u548ci2\u5bf9\u8c61\u662f\u5426\u662f\u540c\u4e00\u4e2a\u5bf9\u8c61\uff1f&quot;</span>).append((<span class="type">boolean</span>)(i1 == i2)).toString());</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> Integer.valueOf((<span class="type">int</span>)<span class="number">128</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> Integer.valueOf((<span class="type">int</span>)<span class="number">128</span>);</span><br><span class="line">        System.out.println((String)<span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append((String)<span class="string">&quot;i3\u548ci4\u5bf9\u8c61\u662f\u5426\u662f\u540c\u4e00\u4e2a\u5bf9\u8c61\uff1f&quot;</span>).append((<span class="type">boolean</span>)(i3 == i4)).toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码可以看到，直接给Integer类型的变量赋值基本数据类型数据的操作底层使用的就是 <code>valueOf()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Integer</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span></span><br><span class="line">                sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line">            cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">IntegerCache</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="结构型-代理-Proxy"><a href="#结构型-代理-Proxy" class="headerlink" title="结构型 - 代理(Proxy)"></a>结构型 - 代理(Proxy)</h1><blockquote>
<p>代理模式的目的是为另一个对象提供一个替身或占位符以控制对这个对象的访问。</p>
</blockquote>
<ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li>
<li>代理对象可以扩展目标对象的功能；</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li>
</ul>
<p>Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。</p>
<h2 id="三种代理的对比："><a href="#三种代理的对比：" class="headerlink" title="三种代理的对比："></a>三种代理的对比：</h2><ul>
<li><p>动态代理和静态代理</p>
<p>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。</p>
<p>如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题。</p>
</li>
<li><p>使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。</p>
<p>在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理。</p>
</li>
</ul>
<h2 id="JDK动态代理示例"><a href="#JDK动态代理示例" class="headerlink" title="JDK动态代理示例"></a>JDK动态代理示例</h2><p>如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象</p>
<p>Java中提供了一个动态代理类<code>Proxy</code>，<code>Proxy</code>并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（<code>newProxyInstance</code>方法）来获取代理对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卖票接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理工厂，用来创建代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SellTickets <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用Proxy获取代理对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            newProxyInstance()方法参数说明：</span></span><br><span class="line"><span class="comment">                ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可</span></span><br><span class="line"><span class="comment">                Class&lt;?&gt;[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口</span></span><br><span class="line"><span class="comment">                InvocationHandler h ： 代理对象的调用处理程序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">sellTickets</span> <span class="operator">=</span> (SellTickets) Proxy.newProxyInstance(</span><br><span class="line">            station.getClass().getClassLoader(),</span><br><span class="line">            station.getClass().getInterfaces(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    InvocationHandler中invoke方法参数说明：</span></span><br><span class="line"><span class="comment">                        proxy ： 代理对象</span></span><br><span class="line"><span class="comment">                        method ： 对应于在代理对象上调用的接口方法的 Method 实例</span></span><br><span class="line"><span class="comment">                        args ： 代理对象调用接口方法时传递的实际参数</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;</span>);</span><br><span class="line">                    <span class="comment">// 执行真实对象</span></span><br><span class="line">                    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(station, args);</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">return</span> sellTickets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取代理对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，<code>ProxyFactory</code>不是代理模式中所说的代理类，而代理类是程序在运行过程中动态的在内存中生成的类。通过阿里巴巴开源的 Java 诊断工具——<code>Arthas</code>查看代理类的结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.proxy.dynamic.jdk.SellTickets;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler invocationHandler) &#123;</span><br><span class="line">        <span class="built_in">super</span>(invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;com.itheima.proxy.dynamic.jdk.SellTickets&quot;</span>).getMethod(<span class="string">&quot;sell&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchMethodException noSuchMethodException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(noSuchMethodException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException classNotFoundException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(classNotFoundException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m1, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;object&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m2, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m0, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的类中，我们可以看到以下几个信息：</p>
<ul>
<li>代理类<code>$Proxy0</code>实现了<code>SellTickets</code>。这也就印证了我们之前说的真实类和代理类实现同样的接口。</li>
<li>代理类<code>$Proxy0</code>将我们提供了的匿名内部类对象传递给了父类。</li>
</ul>
<p>动态代理的执行流程是什么样的？</p>
<p>下面是摘取的重点代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//程序运行过程中动态生成的代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler invocationHandler) &#123;</span><br><span class="line">        <span class="built_in">super</span>(invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        m3 = Class.forName(<span class="string">&quot;com.itheima.proxy.dynamic.jdk.SellTickets&quot;</span>).getMethod(<span class="string">&quot;sell&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java提供的动态代理相关类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Proxy</span><span class="params">(InvocationHandler h)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SellTickets <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">sellTickets</span> <span class="operator">=</span> (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),</span><br><span class="line">                station.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;</span>);</span><br><span class="line">                        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(station, args);</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> sellTickets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试访问类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行流程如下：</p>
<ol>
<li>在测试类中通过代理对象调用<code>sell()</code>方法</li>
<li>根据多态的特性，执行的是代理类<code>$Proxy0</code>中的<code>sell()</code>方法</li>
<li>代理类<code>$Proxy0</code>中的<code>sell()</code>方法中又调用了<code>InvocationHandler</code>接口的子实现类对象的<code>invoke</code>方法</li>
<li><code>invoke</code>方法通过反射执行了真实对象所属类<code>TrainStation</code>中的<code>sell()</code>方法</li>
</ol>
<h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><p>同样是上面的案例，我们再次使用CGLIB代理实现。</p>
<p>如果没有定义SellTickets接口，只定义了TrainStation(火车站类)。很显然JDK代理是无法使用了，因为JDK动态代理要求必须定义接口，对接口进行代理。</p>
<p>CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。</p>
<p>CGLIB是第三方提供的包，所以需要引入jar包的坐标：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>火车站：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代理工厂：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TrainStation <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//设置父类的字节码对象</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">obj</span> <span class="operator">=</span> (TrainStation) enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        intercept方法参数说明：</span></span><br><span class="line"><span class="comment">            o ： 代理对象</span></span><br><span class="line"><span class="comment">            method ： 真实对象中的方法的Method实例</span></span><br><span class="line"><span class="comment">            args ： 实际参数</span></span><br><span class="line"><span class="comment">            methodProxy ：代理对象中的方法的method实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> TrainStation <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取一些服务费用(CGLIB动态代理方式)&quot;</span>);</span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">result</span> <span class="operator">=</span> (TrainStation) methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建代理工厂对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line"></span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="行为型-责任链-Chain-Of-Responsibility"><a href="#行为型-责任链-Chain-Of-Responsibility" class="headerlink" title="行为型 - 责任链(Chain Of Responsibility)"></a>行为型 - 责任链(Chain Of Responsibility)</h1><blockquote>
<p>通过责任链模式, 你可以为某个请求创建一个对象链. 每个对象依序检查此请求并对其进行处理或者将它传给链中的下一个对象。</p>
</blockquote>
<p>可以把责任链看做一条流水线，产品经过某个工序处理，或被中途丢弃，或被传到下一个工序处理。我们可以很方便的插入或去掉任意一道工序，而不影响其他工序的运行，就像链表一样。每道工序只需要接收一个固定的对象，也就是上下文</p>
<p><strong>缺点：</strong></p>
<ul>
<li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li>
<li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li>
<li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</li>
</ul>
<h2 id="示例：请假流程"><a href="#示例：请假流程" class="headerlink" title="示例：请假流程"></a>示例：请假流程</h2><p>现需要开发一个请假流程控制系统。请假一天以下的假只需要小组长同意即可；请假1天到3天的假还需要部门经理同意；请求3天到7天还需要总经理同意才行</p>
<p><strong>上下文-请假条：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeaveRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String employeeName; <span class="comment">// 员工姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> days;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">approved</span> <span class="operator">=</span> <span class="literal">false</span>;  <span class="comment">// 默认未批准</span></span><br><span class="line">    <span class="keyword">private</span> String reason;  <span class="comment">// 请假事由</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>审批者接口：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line">    <span class="comment">// 下一位审批者</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setNextApprover</span><span class="params">(Approver nextApprover)</span>;</span><br><span class="line">    <span class="comment">// 上下文</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">approveLeave</span><span class="params">(LeaveRequest request)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>审批者实现类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 小组长</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeamLeader</span> <span class="keyword">implements</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Approver nextApprover;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">approveLeave</span><span class="params">(LeaveRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getDays() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            request.setApproved(<span class="literal">true</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;小组长同意&quot;</span> + request.getEmployeeName() + <span class="string">&quot;的请假申请&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextApprover != <span class="literal">null</span>) &#123;</span><br><span class="line">            nextApprover.approveLeave(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部门经理</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartmentManager</span> <span class="keyword">implements</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Approver nextApprover;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">approveLeave</span><span class="params">(LeaveRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getDays() &gt;= <span class="number">1</span> &amp;&amp; request.getDays() &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">            request.setApproved(<span class="literal">true</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;部门经理同意&quot;</span> + request.getEmployeeName() + <span class="string">&quot;的请假申请&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextApprover != <span class="literal">null</span>) &#123;</span><br><span class="line">            nextApprover.approveLeave(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总经理</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneralManager</span> <span class="keyword">implements</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">approveLeave</span><span class="params">(LeaveRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getDays() &gt; <span class="number">3</span> &amp;&amp; request.getDays() &lt;= <span class="number">7</span>) &#123;</span><br><span class="line">            request.setApproved(<span class="literal">true</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;总经理同意&quot;</span> + request.getEmployeeName() + <span class="string">&quot;的请假申请&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            request.setApproved(<span class="literal">false</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;请假超过7天，需要进一步审批&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>请假流程控制类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeaveApprovalChain</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Approver chain;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeaveApprovalChain</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建审批者实例</span></span><br><span class="line">        <span class="type">Approver</span> <span class="variable">teamLeader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeamLeader</span>();</span><br><span class="line">        <span class="type">Approver</span> <span class="variable">departmentManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DepartmentManager</span>();</span><br><span class="line">        <span class="type">Approver</span> <span class="variable">generalManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneralManager</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将责任链的头部设置为小组长</span></span><br><span class="line">        chain = teamLeader;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置责任链的顺序</span></span><br><span class="line">        teamLeader.setNextApprover(departmentManager);</span><br><span class="line">        departmentManager.setNextApprover(generalManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processLeaveRequest</span><span class="params">(LeaveRequest request)</span> &#123;</span><br><span class="line">        chain.approveLeave(request);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!request.isApproved()) &#123;</span><br><span class="line">            System.out.println(request.getEmployeeName() + <span class="string">&quot;的请假申请被拒绝&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端调用：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LeaveRequest</span> <span class="variable">request1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeaveRequest</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">0</span>, <span class="string">&quot;家庭原因&quot;</span>);  <span class="comment">// 张三请假0天</span></span><br><span class="line">        <span class="type">LeaveRequest</span> <span class="variable">request2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeaveRequest</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">2</span>, <span class="string">&quot;病假&quot;</span>);  <span class="comment">// 李四请假2天</span></span><br><span class="line">        <span class="type">LeaveRequest</span> <span class="variable">request3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeaveRequest</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">4</span>, <span class="string">&quot;探亲假&quot;</span>);  <span class="comment">// 王五请假4天</span></span><br><span class="line">        <span class="type">LeaveRequest</span> <span class="variable">request4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeaveRequest</span>(<span class="string">&quot;赵六&quot;</span>, <span class="number">8</span>, <span class="string">&quot;年休假&quot;</span>);  <span class="comment">// 赵六请假8天</span></span><br><span class="line"></span><br><span class="line">        <span class="type">LeaveApprovalChain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeaveApprovalChain</span>();</span><br><span class="line">        chain.processLeaveRequest(request1);</span><br><span class="line">        chain.processLeaveRequest(request2);</span><br><span class="line">        chain.processLeaveRequest(request3);</span><br><span class="line">        chain.processLeaveRequest(request4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行客户端输出：</strong></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">小组长同意张三的请假申请</span><br><span class="line">部门经理同意李四的请假申请</span><br><span class="line">总经理同意王五的请假申请</span><br><span class="line">请假超过7天，需要进一步审批</span><br><span class="line">赵六的请假申请被拒绝</span><br></pre></td></tr></table></figure>

<h1 id="行为型-策略-Strategy"><a href="#行为型-策略-Strategy" class="headerlink" title="行为型 - 策略(Strategy)"></a>行为型 - 策略(Strategy)</h1><blockquote>
<p> 该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。</p>
</blockquote>
<p>我们去旅游选择出行模式有很多种，可以骑自行车、可以坐汽车、可以坐火车、可以坐飞机……</p>
<p>作为一个程序猿，开发需要选择一款开发工具，当然可以进行代码开发的工具有很多，可以选择Idea进行开发，也可以使用eclipse进行开发，也可以使用其他的一些开发工具。</p>
<p>上述例子的共同点是：我们可以自由选择策略来执行某个任务。</p>
<p>策略模式的主要角色如下：</p>
<ul>
<li>抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li>
<li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。</li>
<li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li>
<li>策略模式将造成产生很多策略类，可以通过<strong>使用享元模式</strong>在一定程度上减少对象的数量。</li>
</ul>
<h2 id="示例：促销活动："><a href="#示例：促销活动：" class="headerlink" title="示例：促销活动："></a>示例：促销活动：</h2><p>一家百货公司在定年度的促销活动。针对不同的节日（春节、中秋节、圣诞节）推出不同的促销活动，由促销员将促销活动展示给客户。</p>
<p><strong>促销活动接口：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体策略角色-每个节日具体的促销活动</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为春节准备的促销活动A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;                                                                                                                                                    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买一送一&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为中秋准备的促销活动B</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满200元减50元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为圣诞准备的促销活动C</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyC</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满1000元加一元换购任意200元以下商品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>环境角色-推送者：</strong></p>
<blockquote>
<p>用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SalesMan</span> &#123;                        </span><br><span class="line">    <span class="comment">//持有抽象策略角色的引用                              </span></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;                 </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SalesMan</span><span class="params">(Strategy strategy)</span> &#123;       </span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;              </span><br><span class="line">    &#125;                                          </span><br><span class="line"></span><br><span class="line">    <span class="comment">//向客户展示促销活动                                </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">salesManShow</span><span class="params">()</span>&#123;                </span><br><span class="line">        strategy.show();                       </span><br><span class="line">    &#125;                                          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端调用：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建具体的促销活动对象</span></span><br><span class="line">        <span class="type">Strategy</span> <span class="variable">strategyA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrategyA</span>();  <span class="comment">// 春节促销活动</span></span><br><span class="line">        <span class="type">Strategy</span> <span class="variable">strategyB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrategyB</span>();  <span class="comment">// 中秋节促销活动</span></span><br><span class="line">        <span class="type">Strategy</span> <span class="variable">strategyC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrategyC</span>();  <span class="comment">// 圣诞节促销活动</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建销售员对象并设置不同的促销活动</span></span><br><span class="line">        <span class="type">SalesMan</span> <span class="variable">salesMan1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SalesMan</span>(strategyA);  <span class="comment">// 绑定春节促销活动</span></span><br><span class="line">        <span class="type">SalesMan</span> <span class="variable">salesMan2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SalesMan</span>(strategyB);  <span class="comment">// 绑定中秋节促销活动</span></span><br><span class="line">        <span class="type">SalesMan</span> <span class="variable">salesMan3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SalesMan</span>(strategyC);  <span class="comment">// 绑定圣诞节促销活动</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销售员向客户展示促销活动</span></span><br><span class="line">        salesMan1.salesManShow();</span><br><span class="line">        salesMan2.salesManShow();</span><br><span class="line">        salesMan3.salesManShow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端输出：</strong></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">买一送一</span><br><span class="line">满200元减50元</span><br><span class="line">满1000元加一元换购任意200元以下商品</span><br></pre></td></tr></table></figure>

<h1 id="行为型-模板方法-Template-Method"><a href="#行为型-模板方法-Template-Method" class="headerlink" title="行为型 - 模板方法(Template Method)"></a>行为型 - 模板方法(Template Method)</h1><blockquote>
<p>在一个方法中定义一个算法的骨架, 而将一些步骤延迟到子类中. 模板方法使得子类可以在不改变算法结构的情况下, 重新定义算法中的某些步骤。</p>
</blockquote>
<p>在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。</p>
<p>例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。</p>
<p><strong>优点：</strong></p>
<ul>
<li><p>提高代码复用性</p>
<p>将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。</p>
</li>
<li><p>实现了反向控制</p>
<p>通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li>
<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li>
</ul>
<h2 id="示例：炒菜"><a href="#示例：炒菜" class="headerlink" title="示例：炒菜"></a>示例：炒菜</h2><blockquote>
<p><strong>注意：为防止恶意操作，一般模板方法都加上 final 关键词。</strong></p>
</blockquote>
<p>炒菜的步骤是固定的，分为倒油、热油、倒蔬菜、倒调料品、翻炒等步骤。现通过模板方法模式来用代码模拟。</p>
<p><strong>抽象类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractCook</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">cookProcess</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//第一步：倒油</span></span><br><span class="line">        <span class="built_in">this</span>.pourOil();</span><br><span class="line">        <span class="comment">//第二步：热油</span></span><br><span class="line">        <span class="built_in">this</span>.heatOil();</span><br><span class="line">        <span class="comment">//第三步：倒蔬菜</span></span><br><span class="line">        <span class="built_in">this</span>.pourVegetable();</span><br><span class="line">        <span class="comment">//第四步：倒调味料</span></span><br><span class="line">        <span class="built_in">this</span>.pourSauce();</span><br><span class="line">        <span class="comment">//第五步：翻炒</span></span><br><span class="line">        <span class="built_in">this</span>.fry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourOil</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;倒油&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步：热油是一样的，所以直接实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heatOil</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;热油&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步：倒蔬菜是不一样的（一个下包菜，一个是下菜心）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四步：倒调味料是不一样</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第五步：翻炒是一样的，所以直接实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fry</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;炒啊炒啊炒到熟啊&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>抽象类子类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaoCaiCook</span> <span class="keyword">extends</span> <span class="title class_">AbstractCook</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的蔬菜是包菜&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的酱料是辣椒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CaiXinCook</span> <span class="keyword">extends</span> <span class="title class_">AbstractCook</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的蔬菜是菜心&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的酱料是蒜蓉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CookClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//炒手撕包菜</span></span><br><span class="line">        <span class="type">BaoCaiCook</span> <span class="variable">baoCai</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BaoCaiCook</span>();</span><br><span class="line">        baoCai.cookProcess();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//炒蒜蓉菜心</span></span><br><span class="line">        <span class="type">CaiXinCook</span> <span class="variable">caiXin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CaiXinCook</span>();</span><br><span class="line">        caiXin.cookProcess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用示例输出：</strong></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">倒油</span><br><span class="line">热油</span><br><span class="line">下锅的蔬菜是包菜</span><br><span class="line">下锅的酱料是辣椒</span><br><span class="line">炒啊炒啊炒到熟啊</span><br><span class="line"></span><br><span class="line">倒油</span><br><span class="line">热油</span><br><span class="line">下锅的蔬菜是菜心</span><br><span class="line">下锅的酱料是蒜蓉</span><br><span class="line">炒啊炒啊炒到熟啊</span><br></pre></td></tr></table></figure>

<h1 id="行为型-命令模式-Command"><a href="#行为型-命令模式-Command" class="headerlink" title="行为型 - 命令模式(Command)"></a>行为型 - 命令模式(Command)</h1><blockquote>
<p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。</p>
</blockquote>
<p>命令模式包含以下主要角色：</p>
<ul>
<li>抽象命令类（Command）角色： 定义命令的接口，声明执行的方法。</li>
<li>具体命令（Concrete Command）角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。</li>
<li>实现者&#x2F;接收者（Receiver）角色： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。</li>
<li>调用者&#x2F;请求者（Invoker）角色： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。</li>
</ul>
<h2 id="示例：饭店吃饭"><a href="#示例：饭店吃饭" class="headerlink" title="示例：饭店吃饭"></a>示例：饭店吃饭</h2><ol>
<li><p>点单</p>
</li>
<li><p>订单交给厨师</p>
</li>
<li><p>厨师备菜</p>
</li>
</ol>
<p>将上面的案例用代码实现，那我们就需要分析命令模式的角色在该案例中由谁来充当。</p>
<ul>
<li><p>服务员： 就是调用者角色，由她来发起命令。</p>
</li>
<li><p>资深大厨： 就是接收者角色，真正命令执行的对象。</p>
</li>
<li><p>订单： 命令中包含订单。</p>
</li>
</ul>
<p><strong>pojo类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 订单类</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String dishName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务员类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Waiter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">placeOrder</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务员接收到订单&quot;</span>);</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资深大厨类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeniorChef</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cookDish</span><span class="params">(String dishName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;资深大厨开始烹饪：&quot;</span> + dishName);</span><br><span class="line">        <span class="comment">// 在这里执行具体的烹饪逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;资深大厨完成烹饪：&quot;</span> + dishName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>命令接口<code>Command</code>和具体命令类<code>CookingCommand</code>：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体命令类</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CookingCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SeniorChef chef;</span><br><span class="line">    <span class="keyword">private</span> Order order;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        chef.cookDish(order.getDishName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试输出：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommandPatternExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Waiter</span> <span class="variable">waiter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Waiter</span>();</span><br><span class="line">        <span class="type">SeniorChef</span> <span class="variable">chef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeniorChef</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建订单</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(<span class="string">&quot;红烧肉&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建命令对象，并将订单和大厨传递进去</span></span><br><span class="line">        <span class="type">Command</span> <span class="variable">cookingCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CookingCommand</span>(chef, order);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务员接收到订单，并发起命令</span></span><br><span class="line">        waiter.placeOrder(cookingCommand);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果：</strong></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">服务员接收到订单</span><br><span class="line">资深大厨开始烹饪：红烧肉</span><br><span class="line">资深大厨完成烹饪：红烧肉</span><br></pre></td></tr></table></figure>

<h1 id="行为型-观察者-Observer"><a href="#行为型-观察者-Observer" class="headerlink" title="行为型 - 观察者(Observer)"></a>行为型 - 观察者(Observer)</h1><blockquote>
<p>又被称为发布-订阅（Publish&#x2F;Subscribe）模式。在对象之间定义一对多的依赖, 这样一来, 当一个对象改变状态, 依赖它的对象都会收到通知, 并自动更新。没错，就像公众号订阅。</p>
</blockquote>
<h2 id="示例：微信公众号"><a href="#示例：微信公众号" class="headerlink" title="示例：微信公众号"></a>示例：微信公众号</h2><p>使用微信公众号时，当公众号有新内容更新，订阅者就会收到通知。我们使用观察者模式来模拟这样的场景，微信用户就是观察者，微信公众号是被观察者，一个公众号被多个微信用户订阅。</p>
<p><strong>发布者接口</strong><code>Observable</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line">    <span class="comment">// 添加订阅者</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除订阅者</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知所有订阅者</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>发布者实现类</strong><code>WechatAccount</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 微信公众号</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WechatAccount</span> <span class="keyword">implements</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String accountName;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers;</span><br><span class="line">    <span class="keyword">private</span> String latestContent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WechatAccount</span><span class="params">(String accountName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accountName = accountName;</span><br><span class="line">        <span class="built_in">this</span>.observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布新内容方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishNewContent</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.latestContent = content;</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>订阅者接口</strong><code>Observer</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">// 更新方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable observable)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>订阅者实现类</strong><code>WechatUser</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 微信用户</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WechatUser</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WechatUser</span><span class="params">(String userName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable observable)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (observable <span class="keyword">instanceof</span> WechatAccount) &#123;</span><br><span class="line">            <span class="type">WechatAccount</span> <span class="variable">wechatAccount</span> <span class="operator">=</span> (WechatAccount) observable;</span><br><span class="line">            <span class="type">String</span> <span class="variable">latestContent</span> <span class="operator">=</span> wechatAccount.getLatestContent();</span><br><span class="line">            System.out.println(<span class="string">&quot;用户 &quot;</span> + userName + <span class="string">&quot; 收到了公众号 &quot;</span> + wechatAccount.getAccountName() + <span class="string">&quot; 的新内容：&quot;</span> + latestContent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObserverPatternExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建微信公众号</span></span><br><span class="line">        <span class="type">WechatAccount</span> <span class="variable">accountA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WechatAccount</span>(<span class="string">&quot;公众号A&quot;</span>);</span><br><span class="line">        <span class="type">WechatAccount</span> <span class="variable">accountB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WechatAccount</span>(<span class="string">&quot;公众号B&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建微信用户</span></span><br><span class="line">        <span class="type">WechatUser</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WechatUser</span>(<span class="string">&quot;用户A&quot;</span>);</span><br><span class="line">        <span class="type">WechatUser</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WechatUser</span>(<span class="string">&quot;用户B&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用户A订阅公众号A</span></span><br><span class="line">        accountA.addObserver(user1);</span><br><span class="line">        <span class="comment">// 用户A订阅公众号B</span></span><br><span class="line">        accountB.addObserver(user1);</span><br><span class="line">        <span class="comment">// 用户B订阅公众号B</span></span><br><span class="line">        accountB.addObserver(user2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布新内容</span></span><br><span class="line">        accountA.publishNewContent(<span class="string">&quot;新内容A1&quot;</span>);</span><br><span class="line">        accountB.publishNewContent(<span class="string">&quot;新内容B1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用户A取消订阅公众号A</span></span><br><span class="line">        accountA.removeObserver(user1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布新内容</span></span><br><span class="line">        accountA.publishNewContent(<span class="string">&quot;新内容A2&quot;</span>);</span><br><span class="line">        accountB.publishNewContent(<span class="string">&quot;新内容B2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果：</strong></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">用户 用户A 收到了公众号 公众号A 的新内容：新内容A1</span><br><span class="line">用户 用户A 收到了公众号 公众号B 的新内容：新内容B1</span><br><span class="line">用户 用户B 收到了公众号 公众号B 的新内容：新内容B1</span><br><span class="line">用户 用户A 收到了公众号 公众号A 的新内容：新内容A2</span><br><span class="line">用户 用户B 收到了公众号 公众号B 的新内容：新内容B2</span><br></pre></td></tr></table></figure>

<h1 id="行为型-访问者-Visitor"><a href="#行为型-访问者-Visitor" class="headerlink" title="行为型 - 访问者(Visitor)"></a>行为型 - 访问者(Visitor)</h1><blockquote>
<p>当你想要为一个对象的组合增加新的能力, 且封装并不重要时, 就使用访问者模式</p>
</blockquote>
<h2 id="示例：喂宠物"><a href="#示例：喂宠物" class="headerlink" title="示例：喂宠物"></a>示例：喂宠物</h2><p>现在养宠物的人特别多，我们就以这个为例，当然宠物还分为狗，猫等，要给宠物喂食的话，主人可以喂，其他人也可以喂食</p>
<p><strong>被访问元素抽象类<code>Animal</code>：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(PetVisitor visitor)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>被访问元素</strong>——宠物狗类<code>Dog</code>和宠物猫类<code>Cat</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String breed;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(PetVisitor visitor)</span> &#123;</span><br><span class="line">        visitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的宠物猫类</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(PetVisitor visitor)</span> &#123;</span><br><span class="line">        visitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问者接口<code>PetVisitor</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PetVisitor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Dog dog)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Cat cat)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>访问者实现类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主人访问者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Owner</span> <span class="keyword">implements</span> <span class="title class_">PetVisitor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主人给狗狗 &quot;</span> + dog.getName() + <span class="string">&quot; 喂食&quot;</span>);</span><br><span class="line">        <span class="comment">// 具体的喂食逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Cat cat)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主人给猫咪 &quot;</span> + cat.getName() + <span class="string">&quot; 喂食&quot;</span>);</span><br><span class="line">        <span class="comment">// 具体的喂食逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他人访问者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Others</span> <span class="keyword">implements</span> <span class="title class_">PetVisitor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;其他人给狗狗 &quot;</span> + dog.getName() + <span class="string">&quot; 喂食&quot;</span>);</span><br><span class="line">        <span class="comment">// 具体的喂食逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Cat cat)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;其他人给猫咪 &quot;</span> + cat.getName() + <span class="string">&quot; 喂食&quot;</span>);</span><br><span class="line">        <span class="comment">// 具体的喂食逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisitorPatternExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建具体的宠物对象</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺财&quot;</span>, <span class="string">&quot;金毛&quot;</span>);</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;小花&quot;</span>, <span class="string">&quot;橘猫&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建具体的访问者对象</span></span><br><span class="line">        <span class="type">PetVisitor</span> <span class="variable">owner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Owner</span>();</span><br><span class="line">        <span class="type">PetVisitor</span> <span class="variable">others</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Others</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 被访问元素接受访问者的访问</span></span><br><span class="line">        dog.accept(owner);</span><br><span class="line">        cat.accept(others);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码，输出将是：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">主人给狗狗 旺财 喂食</span><br><span class="line">其他人给猫咪 小花 喂食</span><br></pre></td></tr></table></figure>

<h1 id="行为型-状态-State"><a href="#行为型-状态-State" class="headerlink" title="行为型 - 状态(State)"></a>行为型 - 状态(State)</h1><blockquote>
<p>允许对象在内部状态改变时改变它的行为</p>
</blockquote>
<h2 id="示例：自动售货机"><a href="#示例：自动售货机" class="headerlink" title="示例：自动售货机"></a>示例：自动售货机</h2><p>自动售货机根据当前的状态来决定如何响应用户的操作。例如，在待机状态下，用户插入硬币可能会触发状态转换到选择商品的状态；而在售出商品状态下，用户取出商品后，状态会转换回待机状态。状态模式可以用于管理自动售货机的各种状态，并根据不同状态执行相应的操作。</p>
<p><strong>自动售货机类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VendingMachine</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> VendingMachineState state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertCoin</span><span class="params">()</span> &#123;</span><br><span class="line">        state.insertCoin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        state.selectProduct();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出货</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispenseProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        state.dispenseProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>售货机状态接口：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">VendingMachineState</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insertCoin</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">selectProduct</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dispenseProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>状态实现类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 待机状态类</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IdleState</span> <span class="keyword">implements</span> <span class="title class_">VendingMachineState</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> VendingMachine vendingMachine;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertCoin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 执行插入硬币操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;已插入硬币&quot;</span>);</span><br><span class="line">        vendingMachine.setState(<span class="keyword">new</span> <span class="title class_">SelectProductState</span>(vendingMachine));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请先插入硬币&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispenseProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请先选择商品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择商品状态类</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SelectProductState</span> <span class="keyword">implements</span> <span class="title class_">VendingMachineState</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> VendingMachine vendingMachine;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertCoin</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已插入硬币，请选择商品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 执行选择商品操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;已选择商品&quot;</span>);</span><br><span class="line">        vendingMachine.setState(<span class="keyword">new</span> <span class="title class_">SoldOutState</span>(vendingMachine));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispenseProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请先选择商品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 售出商品状态类</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SoldOutState</span> <span class="keyword">implements</span> <span class="title class_">VendingMachineState</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> VendingMachine vendingMachine;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertCoin</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;商品已售罄&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;商品已售罄&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispenseProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;商品已售罄&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VendingMachineExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">VendingMachine</span> <span class="variable">vendingMachine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VendingMachine</span>();</span><br><span class="line">        vendingMachine.setState(<span class="keyword">new</span> <span class="title class_">IdleState</span>(vendingMachine));</span><br><span class="line"></span><br><span class="line">        vendingMachine.insertCoin();</span><br><span class="line">        vendingMachine.selectProduct();</span><br><span class="line">        vendingMachine.dispenseProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">已插入硬币</span><br><span class="line">已选择商品</span><br><span class="line">请先选择商品</span><br></pre></td></tr></table></figure>

<h1 id="行为型-解释器-Interpreter"><a href="#行为型-解释器-Interpreter" class="headerlink" title="行为型 - 解释器(Interpreter)"></a>行为型 - 解释器(Interpreter)</h1><blockquote>
<p>使用解释器模式为语言创建解释器，通常由语言的语法和语法分析来定义</p>
</blockquote>
<h2 id="示例：正则表达式引擎"><a href="#示例：正则表达式引擎" class="headerlink" title="示例：正则表达式引擎"></a>示例：正则表达式引擎</h2><p>正则表达式是一种强大的文本模式匹配工具，常用于字符串处理、文本搜索和替换等任务。正则表达式引擎使用解释器模式来解析和执行正则表达式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象表达式接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解释给定的输入是否符合表达式。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input 输入字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果输入符合表达式则返回true，否则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(String input)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终结符表达式类 - 字符表达式</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CharacterExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> character;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解释给定的输入是否包含字符表达式中的字符。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input 输入字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果输入包含字符表达式中的字符则返回true，否则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(String input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> input.contains(Character.toString(character));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非终结符表达式类 - 或表达式</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Expression expression1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Expression expression2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解释给定的输入是否符合或表达式的条件。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input 输入字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果输入符合或表达式的条件则返回true，否则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(String input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> expression1.interpret(input) || expression2.interpret(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegularExpressionEngine</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 构建正则表达式：b|c</span></span><br><span class="line">        <span class="type">Expression</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrExpression</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">CharacterExpression</span>(<span class="string">&#x27;b&#x27;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">CharacterExpression</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输入字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用正则表达式引擎解析和执行正则表达式</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isMatch</span> <span class="operator">=</span> expression.interpret(input);</span><br><span class="line">        System.out.println(<span class="string">&quot;Input: &quot;</span> + input);</span><br><span class="line">        System.out.println(<span class="string">&quot;Match result: &quot;</span> + isMatch);  <span class="comment">// Output: true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="行为型-迭代器-Iterator"><a href="#行为型-迭代器-Iterator" class="headerlink" title="行为型 - 迭代器(Iterator)"></a>行为型 - 迭代器(Iterator)</h1><blockquote>
<p>提供一种方法顺序访问一个聚合对象中的各个元素, 而又不暴露其内部的表示</p>
</blockquote>
<p>直接用for循环替代吧，没啥好说的</p>
<h1 id="行为型-中介者-Mediator"><a href="#行为型-中介者-Mediator" class="headerlink" title="行为型 - 中介者(Mediator)"></a>行为型 - 中介者(Mediator)</h1><blockquote>
<p>中介者模式（Mediator Pattern）用于解耦一组对象之间的交互关系。它通过引入一个中介者对象，将各个对象之间的交互逻辑集中处理。中介者模式的重点在于对象之间的通信和协调。</p>
</blockquote>
<h2 id="中介者vs外观"><a href="#中介者vs外观" class="headerlink" title="中介者vs外观"></a>中介者vs外观</h2><ul>
<li><p>中介者模式（Mediator Pattern）用于解耦一组对象之间的交互关系。它通过引入一个中介者对象，将各个对象之间的交互逻辑集中处理。中介者模式的重点在于对象之间的通信和协调。</p>
</li>
<li><p>外观模式（Facade Pattern）主要用于简化复杂系统的接口。它提供了一个统一的接口，隐藏系统的复杂性，使得客户端可以更方便地访问子系统。外观模式的重点在于封装和简化接口。</p>
</li>
<li><p>简单来说，中介者更像是一个中转站，而外观模式则是起点（入口）</p>
</li>
</ul>
<h2 id="示例：GUI开发"><a href="#示例：GUI开发" class="headerlink" title="示例：GUI开发"></a>示例：GUI开发</h2><p>在GUI中，有多个组件（如按钮、文本框、下拉列表等），它们之间需要进行交互和通信。使用中介者模式可以将这些交互逻辑集中处理，并避免组件之间的紧耦合。</p>
<p><strong>中介者接口<code>Mediator</code>，它包含了组件之间的交互方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(Component sender, String event)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>中介者实现类<code>GUIManager</code>，实现中介者接口，负责协调组件之间的交互：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GUIManager</span> <span class="keyword">implements</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Button button;</span><br><span class="line">    <span class="keyword">private</span> TextBox textBox;</span><br><span class="line">    <span class="keyword">private</span> ComboBox comboBox;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(Component sender, String event)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sender == button &amp;&amp; event.equals(<span class="string">&quot;click&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 处理按钮点击事件的逻辑</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">selectedValue</span> <span class="operator">=</span> comboBox.getSelectedValue();</span><br><span class="line">            textBox.setText(<span class="string">&quot;Selected: &quot;</span> + selectedValue);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sender == textBox &amp;&amp; event.equals(<span class="string">&quot;change&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 处理文本框内容变化事件的逻辑</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> textBox.getText();</span><br><span class="line">            comboBox.filterOptions(text);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>组件类接口及其实现：</strong></p>
<blockquote>
<p>在中介者模式中，将<code>Component</code>定义为一个接口是为了强调组件的行为和协议，而不关注具体实现细节。</p>
<p>使用接口的好处是可以实现多重继承，即一个类可以同时实现多个接口。这样，在需要与其他组件进行交互时，组件类可以通过实现<code>Component</code>接口来获得中介者的引用，并实现中介者模式所需的方法。接口的使用还可以帮助实现松耦合，使得组件之间更加灵活和可替换。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setMediator</span><span class="params">(Mediator mediator)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String event)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Button</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMediator</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String event)</span> &#123;</span><br><span class="line">        mediator.notify(<span class="built_in">this</span>, event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">click</span><span class="params">()</span> &#123;</span><br><span class="line">        notify(<span class="string">&quot;click&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TextBox</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMediator</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String event)</span> &#123;</span><br><span class="line">        mediator.notify(<span class="built_in">this</span>, event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">()</span> &#123;</span><br><span class="line">        notify(<span class="string">&quot;change&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComboBox</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMediator</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String event)</span> &#123;</span><br><span class="line">        mediator.notify(<span class="built_in">this</span>, event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">filterOptions</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据文本过滤选项</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSelectedValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取选中的值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MediatorExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>();</span><br><span class="line">        <span class="type">TextBox</span> <span class="variable">textBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextBox</span>();</span><br><span class="line">        <span class="type">ComboBox</span> <span class="variable">comboBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboBox</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Mediator</span> <span class="variable">mediator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GUIManager</span>(button, textBox, comboBox);</span><br><span class="line"></span><br><span class="line">        button.setMediator(mediator);</span><br><span class="line">        textBox.setMediator(mediator);</span><br><span class="line">        comboBox.setMediator(mediator);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟按钮点击事件</span></span><br><span class="line">        button.click();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟文本框内容变化事件</span></span><br><span class="line">        textBox.change();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，各个组件通过中介者接口进行交互，而不是直接相互引用。中介者负责协调和处理组件之间的交互逻辑，从而实现了解耦和集中管理的效果。这样，当需要新增、修改或删除交互逻辑时，只需修改中介者类，而不需要修改多个组件类，提高了代码的可维护性和可扩展性。</p>
<h1 id="行为型-备忘录-Memento"><a href="#行为型-备忘录-Memento" class="headerlink" title="行为型 - 备忘录(Memento)"></a>行为型 - 备忘录(Memento)</h1><blockquote>
<p>当你需要让对象返回之前的状态时，可以使用备忘录模式</p>
</blockquote>
<h2 id="示例：恢复游戏存档"><a href="#示例：恢复游戏存档" class="headerlink" title="示例：恢复游戏存档"></a>示例：恢复游戏存档</h2><p><strong>Originator（发起人）——游戏类：</strong>包含了当前游戏的状态数据，并提供了保存和恢复状态的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> level;</span><br><span class="line">    <span class="keyword">private</span> String checkpoint;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在游戏中玩游戏并更新游戏状态</span></span><br><span class="line">        level++;</span><br><span class="line">        checkpoint = <span class="string">&quot;Check Point &quot;</span> + level;</span><br><span class="line">        System.out.println(<span class="string">&quot;Playing game at Level &quot;</span> + level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> GameState <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GameState</span>(level, checkpoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restore</span><span class="params">(GameState gameState)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.level = gameState.getLevel();</span><br><span class="line">        <span class="built_in">this</span>.checkpoint = gameState.getCheckpoint();</span><br><span class="line">        System.out.println(<span class="string">&quot;Restoring game at Level &quot;</span> + level + <span class="string">&quot;, Check Point: &quot;</span> + checkpoint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Memento（备忘录）——游戏状态类：</strong>它存储了游戏的状态数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameState</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> level;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String checkpoint;</span><br><span class="line">    <span class="comment">// 其他游戏状态相关的属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Caretaker（管理者）——游戏管理类：</strong>负责保存和提供备忘录对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameCareTaker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;GameState&gt; gameStateList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveState</span><span class="params">(GameState gameState)</span> &#123;</span><br><span class="line">        gameStateList.add(gameState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> GameState <span class="title function_">restoreState</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; gameStateList.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> gameStateList.get(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameSaveDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建游戏对象</span></span><br><span class="line">        <span class="type">Game</span> <span class="variable">game</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Game</span>();</span><br><span class="line">        <span class="comment">// 创建游戏管理对象</span></span><br><span class="line">        <span class="type">GameCareTaker</span> <span class="variable">careTaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GameCareTaker</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行游戏，修改状态</span></span><br><span class="line">        game.play(); </span><br><span class="line">        <span class="comment">// 保存当前游戏状态到存档</span></span><br><span class="line">        careTaker.saveState(game.save());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次进行游戏，修改状态</span></span><br><span class="line">        game.play();</span><br><span class="line">        <span class="comment">// 保存当前游戏状态到存档</span></span><br><span class="line">        careTaker.saveState(game.save());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 恢复第一个存档</span></span><br><span class="line">        <span class="type">GameState</span> <span class="variable">savedState1</span> <span class="operator">=</span> careTaker.restoreState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (savedState1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            game.restore(savedState1);</span><br><span class="line">            game.printState(); <span class="comment">// 打印恢复后的游戏状态</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 恢复第二个存档</span></span><br><span class="line">        <span class="type">GameState</span> <span class="variable">savedState2</span> <span class="operator">=</span> careTaker.restoreState(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (savedState2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            game.restore(savedState2);</span><br><span class="line">            game.printState(); <span class="comment">// 打印恢复后的游戏状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>代码美学</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Protobuf3 语言指南</title>
    <url>/blog/2023/06/21/Protobuf3%20%E8%AF%AD%E8%A8%80%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<blockquote>
<p>英文文档：<a href="https://developers.google.com/protocol-buffers/docs/proto3?hl=zh-cn#generating">Language Guide(proto3)</a></p>
<p>汉化文档参考：<a href="https://github.com/lixiangyun/protobuf_doc_ZH_CN">https://github.com/lixiangyun/protobuf_doc_ZH_CN</a></p>
<p>本文基于汉化文档魔改，用一些简单的代码示例替代冗长的表述，降低学习protobuf3的时间成本</p>
</blockquote>
<h1 id="为什么使用protobuf"><a href="#为什么使用protobuf" class="headerlink" title="为什么使用protobuf"></a>为什么使用protobuf</h1><p>新人在使用gRPC的时候，常常会有以下疑问</p>
<p>Q: 欸？我直接写Request和Response类不好吗，为啥要用protobuf定义消息类型并编译</p>
<p>A: 使用.proto文件定义消息结构，然后通过protobuf编译器生成对应的Java类或其他编程语言的类，是为了方便不同编程语言之间的数据传输和解析。</p>
<p><strong>protobuf所采用的二进制格式非常紧凑，而且具有高效的序列化和反序列化性能。因此，可以将使用不同编程语言开发的应用程序之间的数据传输格式标准化，从而实现跨语言的数据交换。</strong></p>
<p>此外，使用生成的Java类可以更方便地操作protobuf消息对象及其中的字段。protobuf编译器生成的Java类包含了许多有用的方法，如setter和getter方法，以及对protobuf消息对象的序列化和反序列化方法等，这些方法和操作简单方便，可以提高开发效率。</p>
<p>因此，通过protobuf编译器生成Java类或其他类，可以将消息结构定义与底层编码和解码逻辑分离，使得代码更加清晰、易读和易维护，同时也方便了跨语言数据传输。</p>
<p><strong>简单来说，在proto文件定义完编译生成的类只是方便对应语言的开发者开发服务的，消息传输还是用的protobuf，就像广东的内部交流可能说粤语，重庆的内部交流可能说重庆话，但当重庆人要和广东人交流，那毫无疑问还是用统一标准的普通话好</strong></p>
<h1 id="定义一个消息类型"><a href="#定义一个消息类型" class="headerlink" title="定义一个消息类型"></a>定义一个消息类型</h1><p>我们上面讲到：<strong>在生成的Java代码中，每个消息类型对应一个Java类，其中每个字段都有对应的getter和setter方法。同时，Java类还提供了对应的构造函数、toString方法等，方便开发者快速处理消息。</strong></p>
<p>先来看一个非常简单的例子。假设你想定义一个“搜索请求”的消息格式，每一个请求含有一个查询字符串、你感兴趣的查询结果所在的页数，以及每一页多少条查询结果。可以采用如下的方式来定义消息类型的.proto文件了：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">SearchRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int32</span> result_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>文件的第一行指定了你正在使用proto3语法：如果你没有指定这个，编译器会使用proto2。这个指定语法行必须是文件的非空非注释的第一个行。</li>
<li><code>SearchRequest</code>消息格式有3个字段，在消息中承载的数据分别对应于每一个字段。其中每个字段都有一个名字和一种类型。</li>
</ul>
<h2 id="指定字段类型"><a href="#指定字段类型" class="headerlink" title="指定字段类型"></a>指定字段类型</h2><p>在上面的例子中，所有字段都是标量类型：两个整型（<code>page_number</code>和<code>result_per_page</code>），一个string类型（<code>query</code>）。当然，你也可以为字段指定其他的合成类型，包括枚举（enumerations）或其他消息类型。</p>
<h2 id="分配标识号"><a href="#分配标识号" class="headerlink" title="分配标识号"></a>分配标识号</h2><p>正如你所见，在消息定义中，每个字段都有唯一的一个数字标识符。这些标识符是用来在消息的二进制格式中识别各个字段的，一旦开始使用就不能够再改变。注：[1,15]之内的标识号在编码的时候会占用一个字节。[16,2047]之内的标识号则占用2个字节。所以应该为那些频繁出现的消息元素保留 [1,15]之内的标识号。切记：要为将来有可能添加的、频繁出现的标识号预留一些标识号。</p>
<p>最小的标识号可以从1开始，最大到2^29 - 1, or 536,870,911。不可以使用其中的[19000－19999]（ (从FieldDescriptor::kFirstReservedNumber 到 FieldDescriptor::kLastReservedNumber)）的标识号， Protobuf协议实现中对这些进行了预留。如果非要在.proto文件中使用这些预留标识号，编译时就会报警。同样你也不能使用早期保留的标识号。</p>
<h2 id="指定字段规则"><a href="#指定字段规则" class="headerlink" title="指定字段规则"></a>指定字段规则</h2><blockquote>
<p>所指定的消息字段修饰符必须是如下之一：</p>
<ul>
<li><code>singular</code>(默认)：一个格式良好的消息应该有0个或者1个这种字段（但是不能超过1个）</li>
<li><code>repeated</code>：在一个格式良好的消息中，这种字段可以重复任意多次（包括0次）。重复的值的顺序会被保留。</li>
</ul>
<p>在proto3中，repeated的标量域默认情况下使用packed。</p>
</blockquote>
<p><code>repeated</code>字段在Protocol Buffers中对应了Java中的<code>List</code>类型。它允许在消息中存储多个相同类型的值，并以列表形式进行操作。</p>
<p>当使用Protocol Buffers生成的Java类时，<code>repeated</code>字段会被映射为一个<code>List</code>类型的属性。您可以通过调用该属性的方法来添加、获取、修改和删除其中的元素。</p>
<p>例如，在示例代码中的<code>UserList</code>消息类型中，<code>repeated User users</code>字段会被映射为一个<code>List&lt;User&gt;</code>类型的属性。您可以使用<code>getUsersList()</code>方法获取用户列表，然后使用<code>add()</code>方法添加新的用户，或者使用下标索引对特定位置的用户进行读取或写入操作。</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">UserList</span> &#123;</span><br><span class="line">  <span class="keyword">repeated</span> User users = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以假设生成的Java代码包名为<code>com.example.demo</code>，生成的类为<code>User</code>和<code>UserList</code>。</p>
<p>下面是一个简单的使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.demo.UserList;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理用户创建逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserList <span class="title function_">getUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟从数据库中获取用户列表</span></span><br><span class="line">        List&lt;User&gt; userList = Arrays.asList(</span><br><span class="line">                User.newBuilder().setName(<span class="string">&quot;张三&quot;</span>).setAge(<span class="number">18</span>).build(),</span><br><span class="line">                User.newBuilder().setName(<span class="string">&quot;李四&quot;</span>).setAge(<span class="number">20</span>).build()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建UserList对象，并设置用户列表</span></span><br><span class="line">        <span class="type">UserList</span> <span class="variable">userListObj</span> <span class="operator">=</span> UserList.newBuilder().addAllUsers(userList).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userListObj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们通过<code>@RequestBody</code>注解接收请求体中的User对象，并执行相应的业务逻辑。在返回用户列表时，我们首先模拟获取用户列表的过程，然后使用<code>UserList</code>对象来封装用户列表，并将其返回给客户端。</p>
<h2 id="添加更多消息类型"><a href="#添加更多消息类型" class="headerlink" title="添加更多消息类型"></a>添加更多消息类型</h2><p>在一个.proto文件中可以定义多个消息类型。在定义多个相关的消息的时候，这一点特别有用——例如，如果想定义与SearchResponse消息类型对应的回复消息格式的话，你可以将它添加到相同的.proto文件中，如：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int32</span> result_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">SearchResponse</span> &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加注释"><a href="#添加注释" class="headerlink" title="添加注释"></a>添加注释</h2><p>向.proto文件添加注释，可以使用C&#x2F;C++&#x2F;java风格的双斜杠（&#x2F;&#x2F;） 语法格式，如：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> page_number = <span class="number">2</span>;  <span class="comment">// Which page number do we want?</span></span><br><span class="line">  <span class="type">int32</span> result_per_page = <span class="number">3</span>;  <span class="comment">// Number of results to return per page.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="保留标识符（Reserved）"><a href="#保留标识符（Reserved）" class="headerlink" title="保留标识符（Reserved）"></a>保留标识符（Reserved）</h2><p>简单来说，这个就是用来占位的，比方说：</p>
<ul>
<li>我先把3, 4标识符先占了</li>
<li><code>age</code>的字段我也占了</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">  reserved <span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那后面的人就不能用你占了的这些字段和标识符了。现在如果我想更新<code>Person</code>这个消息类型，把3号位给<code>age</code>只需要</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">3</span>;</span><br><span class="line">  reserved <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：不要在同一行reserved声明中同时声明域名字和标识号</p>
<h2 id="从-proto文件生成了什么？"><a href="#从-proto文件生成了什么？" class="headerlink" title="从.proto文件生成了什么？"></a>从.proto文件生成了什么？</h2><p>当用protocol buffer编译器来运行.proto文件时，编译器将生成所选择语言的代码，这些代码可以操作在.proto文件中定义的消息类型，包括获取、设置字段值，将消息序列化到一个输出流中，以及从一个输入流中解析消息。</p>
<ul>
<li>对C++来说，编译器会为每个.proto文件生成一个.h文件和一个.cc文件，.proto文件中的每一个消息有一个对应的类。</li>
<li>对Java来说，编译器为每一个消息类型生成了一个.java文件，以及一个特殊的Builder类（该类是用来创建消息类接口的）。</li>
<li>对Python来说，有点不太一样——Python编译器为.proto文件中的每个消息类型生成一个含有静态描述符的模块，，该模块与一个元类（metaclass）在运行时（runtime）被用来创建所需的Python数据访问类。</li>
<li>对go来说，编译器会位每个消息类型生成了一个.pd.go文件。</li>
<li>对于Ruby来说，编译器会为每个消息类型生成了一个.rb文件。</li>
<li>javaNano来说，编译器输出类似域java但是没有Builder类</li>
<li>对于Objective-C来说，编译器会为每个消息类型生成了一个pbobjc.h文件和pbobjcm文件，.proto文件中的每一个消息有一个对应的类。</li>
<li>对于C#来说，编译器会为每个消息类型生成了一个.cs文件，.proto文件中的每一个消息有一个对应的类。</li>
</ul>
<p>你可以从如下的文档链接中获取每种语言更多API(proto3版本的内容很快就公布)。<a href="https://developers.google.com/protocol-buffers/docs/reference/overview?hl=zh-cn">API Reference</a></p>
<h1 id="标量数值类型"><a href="#标量数值类型" class="headerlink" title="标量数值类型"></a>标量数值类型</h1><p>一个标量消息字段可以含有一个如下的类型——该表格展示了定义于.proto文件中的类型，以及与之对应的、在自动生成的访问类中定义的类型：</p>
<table>
<thead>
<tr>
<th>.proto Type</th>
<th>Notes</th>
<th>C++ Type</th>
<th>Java Type</th>
<th>Python Type[2]</th>
<th>Go Type</th>
<th>Ruby Type</th>
<th>C# Type</th>
<th>PHP Type</th>
</tr>
</thead>
<tbody><tr>
<td>double</td>
<td></td>
<td>double</td>
<td>double</td>
<td>float</td>
<td>float64</td>
<td>Float</td>
<td>double</td>
<td>float</td>
</tr>
<tr>
<td>float</td>
<td></td>
<td>float</td>
<td>float</td>
<td>float</td>
<td>float32</td>
<td>Float</td>
<td>float</td>
<td>float</td>
</tr>
<tr>
<td>int32</td>
<td>使用变长编码，对于负值的效率很低，如果你的域有可能有负值，请使用sint64替代</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>int32</td>
<td>Fixnum 或者 Bignum（根据需要）</td>
<td>int</td>
<td>integer</td>
</tr>
<tr>
<td>uint32</td>
<td>使用变长编码</td>
<td>uint32</td>
<td>int</td>
<td>int&#x2F;long</td>
<td>uint32</td>
<td>Fixnum 或者 Bignum（根据需要）</td>
<td>uint</td>
<td>integer</td>
</tr>
<tr>
<td>uint64</td>
<td>使用变长编码</td>
<td>uint64</td>
<td>long</td>
<td>int&#x2F;long</td>
<td>uint64</td>
<td>Bignum</td>
<td>ulong</td>
<td>integer&#x2F;string</td>
</tr>
<tr>
<td>sint32</td>
<td>使用变长编码，这些编码在负值时比int32高效的多</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>int32</td>
<td>Fixnum 或者 Bignum（根据需要）</td>
<td>int</td>
<td>integer</td>
</tr>
<tr>
<td>sint64</td>
<td>使用变长编码，有符号的整型值。编码时比通常的int64高效。</td>
<td>int64</td>
<td>long</td>
<td>int&#x2F;long</td>
<td>int64</td>
<td>Bignum</td>
<td>long</td>
<td>integer&#x2F;string</td>
</tr>
<tr>
<td>fixed32</td>
<td>总是4个字节，如果数值总是比总是比228大的话，这个类型会比uint32高效。</td>
<td>uint32</td>
<td>int</td>
<td>int</td>
<td>uint32</td>
<td>Fixnum 或者 Bignum（根据需要）</td>
<td>uint</td>
<td>integer</td>
</tr>
<tr>
<td>fixed64</td>
<td>总是8个字节，如果数值总是比总是比256大的话，这个类型会比uint64高效。</td>
<td>uint64</td>
<td>long</td>
<td>int&#x2F;long</td>
<td>uint64</td>
<td>Bignum</td>
<td>ulong</td>
<td>integer&#x2F;string</td>
</tr>
<tr>
<td>sfixed32</td>
<td>总是4个字节</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>int32</td>
<td>Fixnum 或者 Bignum（根据需要）</td>
<td>int</td>
<td>integer</td>
</tr>
<tr>
<td>sfixed64</td>
<td>总是8个字节</td>
<td>int64</td>
<td>long</td>
<td>int&#x2F;long</td>
<td>int64</td>
<td>Bignum</td>
<td>long</td>
<td>integer&#x2F;string</td>
</tr>
<tr>
<td>bool</td>
<td></td>
<td>bool</td>
<td>boolean</td>
<td>bool</td>
<td>bool</td>
<td>TrueClass&#x2F;FalseClass</td>
<td>bool</td>
<td>boolean</td>
</tr>
<tr>
<td>string</td>
<td>一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本。</td>
<td>string</td>
<td>String</td>
<td>str&#x2F;unicode</td>
<td>string</td>
<td>String (UTF-8)</td>
<td>string</td>
<td>string</td>
</tr>
<tr>
<td>bytes</td>
<td>可能包含任意顺序的字节数据。</td>
<td>string</td>
<td>ByteString</td>
<td>str</td>
<td>[]byte</td>
<td>String (ASCII-8BIT)</td>
<td>ByteString</td>
<td>string</td>
</tr>
</tbody></table>
<h1 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h1><p>当一个消息被解析的时候，如果被编码的信息不包含一个特定的singular元素，被解析的对象锁对应的域被设置位一个默认值，对于不同类型指定如下：</p>
<ul>
<li>对于strings，默认是一个空string</li>
<li>对于bytes，默认是一个空的bytes</li>
<li>对于bools，默认是false</li>
<li>对于数值类型，默认是0</li>
<li>对于枚举，默认是第一个定义的枚举值，必须为0;</li>
<li>对于消息类型（message），域没有被设置，确切的消息是根据语言确定的，详见<a href="https://developers.google.com/protocol-buffers/docs/reference/overview?hl=zh-cn">generated code guide</a>。</li>
</ul>
<p>对于可重复域的默认值是空（通常情况下是对应语言中空列表）。</p>
<p>注：对于标量消息域，一旦消息被解析，就无法判断域释放被设置为默认值（例如，例如boolean值是否被设置为false）还是根本没有被设置。你应该在定义你的消息类型时非常注意。例如，比如你不应该定义boolean的默认值false作为任何行为的触发方式。也应该注意如果一个标量消息域被设置为标志位，这个值不应该被序列化传输。</p>
<p>查看<a href="https://developers.google.com/protocol-buffers/docs/reference/overview?hl=zh-cn">generated code guide</a>选择你的语言的默认值的工作细节。</p>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>当需要定义一个消息类型的时候，可能想为一个字段指定某“预定义值序列”中的一个值。例如，假设要为每一个SearchRequest消息添加一个 corpus字段，而corpus的值可能是UNIVERSAL，WEB，IMAGES，LOCAL，NEWS，PRODUCTS或VIDEO中的一个。 其实可以很容易地实现这一点：通过向消息定义中添加一个枚举（enum）并且为每个可能的值定义一个常量就可以了。</p>
<p>在下面的例子中，在消息格式中添加了一个叫做Corpus的枚举类型——它含有所有可能的值 ——以及一个类型为Corpus的字段：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int32</span> result_per_page = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">enum </span><span class="title class_">Corpus</span> &#123;</span><br><span class="line">    UNIVERSAL = <span class="number">0</span>;</span><br><span class="line">    WEB = <span class="number">1</span>;</span><br><span class="line">    IMAGES = <span class="number">2</span>;</span><br><span class="line">    LOCAL = <span class="number">3</span>;</span><br><span class="line">    NEWS = <span class="number">4</span>;</span><br><span class="line">    PRODUCTS = <span class="number">5</span>;</span><br><span class="line">    VIDEO = <span class="number">6</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Corpus corpus = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如你所见，Corpus枚举的第一个常量映射为0：每个枚举类型必须将其第一个类型映射为0，这是因为：</p>
<ul>
<li>必须有有一个0值，我们可以用这个0值作为默认值。</li>
<li>这个零值必须为第一个元素，为了兼容proto2语义，枚举类的第一个值总是默认值。</li>
</ul>
<p>你可以通过将不同的枚举常量指定为相同的值。如果这样做你需要将<code>allow_alias</code>设定为true，否则编译器会在相同值地方产生一个错误信息。</p>
<p>比如对于下面的代码，编译铁定出错，因为<code>STARTED</code> 和 <code>RUNNING</code> 都被赋予了相同的值 1：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum </span><span class="title class_">EnumNotAllowingAlias</span> &#123;</span><br><span class="line">  UNKNOWN = <span class="number">0</span>;</span><br><span class="line">  STARTED = <span class="number">1</span>;</span><br><span class="line">  RUNNING = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但如果加上<code>allow_alias</code>，这意味着你可以使用 <code>STARTED</code> 或 <code>RUNNING</code> 来表示同一个概念</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum </span><span class="title class_">EnumAllowingAlias</span> &#123;</span><br><span class="line">  <span class="keyword">option</span> allow_alias = <span class="literal">true</span>;</span><br><span class="line">  UNKNOWN = <span class="number">0</span>;</span><br><span class="line">  STARTED = <span class="number">1</span>;</span><br><span class="line">  RUNNING = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举常量必须在32位整型值的范围内。因为enum值是使用可变编码方式的，对负数不够高效，因此不推荐在enum中使用负数。如上例所示，可以在 一个消息定义的内部或外部定义枚举——这些枚举可以在.proto文件中的任何消息定义里重用。当然也可以在一个消息中声明一个枚举类型，而在另一个不同 的消息中使用它——采用MessageType.EnumType的语法格式。</p>
<p>当对一个使用了枚举的.proto文件运行protocol buffer编译器的时候，生成的代码中将有一个对应的enum（对Java或C++来说），或者一个特殊的EnumDescriptor类（对 Python来说），它被用来在运行时生成的类中创建一系列的整型值符号常量（symbolic constants）。</p>
<p>在反序列化的过程中，无法识别的枚举值会被保存在消息中，虽然这种表示方式需要依据所使用语言而定。在那些支持开放枚举类型超出指定范围之外的语言中（例如C++和Go），为识别的值会被表示成所支持的整型。在使用封闭枚举类型的语言中（Java），使用枚举中的一个类型来表示未识别的值，并且可以使用所支持整型来访问。在其他情况下，如果解析的消息被序列号，未识别的值将保持原样。</p>
<p>关于如何在你的应用程序的消息中使用枚举的更多信息，请查看所选择的语言<a href="http://code.google.com/intl/zh-CN/apis/protocolbuffers/docs/reference/overview.html%E3%80%82">generated code guide</a></p>
<h1 id="使用其他消息类型-对应Java的嵌套"><a href="#使用其他消息类型-对应Java的嵌套" class="headerlink" title="使用其他消息类型(对应Java的嵌套)"></a>使用其他消息类型(对应Java的嵌套)</h1><p>你可以将其他消息类型用作字段类型。例如，假设在每一个SearchResponse消息中包含Result消息，此时可以在相同的.proto文件中定义一个Result消息类型，然后在SearchResponse消息中指定一个Result类型的字段，如：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchResponse</span> &#123;</span><br><span class="line">  <span class="keyword">repeated</span> Result results = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Result</span> &#123;</span><br><span class="line">  <span class="type">string</span> url = <span class="number">1</span>;</span><br><span class="line">  <span class="type">string</span> title = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="type">string</span> snippets = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="导入定义"><a href="#导入定义" class="headerlink" title="导入定义"></a>导入定义</h2><p>在上面的例子中，Result消息类型与SearchResponse是定义在同一文件中的。如果想要使用的消息类型已经在其他.proto文件中已经定义过了呢？<br>你可以通过导入（importing）其他.proto文件中的定义来使用它们。要导入其他.proto文件的定义，你需要在你的文件中添加一个导入声明，如：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;myproject/other_protos.proto&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>默认情况下你只能使用直接导入的.proto文件中的定义. 然而， 有时候你需要移动一个.proto文件到一个新的位置， 可以不直接移动.proto文件， 只需放入一个伪 .proto 文件在老的位置， 然后使用import public转向新的位置。import public 依赖性会通过任意导入包含import public声明的proto文件传递。例如：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是新的proto</span></span><br><span class="line"><span class="comment">// All definitions are moved here</span></span><br></pre></td></tr></table></figure>

<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是旧的proto</span></span><br><span class="line"><span class="comment">// 这是所有客户端正在导入的包</span></span><br><span class="line"><span class="keyword">import</span> public <span class="string">&quot;new.proto&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;other.proto&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端proto</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;old.proto&quot;</span>;</span><br><span class="line"><span class="comment">// 现在你可以使用新久两种包的proto定义了。</span></span><br></pre></td></tr></table></figure>

<p>通过在编译器命令行参数中使用-I&#x2F;–proto_pathprotocal 编译器会在指定目录搜索要导入的文件。如果没有给出标志，编译器会搜索编译命令被调用的目录。通常你只要指定proto_path标志为你的工程根目录就好。并且指定好导入的正确名称就好。</p>
<h2 id="使用proto2消息类型"><a href="#使用proto2消息类型" class="headerlink" title="使用proto2消息类型"></a>使用proto2消息类型</h2><p>在你的proto3消息中导入proto2的消息类型也是可以的，反之亦然，然后proto2枚举不可以直接在proto3的标识符中使用（如果仅仅在proto2消息中使用是可以的）。</p>
<h1 id="嵌套类型-对应Java的内部类"><a href="#嵌套类型-对应Java的内部类" class="headerlink" title="嵌套类型(对应Java的内部类)"></a>嵌套类型(对应Java的内部类)</h1><p>你可以在其他消息类型中定义、使用消息类型，在下面的例子中，Result消息就定义在SearchResponse消息内，如：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchResponse</span> &#123;</span><br><span class="line">  <span class="keyword">message </span><span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="type">string</span> url = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> title = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">string</span> snippets = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">repeated</span> Result results = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你想在它的父消息类型的外部重用这个消息类型，你需要以Parent.Type的形式使用它，如：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SomeOtherMessage</span> &#123;</span><br><span class="line">  SearchResponse.Result result = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，你也可以将消息嵌套任意多层，如：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Outer</span> &#123;                  <span class="comment">// Level 0</span></span><br><span class="line">  <span class="keyword">message </span><span class="title class_">MiddleAA</span> &#123;  <span class="comment">// Level 1</span></span><br><span class="line">    <span class="keyword">message </span><span class="title class_">Inner</span> &#123;   <span class="comment">// Level 2</span></span><br><span class="line">      <span class="type">int64</span> ival = <span class="number">1</span>;</span><br><span class="line">      <span class="type">bool</span>  booly = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">message </span><span class="title class_">MiddleBB</span> &#123;  <span class="comment">// Level 1</span></span><br><span class="line">    <span class="keyword">message </span><span class="title class_">Inner</span> &#123;   <span class="comment">// Level 2</span></span><br><span class="line">      <span class="type">int32</span> ival = <span class="number">1</span>;</span><br><span class="line">      <span class="type">bool</span>  booly = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="更新一个消息类型"><a href="#更新一个消息类型" class="headerlink" title="更新一个消息类型"></a>更新一个消息类型</h1><p>如果一个已有的消息格式已无法满足新的需求——如，要在消息中添加一个额外的字段——但是同时旧版本写的代码仍然可用。不用担心！更新消息而不破坏已有代码是非常简单的。在更新时只要记住以下的规则即可。</p>
<blockquote>
<p>不要更改任何已有的字段的数值标识。</p>
</blockquote>
<p>假设我们有一个旧版本的消息类型 <code>Person</code>，其中包含 <code>name</code> 和 <code>age</code> 两个字段：</p>
<p>旧版本代码示例：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们需要在该消息类型中添加一个新的字段 <code>email</code>，同时遵循规则不更改任何已有字段的数值标识。</p>
<p>更新后的新版本代码示例：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line">  <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，在新版本的代码中，我们增加了一个名为 <code>email</code> 的字段，而没有修改旧字段 <code>name</code> 和 <code>age</code> 的数值标识。</p>
<p>通过这样的更新，旧版本的代码仍然可以正常解析使用旧消息格式的数据，并且只会处理 <code>name</code> 和 <code>age</code> 字段。而新版本的代码可以解析使用新消息格式的数据，并能够同时处理 <code>name</code>、<code>age</code> 和 <code>email</code> 字段。</p>
<blockquote>
<p>如果你增加新的字段，使用旧格式的字段仍然可以被你新产生的代码所解析。你应该记住这些元素的默认值这样你的新代码就可以以适当的方式和旧代码产生的数据交互。相似的，通过新代码产生的消息也可以被旧代码解析：只不过新的字段会被忽视掉。注意，未被识别的字段会在反序列化的过程中丢弃掉，所以如果消息再被传递给新的代码，新的字段依然是不可用的（这和proto2中的行为是不同的，在proto2中未定义的域依然会随着消息被序列化）</p>
</blockquote>
<p>假设我们有一个旧版本的消息类型 <code>Person</code>，包含 <code>name</code> 和 <code>age</code> 字段：</p>
<p>旧版本代码示例：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们要更新消息类型，在其中添加一个新的字段 <code>email</code>。同时，我们需要确保新代码和旧代码之间可以正确解析消息，并处理默认值和未识别字段的情况。</p>
<p>更新后的新版本代码示例：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line">  <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述新版本的代码中，我们增加了一个名为 <code>email</code> 的字段。遵循更新消息类型的规则，该字段的数值标识为 3。</p>
<p>通过这样的更新，我们可以实现以下互操作性：</p>
<ul>
<li><p>旧版本代码解析新消息格式的数据：旧版本代码只能访问到 <code>name</code> 和 <code>age</code> 字段，而无法访问 <code>email</code> 字段。它会忽略掉 <code>email</code> 字段，但仍然能够正常解析和处理 <code>name</code> 和 <code>age</code> 的值。</p>
</li>
<li><p>新版本代码解析旧消息格式的数据：新版本代码可以同时访问 <code>name</code>、<code>age</code> 和 <code>email</code> 字段。对于使用旧消息格式的数据，<code>email</code> 字段会使用默认值（在 <code>proto3</code> 中，默认值为空字符串）。新版本代码可以正确处理这种情况。</p>
</li>
</ul>
<p>此外，当使用新代码生成的消息被传递给旧代码进行解析时，旧代码会忽略掉 <code>email</code> 字段，而未被识别的字段会在反序列化过程中被丢弃。因此，新字段并不可用于旧代码。这种行为与 <code>proto2</code> 的行为不同，因为在 <code>proto2</code> 中，未定义的域会随消息一起被序列化。</p>
<p>通过遵循上述步骤，更新消息类型后，我们可以确保新旧代码之间的互操作性，并正确处理默认值和未识别字段的情况。</p>
<blockquote>
<p>非required的字段可以移除——只要它们的标识号在新的消息类型中不再使用（更好的做法可能是重命名那个字段，例如在字段前添加<code>OBSOLETE_</code>前缀，那样的话，使用的.proto文件的用户将来就不会无意中重新使用了那些不该使用的标识号）。</p>
</blockquote>
<p>假设我们有一个旧版本的消息类型 <code>Person</code>，包含 <code>name</code>、<code>age</code> 和 <code>email</code> 字段：</p>
<p>旧版本代码示例：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line">  <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们要更新消息类型，移除 <code>email</code> 字段。根据建议，更好的做法是将该字段重命名为 <code>OBSOLETE_email</code>，以防止其他用户在未来无意中重新使用该字段的标识号。</p>
<p>更新后的新版本代码示例：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// OBSOLETE_email field, do not use.</span></span><br><span class="line">  <span class="type">string</span> OBSOLETE_email = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述新版本的代码中，我们将要被移除的字段 <code>email</code> 重命名为了 <code>OBSOLETE_email</code>，并添加了注释提示不要使用该字段。通过这样的重命名，我们确保在新消息类型中不再使用原先的标识号（3），从而避免其他用户在未来无意中重新使用该标识号。<strong>对应到Java中，我们可以把它理解为“已弃用的属性”</strong></p>
<p>在这种情况下，通过更新消息类型并移除非 required 的字段，我们可以避免将来的潜在问题，并提供更好的可读性和可维护性。</p>
<blockquote>
<p>int32, uint32, int64, uint64,和bool是全部兼容的，这意味着可以将这些类型中的一个转换为另外一个，而不会破坏向前、 向后的兼容性。如果解析出来的数字与对应的类型不相符，那么结果就像在C++中对它进行了强制类型转换一样（例如，如果把一个64位数字当作int32来 读取，那么它就会被截断为32位的数字）。</p>
</blockquote>
<blockquote>
<p>sint32和sint64是互相兼容的，但是它们与其他整数类型不兼容。</p>
</blockquote>
<blockquote>
<p>string和bytes是兼容的——只要bytes是有效的UTF-8编码。</p>
</blockquote>
<blockquote>
<p>嵌套消息与bytes是兼容的——只要bytes包含该消息的一个编码过的版本。</p>
</blockquote>
<blockquote>
<p>fixed32与sfixed32是兼容的，fixed64与sfixed64是兼容的。</p>
</blockquote>
<blockquote>
<p>枚举类型与int32，uint32，int64和uint64相兼容（注意如果值不相兼容则会被截断），然而在客户端反序列化之后他们可能会有不同的处理方式，例如，未识别的proto3枚举类型会被保留在消息中，但是他的表示方式会依照语言而定。int类型的字段总会保留他们的。</p>
</blockquote>
<p>假设我们有一个旧版本的消息类型 <code>Person</code>，其中包含一个枚举类型的字段 <code>gender</code>：</p>
<p>旧版本代码示例：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line">  Gender gender = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">enum </span><span class="title class_">Gender</span> &#123;</span><br><span class="line">    UNKNOWN = <span class="number">0</span>;</span><br><span class="line">    MALE = <span class="number">1</span>;</span><br><span class="line">    FEMALE = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们要更新消息类型，将 <code>gender</code> 字段的类型从枚举类型改为 int32 类型。根据规范，在更新时需要注意以下几点：</p>
<ul>
<li><p>消息中的已存在的枚举值应该能够使用整型类型进行兼容处理。例如，如果枚举值在新的消息类型中使用了 int32 类型，并且其值在原枚举类型的取值范围内，那么解析时不会出现问题。</p>
</li>
<li><p>对于没有定义的枚举值，旧代码保留未识别的枚举值并将其作为整型类型存储在消息中。但是，它们的表示方式会因语言而异，因此客户端在反序列化后需要注意处理这些未识别值。</p>
</li>
</ul>
<p>更新后的新版本代码示例：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int32</span> gender = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述新版本的代码中，我们将 <code>gender</code> 字段的类型由枚举类型改为了 int32 类型。</p>
<p>通过这样的更新，在新消息类型中，整型类型可以与旧消息类型中的枚举类型兼容。已定义的枚举值可以正常解析，并且未定义的枚举值会以整型类型的形式保留在消息中，但是它们的具体表示方式可能因语言而异。</p>
<p>尽管如此，应该注意的是，客户端在反序列化后需要特别处理这些未识别的整型值，以避免出现意外行为。</p>
<h1 id="Any-类似Java的泛型或Object"><a href="#Any-类似Java的泛型或Object" class="headerlink" title="Any(类似Java的泛型或Object)"></a>Any(类似Java的泛型或Object)</h1><p>尽管存在一些类比，但请注意 Any 类型与泛型和 Object 类型之间的差异：</p>
<ul>
<li>Any 类型是一种特殊的消息类型，需要在 .proto 文件中导入 <code>google/protobuf/any.proto</code>，以便使用。</li>
<li>Any 类型通过序列化和反序列化的方式来存储和传递消息。它不仅存储了序列化后的字节，还包括一个 URL 用于解析消息的类型。</li>
<li>Any 类型需要根据 URL 去解析和处理相应的消息类型，而不是简单地将其视为 Object 类型。</li>
</ul>
<p>Any类型消息允许你在没有指定他们的.proto定义的情况下使用消息作为一个嵌套类型。一个Any类型包括一个可以被序列化bytes类型的任意消息，以及一个URL作为一个全局标识符和解析消息类型。为了使用Any类型，你需要导入import google&#x2F;protobuf&#x2F;any.proto</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/any.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ErrorStatus</span> &#123;</span><br><span class="line">  <span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">repeated</span> google.protobuf.Any details = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于给定的消息类型的默认类型URL是type.googleapis.com&#x2F;packagename.messagename。</p>
<p>不同语言的实现会支持动态库以线程安全的方式去帮助封装或者解封装Any值。例如在java中，Any类型会有特殊的pack()和unpack()访问器，在C++中会有PackFrom()和UnpackTo()方法。</p>
<p>目前，用于Any类型的动态库仍在开发之中<br>如果你已经很熟悉proto2语法，使用Any替换拓展</p>
<h1 id="Oneof"><a href="#Oneof" class="headerlink" title="Oneof"></a>Oneof</h1><p>如果你的消息中有很多可选字段，并且同时最多只会有一个字段被设置，为了节省内存，你可以使用 oneof 特性来增强这种行为。</p>
<p>oneof 字段类似于可选字段，但与可选字段不同的是，它们会共享同一块内存空间，最多只会有一个字段被设置。当设置其中一个字段时，会清除其他已设置的字段。你可以通过使用 <code>case()</code> 或 <code>WhichOneof()</code> 方法（具体取决于你使用的编程语言）来检查哪个 oneof 字段被设置。</p>
<h2 id="使用Oneof"><a href="#使用Oneof" class="headerlink" title="使用Oneof"></a>使用Oneof</h2><p>为了在.proto定义Oneof字段， 你需要在名字前面加上oneof关键字, 比如下面例子的test_oneof:</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SampleMessage</span> &#123;</span><br><span class="line">  <span class="keyword">oneof</span> test_oneof &#123;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">4</span>;</span><br><span class="line">    SubMessage sub_message = <span class="number">9</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后你可以增加oneof字段到 oneof 定义中. 你可以增加任意类型的字段, 但是不能使用repeated 关键字.</p>
<p>在产生的代码中, oneof字段拥有同样的 getters 和setters， 就像正常的可选字段一样. 也有一个特殊的方法来检查到底那个字段被设置. 你可以在相应的语言API指南中找到oneof API介绍.</p>
<h2 id="Oneof-特性"><a href="#Oneof-特性" class="headerlink" title="Oneof 特性"></a>Oneof 特性</h2><ul>
<li>设置oneof会自动清除其它oneof字段的值. 所以设置多次后，只有最后一次设置的字段有值.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SampleMessage message;</span><br><span class="line">message.<span class="built_in">set_name</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="built_in">CHECK</span>(message.<span class="built_in">has_name</span>());</span><br><span class="line">message.<span class="built_in">mutable_sub_message</span>();   <span class="comment">// Will clear name field.</span></span><br><span class="line"><span class="built_in">CHECK</span>(!message.<span class="built_in">has_name</span>());</span><br></pre></td></tr></table></figure>

<ul>
<li>如果解析器遇到同一个oneof中有多个成员，只有最会一个会被解析成消息。</li>
<li>oneof不支持repeated.</li>
<li>反射API对oneof 字段有效.</li>
<li>如果使用C++,需确保代码不会导致内存泄漏. 下面的代码会崩溃， 因为sub_message 已经通过set_name()删除了</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SampleMessage message;</span><br><span class="line">SubMessage* sub_message = message.<span class="built_in">mutable_sub_message</span>();</span><br><span class="line">message.<span class="built_in">set_name</span>(<span class="string">&quot;name&quot;</span>);      <span class="comment">// Will delete sub_message</span></span><br><span class="line">sub_message-&gt;set_...            <span class="comment">// Crashes here</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在C++中，如果你使用Swap()两个oneof消息，每个消息，两个消息将拥有对方的值，例如在下面的例子中，msg1会拥有sub_message并且msg2会有name。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SampleMessage msg1;</span><br><span class="line">msg1.<span class="built_in">set_name</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">SampleMessage msg2;</span><br><span class="line">msg2.<span class="built_in">mutable_sub_message</span>();</span><br><span class="line">msg1.<span class="built_in">swap</span>(&amp;msg2);</span><br><span class="line"><span class="built_in">CHECK</span>(msg1.<span class="built_in">has_sub_message</span>());</span><br><span class="line"><span class="built_in">CHECK</span>(msg2.<span class="built_in">has_name</span>());</span><br></pre></td></tr></table></figure>

<h2 id="向后兼容性问题"><a href="#向后兼容性问题" class="headerlink" title="向后兼容性问题"></a>向后兼容性问题</h2><p>当增加或者删除oneof字段时一定要小心. 如果检查oneof的值返回None&#x2F;NOT_SET, 它意味着oneof字段没有被赋值或者在一个不同的版本中赋值了。 你不会知道是哪种情况，因为没有办法判断如果未识别的字段是一个oneof字段。</p>
<p>Tage 重用问题：</p>
<ul>
<li>将字段移入或移除oneof：在消息被序列号或者解析后，你也许会失去一些信息（有些字段也许会被清除）</li>
<li>删除一个字段或者加入一个字段：在消息被序列号或者解析后，这也许会清除你现在设置的oneof字段</li>
<li>分离或者融合oneof：行为与移动常规字段相似。</li>
</ul>
<h1 id="映射（Maps）"><a href="#映射（Maps）" class="headerlink" title="映射（Maps）"></a>映射（Maps）</h1><p>如果你希望创建一个关联映射，protocol buffer提供了一种快捷的语法：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">map&lt;key_type, value_type&gt; map_field = N;</span><br></pre></td></tr></table></figure>

<p>其中key_type可以是任意Integer或者string类型（所以，除了floating和bytes的任意标量类型都是可以的）value_type可以是任意类型。</p>
<p>例如，如果你希望创建一个project的映射，每个Projecct使用一个string作为key，你可以像下面这样定义：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">string</span>, Project&gt; projects = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>Map的字段可以是repeated。</li>
<li>序列化后的顺序和map迭代器的顺序是不确定的，所以你不要期望以固定顺序处理Map</li>
<li>当为.proto文件产生生成文本格式的时候，map会按照key 的顺序排序，数值化的key会按照数值排序。</li>
<li>从序列化中解析或者融合时，如果有重复的key则后一个key不会被使用，当从文本格式中解析map时，如果存在重复的key。</li>
</ul>
<p>生成map的API现在对于所有proto3支持的语言都可用了，你可以从API指南找到更多信息。</p>
<h2 id="向后兼容性问题-1"><a href="#向后兼容性问题-1" class="headerlink" title="向后兼容性问题"></a>向后兼容性问题</h2><p>map语法序列化后等同于如下内容，因此即使是不支持map语法的protocol buffer实现也是可以处理你的数据的：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">MapFieldEntry</span> &#123;</span><br><span class="line">  key_type key = <span class="number">1</span>;</span><br><span class="line">  value_type value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">repeated</span> MapFieldEntry map_field = N;</span><br></pre></td></tr></table></figure>

<h1 id="包（Packages）"><a href="#包（Packages）" class="headerlink" title="包（Packages）"></a>包（Packages）</h1><p>当然可以为.proto文件新增一个可选的package声明符，用来防止不同的消息类型有命名冲突。如：</p>
<p>package foo.bar;<br>message Open { … }</p>
<p>在其他的消息格式定义中可以使用包名+消息名的方式来定义域的类型，如：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Foo</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">required</span> foo.bar.Open open = <span class="number">1</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包的声明符会根据使用语言的不同影响生成的代码。</p>
<ul>
<li>对于C++，产生的类会被包装在C++的命名空间中，如上例中的Open会被封装在 foo::bar空间中； - 对于Java，包声明符会变为java的一个包，除非在.proto文件中提供了一个明确有java_package；</li>
<li>对于 Python，这个包声明符是被忽略的，因为Python模块是按照其在文件系统中的位置进行组织的。</li>
<li>对于Go，包可以被用做Go包名称，除非你显式的提供一个option go_package在你的.proto文件中。</li>
<li>对于Ruby，生成的类可以被包装在内置的Ruby名称空间中，转换成Ruby所需的大小写样式 （首字母大写；如果第一个符号不是一个字母，则使用PB_前缀），例如Open会在Foo::Bar名称空间中。</li>
<li>对于javaNano包会使用Java包，除非你在你的文件中显式的提供一个option java_package。</li>
<li>对于C#包可以转换为PascalCase后作为名称空间，除非你在你的文件中显式的提供一个option csharp_namespace，例如，Open会在Foo.Bar名称空间中</li>
</ul>
<h2 id="包及名称的解析"><a href="#包及名称的解析" class="headerlink" title="包及名称的解析"></a>包及名称的解析</h2><p>Protocol buffer语言中类型名称的解析与C++是一致的：首先从最内部开始查找，依次向外进行，每个包会被看作是其父类包的内部类。当然对于 （foo.bar.Baz）这样以“.”分隔的意味着是从最外围开始的。</p>
<p>ProtocolBuffer编译器会解析.proto文件中定义的所有类型名。 对于不同语言的代码生成器会知道如何来指向每个具体的类型，即使它们使用了不同的规则。</p>
<h1 id="定义服务-service接口"><a href="#定义服务-service接口" class="headerlink" title="定义服务(service接口)"></a>定义服务(service接口)</h1><p>当然，具体的实现类要我们自己写</p>
<p>如果想要将消息类型用在RPC(远程方法调用)系统中，可以在.proto文件中定义一个RPC服务接口，protocol buffer编译器将会根据所选择的不同语言生成服务接口代码及存根。如，想要定义一个RPC服务并具有一个方法，该方法能够接收 SearchRequest并返回一个SearchResponse，此时可以在.proto文件中进行如下定义：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">service </span><span class="title class_">SearchService</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> Search (SearchRequest) <span class="keyword">returns</span> (SearchResponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最直观的使用protocol buffer的RPC系统是gRPC一个由谷歌开发的语言和平台中的开源的PRC系统，gRPC在使用protocl buffer时非常有效，如果使用特殊的protocol buffer插件可以直接为您从.proto文件中产生相关的RPC代码。</p>
<p>如果你不想使用gRPC，也可以使用protocol buffer用于自己的RPC实现，你可以从proto2语言指南中找到更多信息</p>
<p>还有一些第三方开发的PRC实现使用Protocol Buffer。参考第三方插件wiki查看这些实现的列表。</p>
<h1 id="JSON-映射"><a href="#JSON-映射" class="headerlink" title="JSON 映射"></a>JSON 映射</h1><p>Proto3 支持JSON的编码规范，使他更容易在不同系统之间共享数据，在下表中逐个描述类型。</p>
<p>如果JSON编码的数据丢失或者其本身就是null，这个数据会在解析成protocol buffer的时候被表示成默认值。如果一个字段在protocol buffer中表示为默认值，体会在转化成JSON的时候编码的时候忽略掉以节省空间。具体实现可以提供在JSON编码中可选的默认值。</p>
<table>
<thead>
<tr>
<th>proto3</th>
<th>JSON</th>
<th>JSON示例</th>
<th>注意</th>
</tr>
</thead>
<tbody><tr>
<td>message</td>
<td>object</td>
<td>{“fBar”: v, “g”: null, …}</td>
<td>产生JSON对象，消息字段名可以被映射成lowerCamelCase形式，并且成为JSON对象键，null被接受并成为对应字段的默认值</td>
</tr>
<tr>
<td>enum</td>
<td>string</td>
<td>“FOO_BAR”</td>
<td>枚举值的名字在proto文件中被指定</td>
</tr>
<tr>
<td>map</td>
<td>object</td>
<td>{“k”: v, …}</td>
<td>所有的键都被转换成string</td>
</tr>
<tr>
<td>repeated V</td>
<td>array</td>
<td>[v, …]</td>
<td>null被视为空列表</td>
</tr>
<tr>
<td>bool</td>
<td>true, false</td>
<td>true, false</td>
<td></td>
</tr>
<tr>
<td>string</td>
<td>string</td>
<td>“Hello World!”</td>
<td></td>
</tr>
<tr>
<td>bytes</td>
<td>base64 string</td>
<td>“YWJjMTIzIT8kKiYoKSctPUB+”</td>
<td></td>
</tr>
<tr>
<td>int32, fixed32, uint32</td>
<td>number</td>
<td>1, -10, 0</td>
<td>JSON值会是一个十进制数，数值型或者string类型都会接受</td>
</tr>
<tr>
<td>int64, fixed64, uint64</td>
<td>string</td>
<td>“1”, “-10”</td>
<td>JSON值会是一个十进制数，数值型或者string类型都会接受</td>
</tr>
<tr>
<td>float, double</td>
<td>number</td>
<td>1.1, -10.0, 0, “NaN”, “Infinity”</td>
<td>JSON值会是一个数字或者一个指定的字符串如”NaN”,”infinity”或者”-Infinity”，数值型或者字符串都是可接受的，指数符号也可以接受</td>
</tr>
<tr>
<td>Any</td>
<td>object</td>
<td>{“@type”: “url”, “f”: v, … }</td>
<td>如果一个Any保留一个特上述的JSON映射，则它会转换成一个如下形式：{“@type”: xxx, “value”: yyy}否则，该值会被转换成一个JSON对象，@type字段会被插入所指定的确定的值</td>
</tr>
<tr>
<td>Timestamp</td>
<td>string</td>
<td>“1972-01-01T10:00:20.021Z”</td>
<td>使用RFC 339，其中生成的输出将始终是Z-归一化啊的，并且使用0，3，6或者9位小数</td>
</tr>
<tr>
<td>Duration</td>
<td>string</td>
<td>“1.000340012s”, “1s”</td>
<td>生成的输出总是0，3，6或者9位小数，具体依赖于所需要的精度，接受所有可以转换为纳秒级的精度</td>
</tr>
<tr>
<td>Struct</td>
<td>object</td>
<td>{ … }</td>
<td>任意的JSON对象，见struct.proto</td>
</tr>
<tr>
<td>Wrapper types</td>
<td>various types</td>
<td>2, “2”, “foo”, true, “true”, null, 0, …</td>
<td>包装器在JSON中的表示方式类似于基本类型，但是允许nulll，并且在转换的过程中保留null</td>
</tr>
<tr>
<td>FieldMask</td>
<td>string</td>
<td>“f.fooBar,h”</td>
<td>见fieldmask.proto</td>
</tr>
<tr>
<td>ListValue</td>
<td>array</td>
<td>[foo, bar, …]</td>
<td></td>
</tr>
<tr>
<td>Value</td>
<td>value</td>
<td></td>
<td>任意JSON值</td>
</tr>
<tr>
<td>NullValue</td>
<td>null</td>
<td></td>
<td>JSON null</td>
</tr>
</tbody></table>
<h1 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h1><p>在定义.proto文件时能够标注一系列的options。Options并不改变整个文件声明的含义，但却能够影响特定环境下处理方式。完整的可用选项可以在google&#x2F;protobuf&#x2F;descriptor.proto找到。</p>
<p>一些选项是文件级别的，意味着它可以作用于最外范围，不包含在任何消息内部、enum或服务定义中。一些选项是消息级别的，意味着它可以用在消息定义的内部。当然有些选项可以作用在域、enum类型、enum值、服务类型及服务方法中。到目前为止，并没有一种有效的选项能作用于所有的类型。</p>
<p>如下就是一些常用的选择：</p>
<ul>
<li>java_package (文件选项) :这个选项表明生成java类所在的包。如果在.proto文件中没有明确的声明java_package，就采用默认的包名。当然了，默认方式产生的 java包名并不是最好的方式，按照应用名称倒序方式进行排序的。如果不需要产生java代码，则该选项将不起任何作用。如：</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">option</span> java_package = <span class="string">&quot;com.example.foo&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>java_outer_classname (文件选项): 该选项表明想要生成Java类的名称。如果在.proto文件中没有明确的java_outer_classname定义，生成的class名称将会根据.proto文件的名称采用驼峰式的命名方式进行生成。如（foo_bar.proto生成的java类名为FooBar.java）,如果不生成java代码，则该选项不起任何作用。如：</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">&quot;Ponycopter&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>optimize_for(文件选项): 可以被设置为 SPEED, CODE_SIZE,或者LITE_RUNTIME。这些值将通过如下的方式影响C++及java代码的生成： <ul>
<li>SPEED (default): protocol buffer编译器将通过在消息类型上执行序列化、语法分析及其他通用的操作。这种代码是最优的。</li>
<li>CODE_SIZE: protocol buffer编译器将会产生最少量的类，通过共享或基于反射的代码来实现序列化、语法分析及各种其它操作。采用该方式产生的代码将比SPEED要少得多， 但是操作要相对慢些。当然实现的类及其对外的API与SPEED模式都是一样的。这种方式经常用在一些包含大量的.proto文件而且并不盲目追求速度的 应用中。</li>
<li>LITE_RUNTIME: protocol buffer编译器依赖于运行时核心类库来生成代码（即采用libprotobuf-lite 替代libprotobuf）。这种核心类库由于忽略了一 些描述符及反射，要比全类库小得多。这种模式经常在移动手机平台应用多一些。编译器采用该模式产生的方法实现与SPEED模式不相上下，产生的类通过实现 MessageLite接口，但它仅仅是Messager接口的一个子集。</li>
</ul>
</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">option</span> optimize_for = CODE_SIZE;</span><br></pre></td></tr></table></figure>

<ul>
<li>cc_enable_arenas(文件选项):对于C++产生的代码启用<a href="https://developers.google.com/protocol-buffers/docs/reference/arenas?hl=zh-cn">arena allocation</a>。</li>
<li>objc_class_prefix(文件选项):设置Objective-C类的前缀，添加到所有Objective-C从此.proto文件产生的类和枚举类型。没有默认值，所使用的前缀应该是苹果推荐的3-5个大写字符，注意2个字节的前缀是苹果所保留的。</li>
<li>deprecated(字段选项):如果设置为true则表示该字段已经被废弃，并且不应该在新的代码中使用。在大多数语言中没有实际的意义。在java中，这回变成@Deprecated注释，在未来，其他语言的代码生成器也许会在字标识符中产生废弃注释，废弃注释会在编译器尝试使用该字段时发出警告。如果字段没有被使用你也不希望有新用户使用它，尝试使用保留语句替换字段声明。</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="type">int32</span> old_field = <span class="number">6</span> [deprecated=<span class="literal">true</span>];</span><br></pre></td></tr></table></figure>

<h2 id="自定义选项"><a href="#自定义选项" class="headerlink" title="自定义选项"></a>自定义选项</h2><p>ProtocolBuffers允许自定义并使用选项。该功能应该属于一个高级特性，对于大部分人是用不到的。如果你的确希望创建自己的选项，请参看<a href="https://developers.google.com/protocol-buffers/docs/proto?hl=zh-cn#customoptions">Proto2 Language Guide</a>。注意创建自定义选项使用了拓展，拓展只在proto3中可用。</p>
<h1 id="生成你的类"><a href="#生成你的类" class="headerlink" title="生成你的类"></a>生成你的类</h1><p>在pom.xml中：</p>
<ol>
<li>引入 <a href="https://mvnrepository.com/artifact/io.grpc/grpc-protobuf"><code>grpc-protobuf</code></a> 依赖，使用 Protobuf 作为序列化库。引入 <a href="https://mvnrepository.com/artifact/io.grpc/grpc-stub"><code>grpc-stub</code></a> 依赖，使用 gRPC Stub 作为客户端。</li>
<li>引入 <a href="https://mvnrepository.com/artifact/kr.motd.maven/os-maven-plugin"><code>os-maven-plugin</code></a> 插件，从 OS 系统中获取参数。因为需要通过它，从 OS 系统中获取 <code>os.detected.classifier</code> 参数，稍后使用到 <code>protobuf-maven-plugin</code> 插件和 OS 系统相关。</li>
<li>引入 <a href="https://mvnrepository.com/artifact/org.xolstice.maven.plugins/protobuf-maven-plugin"><code>protobuf-maven-plugin</code></a> 插件，实现通过 <code>proto</code> 目录下的 protobuf 文件，生成 Service 和 Message 类。</li>
</ol>
<p>然后，我们点击 IDEA 的「compile」按钮，编译该 API 项目，并同时执行 <code>protobuf-maven-plugin</code> 插件进行生成。</p>
<p>具体依赖可以参考<a href="https://github.com/OrionLi/spring-boot-demo/blob/master/demo-rpc-grpc/grpc-userservice-api/pom.xml">我的GitHub中使用gRPC的api模块demo</a></p>
]]></content>
      <categories>
        <category>语言指南</category>
      </categories>
      <tags>
        <tag>gRPC</tag>
        <tag>Protobuf3</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 备忘清单</title>
    <url>/blog/2023/07/06/Markdown%20%E5%A4%87%E5%BF%98%E6%B8%85%E5%8D%95/</url>
    <content><![CDATA[<blockquote>
<p>本文为转载</p>
<p>原出处：<a href="http://bbs.laoleng.vip/reference/docs/markdown.html">http://bbs.laoleng.vip/reference/docs/markdown.html</a></p>
<p>仓库地址：<a href="https://github.com/jaywcjlove/reference">https://github.com/jaywcjlove/reference</a></p>
</blockquote>
<p>这是 Markdown 语法的快速参考备忘单。</p>
<h1 id="标题-atx-风格"><a href="#标题-atx-风格" class="headerlink" title="标题 (atx 风格)"></a>标题 (atx 风格)</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># h1</span></span><br><span class="line"><span class="section">## h2</span></span><br><span class="line"><span class="section">### h3</span></span><br><span class="line"><span class="section">#### h4</span></span><br><span class="line"><span class="section">##### h5</span></span><br><span class="line"><span class="section">###### h6</span></span><br></pre></td></tr></table></figure>

<h1 id="块引用"><a href="#块引用" class="headerlink" title="块引用"></a>块引用</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 这是一个</span></span><br><span class="line"><span class="quote">&gt; 块引用</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; &gt; 嵌套</span></span><br><span class="line"><span class="quote">&gt; &gt; 块引用</span></span><br></pre></td></tr></table></figure>

<h1 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h1><!--rehype:wrap-class=row-span-3-->

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> Item 1</span><br><span class="line"><span class="bullet">*</span> Item 2</span><br><span class="line"><span class="bullet">    *</span> item 3a</span><br><span class="line"><span class="bullet">    *</span> item 3b</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> Item 1</span><br><span class="line"><span class="bullet">-</span> Item 2</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">+</span> Item 1</span><br><span class="line"><span class="bullet">+</span> Item 2</span><br></pre></td></tr></table></figure>

<p>或者<strong>任务</strong>列表</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> [ ] Checkbox off</span><br><span class="line"><span class="bullet">-</span> [x] Checkbox on</span><br></pre></td></tr></table></figure>

<h1 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> Item 1</span><br><span class="line"><span class="bullet">2.</span> Item 2</span><br><span class="line"><span class="code">    a. item 3a</span></span><br><span class="line"><span class="code">    b. item 3b</span></span><br></pre></td></tr></table></figure>

<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">link</span>](<span class="link">http://google.com</span>)</span><br><span class="line"></span><br><span class="line">[<span class="string">link</span>][<span class="symbol">google</span>]</span><br><span class="line">[<span class="symbol">google</span>]: <span class="link">http://google.com</span></span><br><span class="line"></span><br><span class="line"><span class="language-xml">&lt;http://google.com&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span>    <span class="emphasis">_斜体_</span>    <span class="strong">**粗体**</span>   <span class="strong">__粗体__</span></span><br><span class="line"></span><br><span class="line"><span class="code">`内联代码`</span>  ~~删除~~</span><br></pre></td></tr></table></figure>

<h1 id="水平线"><a href="#水平线" class="headerlink" title="水平线"></a>水平线</h1><!--rehype:wrap-class=row-span-2-->

<p>连字符</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure>

<p>星号</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure>

<p>下划线</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">__<span class="emphasis">_</span></span></span><br></pre></td></tr></table></figure>

<h1 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">在当前行的结尾加 2 个空格··</span><br><span class="line">这行就会新起一行\</span><br><span class="line">反斜杠也可以换行</span><br></pre></td></tr></table></figure>

<p>尾部添加两个空格，或者添加 <code>\</code> 反斜杠</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">```javascript</span></span><br><span class="line"><span class="code">console.log(&quot;This is a block code&quot;)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```markdown</span><br><span class="line">~~~css</span><br><span class="line">.button &#123; border: none; &#125;</span><br><span class="line">~~~</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">4 空格缩进做一个代码块</span><br></pre></td></tr></table></figure>

<h2 id="内联代码"><a href="#内联代码" class="headerlink" title="内联代码"></a>内联代码</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">`Inline code`</span> 周围有反引号</span><br></pre></td></tr></table></figure>

<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 左栏     | 中间栏   | 右栏  |</span><br><span class="line">| -------- | -------- | ----- |</span><br><span class="line">| 单元格 1 | 居中     | $1600 |</span><br><span class="line">| 单元格 2 | 单元格 3 | $12   |</span><br></pre></td></tr></table></figure>

<p>简单的风格</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">左栏     | 中间栏   | 右栏  </span><br><span class="line">-------- | -------- | -----</span><br><span class="line">单元格 1 | 居中     | $1600</span><br><span class="line">单元格 2 | 单元格 3 | $12 </span><br></pre></td></tr></table></figure>

<p>增加 <code>:</code> 改变文字对齐方式</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">左栏     |  中间栏  |   右栏 </span><br><span class="line">:------- | :------: | -----: </span><br><span class="line">左对齐   |   居中   | 右对齐</span><br></pre></td></tr></table></figure>

<p>Markdown 表格生成器：<a href="https://tableconvert.com/">tableconvert.com</a></p>
<h1 id="脚注-Footnotes"><a href="#脚注-Footnotes" class="headerlink" title="脚注 (Footnotes)"></a>脚注 (Footnotes)</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这是一个简单的脚注[^1]。</span><br><span class="line"></span><br><span class="line">一个脚注也可以有多行[^2]。</span><br><span class="line"></span><br><span class="line">你也可以使用文字，更贴合你的写作风格[^note]。</span><br><span class="line"></span><br><span class="line">[^1]：我的参考。</span><br><span class="line">[^2]：每个新行都应以 2 个空格为前缀。</span><br><span class="line">  这允许你有一个多行的脚注。</span><br><span class="line">[^note]：</span><br><span class="line"><span class="code">    推荐使用数字命名脚注，但文本更容易识别和链接。</span></span><br><span class="line"><span class="code">    脚注使用了不同的语法，使用 4 个空格作为新行。</span></span><br></pre></td></tr></table></figure>

<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><!--rehype:wrap-class=col-span-2-->

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">图片名称</span>](<span class="link">http://图片网址/images/logo.png</span>)</span><br><span class="line"></span><br><span class="line">![<span class="string">替代文字</span>](<span class="link">url</span>)</span><br></pre></td></tr></table></figure>

<h2 id="带链接的图片"><a href="#带链接的图片" class="headerlink" title="带链接的图片"></a>带链接的图片</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">![GitHub Logo</span>](<span class="link">/images/logo.png</span>)](<span class="link">https://github.com/</span>)</span><br><span class="line"></span><br><span class="line">[<span class="string">![替代文字</span>](<span class="link">image_url</span>)](<span class="link">link_url</span>)</span><br></pre></td></tr></table></figure>

<h2 id="参考风格"><a href="#参考风格" class="headerlink" title="参考风格"></a>参考风格</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">替代文字</span>][<span class="symbol">logo</span>]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">logo</span>]: <span class="link">/images/logo.png &quot;Logo Title&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="反斜杠转义"><a href="#反斜杠转义" class="headerlink" title="反斜杠转义"></a>反斜杠转义</h1><!--rehype:wrap-class=row-span-2-->

<table>
<thead>
<tr>
<th>字符</th>
<th>转义</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><pur>\</pur></td>
<td>\\</td>
<td>backslash 反斜杠</td>
</tr>
<tr>
<td><pur>`</pur></td>
<td>\`</td>
<td>backtick 反引号</td>
</tr>
<tr>
<td><pur>*</pur></td>
<td>\*</td>
<td>asterisk 星号</td>
</tr>
<tr>
<td><pur>_</pur></td>
<td>\_</td>
<td>underscore 下划线</td>
</tr>
<tr>
<td><pur>{}</pur></td>
<td>\{}</td>
<td>curly braces 花括号</td>
</tr>
<tr>
<td><pur>[]</pur></td>
<td>\[]</td>
<td>square brackets 方括号</td>
</tr>
<tr>
<td><pur>()</pur></td>
<td>\()</td>
<td>parentheses 圆括号</td>
</tr>
<tr>
<td><pur>#</pur></td>
<td>\#</td>
<td>hash mark 哈希标记</td>
</tr>
<tr>
<td><pur>+</pur></td>
<td>\+</td>
<td>plus sign 加号</td>
</tr>
<tr>
<td><pur>-</pur></td>
<td>\-</td>
<td>minus sign (hyphen) 减号(连字符)</td>
</tr>
<tr>
<td><pur>.</pur></td>
<td>\.</td>
<td>dot 点</td>
</tr>
<tr>
<td><pur>!</pur></td>
<td>\!</td>
<td>exclamation mark 感叹号</td>
</tr>
</tbody></table>
<h1 id="行内-HTML-元素"><a href="#行内-HTML-元素" class="headerlink" title="行内 HTML 元素"></a>行内 HTML 元素</h1><!--rehype:wrap-class=col-span-2-->

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">目前只支持部分段内 HTML 元素效果，包括 <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>, <span class="tag">&lt;<span class="name">b</span>&gt;</span>, <span class="tag">&lt;<span class="name">i</span>&gt;</span>, <span class="tag">&lt;<span class="name">em</span>&gt;</span>, <span class="tag">&lt;<span class="name">sup</span>&gt;</span>, <span class="tag">&lt;<span class="name">sub</span>&gt;</span>, <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="另见"><a href="#另见" class="headerlink" title="另见"></a>另见</h1><ul>
<li><a href="https://github.github.com/gfm/">GitHub 风格的 Markdown 规范</a> <em>(github.com)</em></li>
</ul>
]]></content>
      <categories>
        <category>语言指南</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>软件设计原则</title>
    <url>/blog/2023/07/06/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h1><p><strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，而是要实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级</p>
<p>想要达到这样的效果，我们需要使用接口和抽象类。</p>
<h2 id="示例：计算面积"><a href="#示例：计算面积" class="headerlink" title="示例：计算面积"></a>示例：计算面积</h2><p>假设有一个图形类（Shape）和两个具体的图形子类：矩形（Rectangle）和圆形（Circle）。现在，我们要为这些图形添加一个计算面积的功能，并且希望在未来能够扩展更多的图形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 图形类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> width;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">double</span> width, <span class="type">double</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width * height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆形类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算面积的工具类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AreaCalculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateTotalArea</span><span class="params">(Shape[] shapes)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">totalArea</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Shape shape : shapes) &#123;</span><br><span class="line">            totalArea += shape.calculateArea();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OCPDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Shape[] shapes = &#123;<span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">4</span>, <span class="number">5</span>), <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">3</span>)&#125;;</span><br><span class="line">        <span class="type">AreaCalculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AreaCalculator</span>();</span><br><span class="line">        <span class="type">double</span> <span class="variable">totalArea</span> <span class="operator">=</span> calculator.calculateTotalArea(shapes);</span><br><span class="line">        System.out.println(<span class="string">&quot;Total area: &quot;</span> + totalArea);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h1><p>任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p>
<p>里氏代换原则可以扩展代码的功能而不破坏原有结构，同时提高类型检查的准确性</p>
<h1 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h1><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p>
<h2 id="示例：电脑组装"><a href="#示例：电脑组装" class="headerlink" title="示例：电脑组装"></a>示例：电脑组装</h2><p>现要组装一台电脑，需要配件cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选择cpu有很多选择，如Intel，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船等。</p>
<p><strong>电脑（Computer）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HardDisk hardDisk;</span><br><span class="line">    <span class="keyword">private</span> Cpu cpu;</span><br><span class="line">    <span class="keyword">private</span> Memory memory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;计算机工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>硬盘接口（HardDisk）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HardDisk</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(String data)</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>希捷硬盘类（XiJieHardDisk）:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiJieHardDisk</span> <span class="keyword">implements</span> <span class="title class_">HardDisk</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用希捷硬盘存储数据&quot;</span> + data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用希捷希捷硬盘取数据&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;数据&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>西数硬盘类（XiShuHardDisk）:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiShuHardDisk</span> <span class="keyword">implements</span> <span class="title class_">HardDisk</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用西数硬盘存储数据&quot;</span> + data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用西数希捷硬盘取数据&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;数据&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CPU、内存各自的接口和实现类同理</p>
<p><strong>测试类（TestComputer）：</strong></p>
<p>测试类用来组装电脑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestComputer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        computer.setHardDisk(<span class="keyword">new</span> <span class="title class_">XiJieHardDisk</span>()); <span class="comment">// new XiShuHardDisk() 也能运行，可以替换，下面同理</span></span><br><span class="line">        computer.setCpu(<span class="keyword">new</span> <span class="title class_">IntelCpu</span>());</span><br><span class="line">        computer.setMemory(<span class="keyword">new</span> <span class="title class_">KingstonMemory</span>());</span><br><span class="line"></span><br><span class="line">        computer.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h1><p>客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。</p>
<h2 id="示例：安全门"><a href="#示例：安全门" class="headerlink" title="示例：安全门"></a>示例：安全门</h2><p>我们需要创建一个安全门，该安全门具有防火、防水、防盗的功能。可以将防火，防水，防盗功能提取成一个接口，形成一套规范。</p>
<p>现在如果我们还需要再创建一个只具有防盗、防水功能，那创建起来就相当方便了</p>
<p><strong>防盗接口（AntiTheft）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AntiTheft</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>防火接口（Fireproof）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Fireproof</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fireproof</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>防水接口（Waterproof）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Waterproof</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">waterproof</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SafetyDoor（类）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafetyDoor</span> <span class="keyword">implements</span> <span class="title class_">AntiTheft</span>,Fireproof,Waterproof &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防盗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fireproof</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防火&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waterproof</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防水&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>LiteSafetyDoor（类）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiteSafetyDoor</span> <span class="keyword">implements</span> <span class="title class_">AntiTheft</span>,Fireproof &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防盗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fireproof</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防火&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h1><p>迪米特法则又叫最少知识原则。</p>
<p>只和你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。</p>
<p>其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p>
<p>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p>
<h2 id="示例：明星与经纪人"><a href="#示例：明星与经纪人" class="headerlink" title="示例：明星与经纪人"></a>示例：明星与经纪人</h2><p>明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。</p>
<p><strong>明星类（Star）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Star</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>粉丝类（Fans）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fans</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>媒体公司类（Company）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>经纪人类（Agent）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Agent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Star star;</span><br><span class="line">    <span class="keyword">private</span> Fans fans;</span><br><span class="line">    <span class="keyword">private</span> Company company;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meeting</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(fans.getName() + <span class="string">&quot;与明星&quot;</span> + star.getName() + <span class="string">&quot;见面了。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">business</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(company.getName() + <span class="string">&quot;与明星&quot;</span> + star.getName() + <span class="string">&quot;洽谈业务。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h1><p>合成复用原则是指：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p>
<p>通常类的复用分为继承复用和合成复用两种。</p>
<p>继承复用虽然有简单和易实现的优点，但它也存在以下缺点：</p>
<ol>
<li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li>
<li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li>
<li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li>
</ol>
<p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：</p>
<ol>
<li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li>
<li>对象间的耦合度低。可以在类的成员位置声明抽象。</li>
<li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li>
</ol>
<h2 id="示例：汽车颜色和动力源"><a href="#示例：汽车颜色和动力源" class="headerlink" title="示例：汽车颜色和动力源"></a>示例：汽车颜色和动力源</h2><p>汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。</p>
<p>当使用继承复用时，我们可能会先让电车和油车继承抽象父类Car，然后电车油车各自再细分子类红电车、蓝电车、黑油车……继承复用会产生很多子类</p>
<p>但如果我们将继承复用改为聚合复用就会简单很多：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口或类定义动力源</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PowerSource</span> &#123;</span><br><span class="line">    <span class="comment">// 声明动力源相关的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口或类定义颜色</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="comment">// 声明颜色相关的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PowerSource powerSource;</span><br><span class="line">    <span class="keyword">private</span> Color color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他属性和方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(PowerSource powerSource, Color color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.powerSource = powerSource;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PowerSource</span> <span class="variable">gasolinePower</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GasolinePower</span>();</span><br><span class="line">        <span class="type">Color</span> <span class="variable">whiteColor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WhiteColor</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Car</span> <span class="variable">car1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(gasolinePower, whiteColor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有新的动力源或者新的颜色，只需要定义新的类并组合即可</span></span><br><span class="line">        <span class="type">PowerSource</span> <span class="variable">electricPower</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ElectricPower</span>();</span><br><span class="line">        <span class="type">Color</span> <span class="variable">redColor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedColor</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Car</span> <span class="variable">car2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(electricPower, redColor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他操作和逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>代码美学</category>
      </categories>
      <tags>
        <tag>软件设计原则</tag>
      </tags>
  </entry>
</search>
