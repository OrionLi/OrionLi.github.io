<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Protobuf3 语言指南 | OrionLi's Blog</title><meta name="author" content="OrionLi"><meta name="copyright" content="OrionLi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Protocol Buffers比XML更快、更小，广泛用于Google内部结构化数据存储和RPC系统基础，几乎全面用于跨服务器通信。它类似于Apache Thrift和Ion等协议，提供gRPC作为RPC协议栈给上层服务使用">
<meta property="og:type" content="article">
<meta property="og:title" content="Protobuf3 语言指南">
<meta property="og:url" content="https://orionli.gitee.io/blog/2023/06/21/protobuf3-guide/index.html">
<meta property="og:site_name" content="OrionLi&#39;s Blog">
<meta property="og:description" content="Protocol Buffers比XML更快、更小，广泛用于Google内部结构化数据存储和RPC系统基础，几乎全面用于跨服务器通信。它类似于Apache Thrift和Ion等协议，提供gRPC作为RPC协议栈给上层服务使用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://avatars.githubusercontent.com/OrionLi">
<meta property="article:published_time" content="2023-06-21T11:57:00.000Z">
<meta property="article:modified_time" content="2023-06-22T08:02:00.000Z">
<meta property="article:author" content="OrionLi">
<meta property="article:tag" content="gRPC">
<meta property="article:tag" content="Protobuf3">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://avatars.githubusercontent.com/OrionLi"><link rel="shortcut icon" href="/blog/img/favicon.png"><link rel="canonical" href="https://orionli.gitee.io/blog/2023/06/21/protobuf3-guide/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/blog/',
  algolia: undefined,
  localSearch: {"path":"/blog/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: false,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Protobuf3 语言指南',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-22 16:02:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 7 || hour >= 20
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://avatars.githubusercontent.com/OrionLi" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/blog/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/blog/" title="OrionLi's Blog"><span class="site-name">OrionLi's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/blog/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Protobuf3 语言指南</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-21T11:57:00.000Z" title="发表于 2023-06-21 19:57:00">2023-06-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-22T08:02:00.000Z" title="更新于 2023-06-22 16:02:00">2023-06-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blog/categories/%E8%AF%AD%E8%A8%80%E6%8C%87%E5%8D%97/">语言指南</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Protobuf3 语言指南"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><blockquote>
<p>英文文档：<a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/proto3?hl=zh-cn#generating">Language Guide(proto3)</a></p>
<p>汉化文档参考：<a target="_blank" rel="noopener" href="https://github.com/lixiangyun/protobuf_doc_ZH_CN">https://github.com/lixiangyun/protobuf_doc_ZH_CN</a></p>
<p>本文基于汉化文档魔改，用一些简单的代码示例替代冗长的表述，降低学习protobuf3的时间成本</p>
</blockquote>
<h1 id="为什么使用protobuf"><a href="#为什么使用protobuf" class="headerlink" title="为什么使用protobuf"></a>为什么使用protobuf</h1><p>新人在使用gRPC的时候，常常会有以下疑问</p>
<p>Q: 欸？我直接写Request和Response类不好吗，为啥要用protobuf定义消息类型并编译</p>
<p>A: 使用.proto文件定义消息结构，然后通过protobuf编译器生成对应的Java类或其他编程语言的类，是为了方便不同编程语言之间的数据传输和解析。</p>
<p><strong>protobuf所采用的二进制格式非常紧凑，而且具有高效的序列化和反序列化性能。因此，可以将使用不同编程语言开发的应用程序之间的数据传输格式标准化，从而实现跨语言的数据交换。</strong></p>
<p>此外，使用生成的Java类可以更方便地操作protobuf消息对象及其中的字段。protobuf编译器生成的Java类包含了许多有用的方法，如setter和getter方法，以及对protobuf消息对象的序列化和反序列化方法等，这些方法和操作简单方便，可以提高开发效率。</p>
<p>因此，通过protobuf编译器生成Java类或其他类，可以将消息结构定义与底层编码和解码逻辑分离，使得代码更加清晰、易读和易维护，同时也方便了跨语言数据传输。</p>
<p><strong>简单来说，在proto文件定义完编译生成的类只是方便对应语言的开发者开发服务的，消息传输还是用的protobuf，就像广东的内部交流可能说粤语，重庆的内部交流可能说重庆话，但当重庆人要和广东人交流，那毫无疑问还是用统一标准的普通话好</strong></p>
<h1 id="定义一个消息类型"><a href="#定义一个消息类型" class="headerlink" title="定义一个消息类型"></a>定义一个消息类型</h1><p>我们上面讲到：<strong>在生成的Java代码中，每个消息类型对应一个Java类，其中每个字段都有对应的getter和setter方法。同时，Java类还提供了对应的构造函数、toString方法等，方便开发者快速处理消息。</strong></p>
<p>先来看一个非常简单的例子。假设你想定义一个“搜索请求”的消息格式，每一个请求含有一个查询字符串、你感兴趣的查询结果所在的页数，以及每一页多少条查询结果。可以采用如下的方式来定义消息类型的.proto文件了：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">SearchRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int32</span> result_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>文件的第一行指定了你正在使用proto3语法：如果你没有指定这个，编译器会使用proto2。这个指定语法行必须是文件的非空非注释的第一个行。</li>
<li><code>SearchRequest</code>消息格式有3个字段，在消息中承载的数据分别对应于每一个字段。其中每个字段都有一个名字和一种类型。</li>
</ul>
<h2 id="指定字段类型"><a href="#指定字段类型" class="headerlink" title="指定字段类型"></a>指定字段类型</h2><p>在上面的例子中，所有字段都是标量类型：两个整型（<code>page_number</code>和<code>result_per_page</code>），一个string类型（<code>query</code>）。当然，你也可以为字段指定其他的合成类型，包括枚举（enumerations）或其他消息类型。</p>
<h2 id="分配标识号"><a href="#分配标识号" class="headerlink" title="分配标识号"></a>分配标识号</h2><p>正如你所见，在消息定义中，每个字段都有唯一的一个数字标识符。这些标识符是用来在消息的二进制格式中识别各个字段的，一旦开始使用就不能够再改变。注：[1,15]之内的标识号在编码的时候会占用一个字节。[16,2047]之内的标识号则占用2个字节。所以应该为那些频繁出现的消息元素保留 [1,15]之内的标识号。切记：要为将来有可能添加的、频繁出现的标识号预留一些标识号。</p>
<p>最小的标识号可以从1开始，最大到2^29 - 1, or 536,870,911。不可以使用其中的[19000－19999]（ (从FieldDescriptor::kFirstReservedNumber 到 FieldDescriptor::kLastReservedNumber)）的标识号， Protobuf协议实现中对这些进行了预留。如果非要在.proto文件中使用这些预留标识号，编译时就会报警。同样你也不能使用早期保留的标识号。</p>
<h2 id="指定字段规则"><a href="#指定字段规则" class="headerlink" title="指定字段规则"></a>指定字段规则</h2><blockquote>
<p>所指定的消息字段修饰符必须是如下之一：</p>
<ul>
<li><code>singular</code>(默认)：一个格式良好的消息应该有0个或者1个这种字段（但是不能超过1个）</li>
<li><code>repeated</code>：在一个格式良好的消息中，这种字段可以重复任意多次（包括0次）。重复的值的顺序会被保留。</li>
</ul>
<p>在proto3中，repeated的标量域默认情况下使用packed。</p>
</blockquote>
<p><code>repeated</code>字段在Protocol Buffers中对应了Java中的<code>List</code>类型。它允许在消息中存储多个相同类型的值，并以列表形式进行操作。</p>
<p>当使用Protocol Buffers生成的Java类时，<code>repeated</code>字段会被映射为一个<code>List</code>类型的属性。您可以通过调用该属性的方法来添加、获取、修改和删除其中的元素。</p>
<p>例如，在示例代码中的<code>UserList</code>消息类型中，<code>repeated User users</code>字段会被映射为一个<code>List&lt;User&gt;</code>类型的属性。您可以使用<code>getUsersList()</code>方法获取用户列表，然后使用<code>add()</code>方法添加新的用户，或者使用下标索引对特定位置的用户进行读取或写入操作。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">UserList</span> &#123;</span><br><span class="line">  <span class="keyword">repeated</span> User users = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以假设生成的Java代码包名为<code>com.example.demo</code>，生成的类为<code>User</code>和<code>UserList</code>。</p>
<p>下面是一个简单的使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.demo.UserList;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理用户创建逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserList <span class="title function_">getUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟从数据库中获取用户列表</span></span><br><span class="line">        List&lt;User&gt; userList = Arrays.asList(</span><br><span class="line">                User.newBuilder().setName(<span class="string">&quot;张三&quot;</span>).setAge(<span class="number">18</span>).build(),</span><br><span class="line">                User.newBuilder().setName(<span class="string">&quot;李四&quot;</span>).setAge(<span class="number">20</span>).build()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建UserList对象，并设置用户列表</span></span><br><span class="line">        <span class="type">UserList</span> <span class="variable">userListObj</span> <span class="operator">=</span> UserList.newBuilder().addAllUsers(userList).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userListObj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们通过<code>@RequestBody</code>注解接收请求体中的User对象，并执行相应的业务逻辑。在返回用户列表时，我们首先模拟获取用户列表的过程，然后使用<code>UserList</code>对象来封装用户列表，并将其返回给客户端。</p>
<h2 id="添加更多消息类型"><a href="#添加更多消息类型" class="headerlink" title="添加更多消息类型"></a>添加更多消息类型</h2><p>在一个.proto文件中可以定义多个消息类型。在定义多个相关的消息的时候，这一点特别有用——例如，如果想定义与SearchResponse消息类型对应的回复消息格式的话，你可以将它添加到相同的.proto文件中，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int32</span> result_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">SearchResponse</span> &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加注释"><a href="#添加注释" class="headerlink" title="添加注释"></a>添加注释</h2><p>向.proto文件添加注释，可以使用C&#x2F;C++&#x2F;java风格的双斜杠（&#x2F;&#x2F;） 语法格式，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> page_number = <span class="number">2</span>;  <span class="comment">// Which page number do we want?</span></span><br><span class="line">  <span class="type">int32</span> result_per_page = <span class="number">3</span>;  <span class="comment">// Number of results to return per page.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="保留标识符（Reserved）"><a href="#保留标识符（Reserved）" class="headerlink" title="保留标识符（Reserved）"></a>保留标识符（Reserved）</h2><p>简单来说，这个就是用来占位的，比方说：</p>
<ul>
<li>我先把3, 4标识符先占了</li>
<li><code>age</code>的字段我也占了</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">  reserved <span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那后面的人就不能用你占了的这些字段和标识符了。现在如果我想更新<code>Person</code>这个消息类型，把3号位给<code>age</code>只需要</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">3</span>;</span><br><span class="line">  reserved <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：不要在同一行reserved声明中同时声明域名字和标识号</p>
<h2 id="从-proto文件生成了什么？"><a href="#从-proto文件生成了什么？" class="headerlink" title="从.proto文件生成了什么？"></a>从.proto文件生成了什么？</h2><p>当用protocol buffer编译器来运行.proto文件时，编译器将生成所选择语言的代码，这些代码可以操作在.proto文件中定义的消息类型，包括获取、设置字段值，将消息序列化到一个输出流中，以及从一个输入流中解析消息。</p>
<ul>
<li>对C++来说，编译器会为每个.proto文件生成一个.h文件和一个.cc文件，.proto文件中的每一个消息有一个对应的类。</li>
<li>对Java来说，编译器为每一个消息类型生成了一个.java文件，以及一个特殊的Builder类（该类是用来创建消息类接口的）。</li>
<li>对Python来说，有点不太一样——Python编译器为.proto文件中的每个消息类型生成一个含有静态描述符的模块，，该模块与一个元类（metaclass）在运行时（runtime）被用来创建所需的Python数据访问类。</li>
<li>对go来说，编译器会位每个消息类型生成了一个.pd.go文件。</li>
<li>对于Ruby来说，编译器会为每个消息类型生成了一个.rb文件。</li>
<li>javaNano来说，编译器输出类似域java但是没有Builder类</li>
<li>对于Objective-C来说，编译器会为每个消息类型生成了一个pbobjc.h文件和pbobjcm文件，.proto文件中的每一个消息有一个对应的类。</li>
<li>对于C#来说，编译器会为每个消息类型生成了一个.cs文件，.proto文件中的每一个消息有一个对应的类。</li>
</ul>
<p>你可以从如下的文档链接中获取每种语言更多API(proto3版本的内容很快就公布)。<a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/reference/overview?hl=zh-cn">API Reference</a></p>
<h1 id="标量数值类型"><a href="#标量数值类型" class="headerlink" title="标量数值类型"></a>标量数值类型</h1><p>一个标量消息字段可以含有一个如下的类型——该表格展示了定义于.proto文件中的类型，以及与之对应的、在自动生成的访问类中定义的类型：</p>
<table>
<thead>
<tr>
<th>.proto Type</th>
<th>Notes</th>
<th>C++ Type</th>
<th>Java Type</th>
<th>Python Type[2]</th>
<th>Go Type</th>
<th>Ruby Type</th>
<th>C# Type</th>
<th>PHP Type</th>
</tr>
</thead>
<tbody><tr>
<td>double</td>
<td></td>
<td>double</td>
<td>double</td>
<td>float</td>
<td>float64</td>
<td>Float</td>
<td>double</td>
<td>float</td>
</tr>
<tr>
<td>float</td>
<td></td>
<td>float</td>
<td>float</td>
<td>float</td>
<td>float32</td>
<td>Float</td>
<td>float</td>
<td>float</td>
</tr>
<tr>
<td>int32</td>
<td>使用变长编码，对于负值的效率很低，如果你的域有可能有负值，请使用sint64替代</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>int32</td>
<td>Fixnum 或者 Bignum（根据需要）</td>
<td>int</td>
<td>integer</td>
</tr>
<tr>
<td>uint32</td>
<td>使用变长编码</td>
<td>uint32</td>
<td>int</td>
<td>int&#x2F;long</td>
<td>uint32</td>
<td>Fixnum 或者 Bignum（根据需要）</td>
<td>uint</td>
<td>integer</td>
</tr>
<tr>
<td>uint64</td>
<td>使用变长编码</td>
<td>uint64</td>
<td>long</td>
<td>int&#x2F;long</td>
<td>uint64</td>
<td>Bignum</td>
<td>ulong</td>
<td>integer&#x2F;string</td>
</tr>
<tr>
<td>sint32</td>
<td>使用变长编码，这些编码在负值时比int32高效的多</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>int32</td>
<td>Fixnum 或者 Bignum（根据需要）</td>
<td>int</td>
<td>integer</td>
</tr>
<tr>
<td>sint64</td>
<td>使用变长编码，有符号的整型值。编码时比通常的int64高效。</td>
<td>int64</td>
<td>long</td>
<td>int&#x2F;long</td>
<td>int64</td>
<td>Bignum</td>
<td>long</td>
<td>integer&#x2F;string</td>
</tr>
<tr>
<td>fixed32</td>
<td>总是4个字节，如果数值总是比总是比228大的话，这个类型会比uint32高效。</td>
<td>uint32</td>
<td>int</td>
<td>int</td>
<td>uint32</td>
<td>Fixnum 或者 Bignum（根据需要）</td>
<td>uint</td>
<td>integer</td>
</tr>
<tr>
<td>fixed64</td>
<td>总是8个字节，如果数值总是比总是比256大的话，这个类型会比uint64高效。</td>
<td>uint64</td>
<td>long</td>
<td>int&#x2F;long</td>
<td>uint64</td>
<td>Bignum</td>
<td>ulong</td>
<td>integer&#x2F;string</td>
</tr>
<tr>
<td>sfixed32</td>
<td>总是4个字节</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>int32</td>
<td>Fixnum 或者 Bignum（根据需要）</td>
<td>int</td>
<td>integer</td>
</tr>
<tr>
<td>sfixed64</td>
<td>总是8个字节</td>
<td>int64</td>
<td>long</td>
<td>int&#x2F;long</td>
<td>int64</td>
<td>Bignum</td>
<td>long</td>
<td>integer&#x2F;string</td>
</tr>
<tr>
<td>bool</td>
<td></td>
<td>bool</td>
<td>boolean</td>
<td>bool</td>
<td>bool</td>
<td>TrueClass&#x2F;FalseClass</td>
<td>bool</td>
<td>boolean</td>
</tr>
<tr>
<td>string</td>
<td>一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本。</td>
<td>string</td>
<td>String</td>
<td>str&#x2F;unicode</td>
<td>string</td>
<td>String (UTF-8)</td>
<td>string</td>
<td>string</td>
</tr>
<tr>
<td>bytes</td>
<td>可能包含任意顺序的字节数据。</td>
<td>string</td>
<td>ByteString</td>
<td>str</td>
<td>[]byte</td>
<td>String (ASCII-8BIT)</td>
<td>ByteString</td>
<td>string</td>
</tr>
</tbody></table>
<h1 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h1><p>当一个消息被解析的时候，如果被编码的信息不包含一个特定的singular元素，被解析的对象锁对应的域被设置位一个默认值，对于不同类型指定如下：</p>
<ul>
<li>对于strings，默认是一个空string</li>
<li>对于bytes，默认是一个空的bytes</li>
<li>对于bools，默认是false</li>
<li>对于数值类型，默认是0</li>
<li>对于枚举，默认是第一个定义的枚举值，必须为0;</li>
<li>对于消息类型（message），域没有被设置，确切的消息是根据语言确定的，详见<a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/reference/overview?hl=zh-cn">generated code guide</a>。</li>
</ul>
<p>对于可重复域的默认值是空（通常情况下是对应语言中空列表）。</p>
<p>注：对于标量消息域，一旦消息被解析，就无法判断域释放被设置为默认值（例如，例如boolean值是否被设置为false）还是根本没有被设置。你应该在定义你的消息类型时非常注意。例如，比如你不应该定义boolean的默认值false作为任何行为的触发方式。也应该注意如果一个标量消息域被设置为标志位，这个值不应该被序列化传输。</p>
<p>查看<a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/reference/overview?hl=zh-cn">generated code guide</a>选择你的语言的默认值的工作细节。</p>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>当需要定义一个消息类型的时候，可能想为一个字段指定某“预定义值序列”中的一个值。例如，假设要为每一个SearchRequest消息添加一个 corpus字段，而corpus的值可能是UNIVERSAL，WEB，IMAGES，LOCAL，NEWS，PRODUCTS或VIDEO中的一个。 其实可以很容易地实现这一点：通过向消息定义中添加一个枚举（enum）并且为每个可能的值定义一个常量就可以了。</p>
<p>在下面的例子中，在消息格式中添加了一个叫做Corpus的枚举类型——它含有所有可能的值 ——以及一个类型为Corpus的字段：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int32</span> result_per_page = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">enum </span><span class="title class_">Corpus</span> &#123;</span><br><span class="line">    UNIVERSAL = <span class="number">0</span>;</span><br><span class="line">    WEB = <span class="number">1</span>;</span><br><span class="line">    IMAGES = <span class="number">2</span>;</span><br><span class="line">    LOCAL = <span class="number">3</span>;</span><br><span class="line">    NEWS = <span class="number">4</span>;</span><br><span class="line">    PRODUCTS = <span class="number">5</span>;</span><br><span class="line">    VIDEO = <span class="number">6</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Corpus corpus = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如你所见，Corpus枚举的第一个常量映射为0：每个枚举类型必须将其第一个类型映射为0，这是因为：</p>
<ul>
<li>必须有有一个0值，我们可以用这个0值作为默认值。</li>
<li>这个零值必须为第一个元素，为了兼容proto2语义，枚举类的第一个值总是默认值。</li>
</ul>
<p>你可以通过将不同的枚举常量指定为相同的值。如果这样做你需要将<code>allow_alias</code>设定为true，否则编译器会在相同值地方产生一个错误信息。</p>
<p>比如对于下面的代码，编译铁定出错，因为<code>STARTED</code> 和 <code>RUNNING</code> 都被赋予了相同的值 1：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum </span><span class="title class_">EnumNotAllowingAlias</span> &#123;</span><br><span class="line">  UNKNOWN = <span class="number">0</span>;</span><br><span class="line">  STARTED = <span class="number">1</span>;</span><br><span class="line">  RUNNING = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但如果加上<code>allow_alias</code>，这意味着你可以使用 <code>STARTED</code> 或 <code>RUNNING</code> 来表示同一个概念</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum </span><span class="title class_">EnumAllowingAlias</span> &#123;</span><br><span class="line">  <span class="keyword">option</span> allow_alias = <span class="literal">true</span>;</span><br><span class="line">  UNKNOWN = <span class="number">0</span>;</span><br><span class="line">  STARTED = <span class="number">1</span>;</span><br><span class="line">  RUNNING = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举常量必须在32位整型值的范围内。因为enum值是使用可变编码方式的，对负数不够高效，因此不推荐在enum中使用负数。如上例所示，可以在 一个消息定义的内部或外部定义枚举——这些枚举可以在.proto文件中的任何消息定义里重用。当然也可以在一个消息中声明一个枚举类型，而在另一个不同 的消息中使用它——采用MessageType.EnumType的语法格式。</p>
<p>当对一个使用了枚举的.proto文件运行protocol buffer编译器的时候，生成的代码中将有一个对应的enum（对Java或C++来说），或者一个特殊的EnumDescriptor类（对 Python来说），它被用来在运行时生成的类中创建一系列的整型值符号常量（symbolic constants）。</p>
<p>在反序列化的过程中，无法识别的枚举值会被保存在消息中，虽然这种表示方式需要依据所使用语言而定。在那些支持开放枚举类型超出指定范围之外的语言中（例如C++和Go），为识别的值会被表示成所支持的整型。在使用封闭枚举类型的语言中（Java），使用枚举中的一个类型来表示未识别的值，并且可以使用所支持整型来访问。在其他情况下，如果解析的消息被序列号，未识别的值将保持原样。</p>
<p>关于如何在你的应用程序的消息中使用枚举的更多信息，请查看所选择的语言<a target="_blank" rel="noopener" href="http://code.google.com/intl/zh-CN/apis/protocolbuffers/docs/reference/overview.html%E3%80%82">generated code guide</a></p>
<h1 id="使用其他消息类型-对应Java的嵌套"><a href="#使用其他消息类型-对应Java的嵌套" class="headerlink" title="使用其他消息类型(对应Java的嵌套)"></a>使用其他消息类型(对应Java的嵌套)</h1><p>你可以将其他消息类型用作字段类型。例如，假设在每一个SearchResponse消息中包含Result消息，此时可以在相同的.proto文件中定义一个Result消息类型，然后在SearchResponse消息中指定一个Result类型的字段，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchResponse</span> &#123;</span><br><span class="line">  <span class="keyword">repeated</span> Result results = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Result</span> &#123;</span><br><span class="line">  <span class="type">string</span> url = <span class="number">1</span>;</span><br><span class="line">  <span class="type">string</span> title = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="type">string</span> snippets = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="导入定义"><a href="#导入定义" class="headerlink" title="导入定义"></a>导入定义</h2><p>在上面的例子中，Result消息类型与SearchResponse是定义在同一文件中的。如果想要使用的消息类型已经在其他.proto文件中已经定义过了呢？<br>你可以通过导入（importing）其他.proto文件中的定义来使用它们。要导入其他.proto文件的定义，你需要在你的文件中添加一个导入声明，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;myproject/other_protos.proto&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>默认情况下你只能使用直接导入的.proto文件中的定义. 然而， 有时候你需要移动一个.proto文件到一个新的位置， 可以不直接移动.proto文件， 只需放入一个伪 .proto 文件在老的位置， 然后使用import public转向新的位置。import public 依赖性会通过任意导入包含import public声明的proto文件传递。例如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是新的proto</span></span><br><span class="line"><span class="comment">// All definitions are moved here</span></span><br></pre></td></tr></table></figure>

<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是旧的proto</span></span><br><span class="line"><span class="comment">// 这是所有客户端正在导入的包</span></span><br><span class="line"><span class="keyword">import</span> public <span class="string">&quot;new.proto&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;other.proto&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端proto</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;old.proto&quot;</span>;</span><br><span class="line"><span class="comment">// 现在你可以使用新久两种包的proto定义了。</span></span><br></pre></td></tr></table></figure>

<p>通过在编译器命令行参数中使用-I&#x2F;–proto_pathprotocal 编译器会在指定目录搜索要导入的文件。如果没有给出标志，编译器会搜索编译命令被调用的目录。通常你只要指定proto_path标志为你的工程根目录就好。并且指定好导入的正确名称就好。</p>
<h2 id="使用proto2消息类型"><a href="#使用proto2消息类型" class="headerlink" title="使用proto2消息类型"></a>使用proto2消息类型</h2><p>在你的proto3消息中导入proto2的消息类型也是可以的，反之亦然，然后proto2枚举不可以直接在proto3的标识符中使用（如果仅仅在proto2消息中使用是可以的）。</p>
<h1 id="嵌套类型-对应Java的内部类"><a href="#嵌套类型-对应Java的内部类" class="headerlink" title="嵌套类型(对应Java的内部类)"></a>嵌套类型(对应Java的内部类)</h1><p>你可以在其他消息类型中定义、使用消息类型，在下面的例子中，Result消息就定义在SearchResponse消息内，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchResponse</span> &#123;</span><br><span class="line">  <span class="keyword">message </span><span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="type">string</span> url = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> title = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">string</span> snippets = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">repeated</span> Result results = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你想在它的父消息类型的外部重用这个消息类型，你需要以Parent.Type的形式使用它，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SomeOtherMessage</span> &#123;</span><br><span class="line">  SearchResponse.Result result = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，你也可以将消息嵌套任意多层，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Outer</span> &#123;                  <span class="comment">// Level 0</span></span><br><span class="line">  <span class="keyword">message </span><span class="title class_">MiddleAA</span> &#123;  <span class="comment">// Level 1</span></span><br><span class="line">    <span class="keyword">message </span><span class="title class_">Inner</span> &#123;   <span class="comment">// Level 2</span></span><br><span class="line">      <span class="type">int64</span> ival = <span class="number">1</span>;</span><br><span class="line">      <span class="type">bool</span>  booly = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">message </span><span class="title class_">MiddleBB</span> &#123;  <span class="comment">// Level 1</span></span><br><span class="line">    <span class="keyword">message </span><span class="title class_">Inner</span> &#123;   <span class="comment">// Level 2</span></span><br><span class="line">      <span class="type">int32</span> ival = <span class="number">1</span>;</span><br><span class="line">      <span class="type">bool</span>  booly = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="更新一个消息类型"><a href="#更新一个消息类型" class="headerlink" title="更新一个消息类型"></a>更新一个消息类型</h1><p>如果一个已有的消息格式已无法满足新的需求——如，要在消息中添加一个额外的字段——但是同时旧版本写的代码仍然可用。不用担心！更新消息而不破坏已有代码是非常简单的。在更新时只要记住以下的规则即可。</p>
<blockquote>
<p>不要更改任何已有的字段的数值标识。</p>
</blockquote>
<p>假设我们有一个旧版本的消息类型 <code>Person</code>，其中包含 <code>name</code> 和 <code>age</code> 两个字段：</p>
<p>旧版本代码示例：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们需要在该消息类型中添加一个新的字段 <code>email</code>，同时遵循规则不更改任何已有字段的数值标识。</p>
<p>更新后的新版本代码示例：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line">  <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，在新版本的代码中，我们增加了一个名为 <code>email</code> 的字段，而没有修改旧字段 <code>name</code> 和 <code>age</code> 的数值标识。</p>
<p>通过这样的更新，旧版本的代码仍然可以正常解析使用旧消息格式的数据，并且只会处理 <code>name</code> 和 <code>age</code> 字段。而新版本的代码可以解析使用新消息格式的数据，并能够同时处理 <code>name</code>、<code>age</code> 和 <code>email</code> 字段。</p>
<blockquote>
<p>如果你增加新的字段，使用旧格式的字段仍然可以被你新产生的代码所解析。你应该记住这些元素的默认值这样你的新代码就可以以适当的方式和旧代码产生的数据交互。相似的，通过新代码产生的消息也可以被旧代码解析：只不过新的字段会被忽视掉。注意，未被识别的字段会在反序列化的过程中丢弃掉，所以如果消息再被传递给新的代码，新的字段依然是不可用的（这和proto2中的行为是不同的，在proto2中未定义的域依然会随着消息被序列化）</p>
</blockquote>
<p>假设我们有一个旧版本的消息类型 <code>Person</code>，包含 <code>name</code> 和 <code>age</code> 字段：</p>
<p>旧版本代码示例：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们要更新消息类型，在其中添加一个新的字段 <code>email</code>。同时，我们需要确保新代码和旧代码之间可以正确解析消息，并处理默认值和未识别字段的情况。</p>
<p>更新后的新版本代码示例：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line">  <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述新版本的代码中，我们增加了一个名为 <code>email</code> 的字段。遵循更新消息类型的规则，该字段的数值标识为 3。</p>
<p>通过这样的更新，我们可以实现以下互操作性：</p>
<ul>
<li><p>旧版本代码解析新消息格式的数据：旧版本代码只能访问到 <code>name</code> 和 <code>age</code> 字段，而无法访问 <code>email</code> 字段。它会忽略掉 <code>email</code> 字段，但仍然能够正常解析和处理 <code>name</code> 和 <code>age</code> 的值。</p>
</li>
<li><p>新版本代码解析旧消息格式的数据：新版本代码可以同时访问 <code>name</code>、<code>age</code> 和 <code>email</code> 字段。对于使用旧消息格式的数据，<code>email</code> 字段会使用默认值（在 <code>proto3</code> 中，默认值为空字符串）。新版本代码可以正确处理这种情况。</p>
</li>
</ul>
<p>此外，当使用新代码生成的消息被传递给旧代码进行解析时，旧代码会忽略掉 <code>email</code> 字段，而未被识别的字段会在反序列化过程中被丢弃。因此，新字段并不可用于旧代码。这种行为与 <code>proto2</code> 的行为不同，因为在 <code>proto2</code> 中，未定义的域会随消息一起被序列化。</p>
<p>通过遵循上述步骤，更新消息类型后，我们可以确保新旧代码之间的互操作性，并正确处理默认值和未识别字段的情况。</p>
<blockquote>
<p>非required的字段可以移除——只要它们的标识号在新的消息类型中不再使用（更好的做法可能是重命名那个字段，例如在字段前添加<code>OBSOLETE_</code>前缀，那样的话，使用的.proto文件的用户将来就不会无意中重新使用了那些不该使用的标识号）。</p>
</blockquote>
<p>假设我们有一个旧版本的消息类型 <code>Person</code>，包含 <code>name</code>、<code>age</code> 和 <code>email</code> 字段：</p>
<p>旧版本代码示例：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line">  <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们要更新消息类型，移除 <code>email</code> 字段。根据建议，更好的做法是将该字段重命名为 <code>OBSOLETE_email</code>，以防止其他用户在未来无意中重新使用该字段的标识号。</p>
<p>更新后的新版本代码示例：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// OBSOLETE_email field, do not use.</span></span><br><span class="line">  <span class="type">string</span> OBSOLETE_email = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述新版本的代码中，我们将要被移除的字段 <code>email</code> 重命名为了 <code>OBSOLETE_email</code>，并添加了注释提示不要使用该字段。通过这样的重命名，我们确保在新消息类型中不再使用原先的标识号（3），从而避免其他用户在未来无意中重新使用该标识号。<strong>对应到Java中，我们可以把它理解为“已弃用的属性”</strong></p>
<p>在这种情况下，通过更新消息类型并移除非 required 的字段，我们可以避免将来的潜在问题，并提供更好的可读性和可维护性。</p>
<blockquote>
<p>int32, uint32, int64, uint64,和bool是全部兼容的，这意味着可以将这些类型中的一个转换为另外一个，而不会破坏向前、 向后的兼容性。如果解析出来的数字与对应的类型不相符，那么结果就像在C++中对它进行了强制类型转换一样（例如，如果把一个64位数字当作int32来 读取，那么它就会被截断为32位的数字）。</p>
</blockquote>
<blockquote>
<p>sint32和sint64是互相兼容的，但是它们与其他整数类型不兼容。</p>
</blockquote>
<blockquote>
<p>string和bytes是兼容的——只要bytes是有效的UTF-8编码。</p>
</blockquote>
<blockquote>
<p>嵌套消息与bytes是兼容的——只要bytes包含该消息的一个编码过的版本。</p>
</blockquote>
<blockquote>
<p>fixed32与sfixed32是兼容的，fixed64与sfixed64是兼容的。</p>
</blockquote>
<blockquote>
<p>枚举类型与int32，uint32，int64和uint64相兼容（注意如果值不相兼容则会被截断），然而在客户端反序列化之后他们可能会有不同的处理方式，例如，未识别的proto3枚举类型会被保留在消息中，但是他的表示方式会依照语言而定。int类型的字段总会保留他们的。</p>
</blockquote>
<p>假设我们有一个旧版本的消息类型 <code>Person</code>，其中包含一个枚举类型的字段 <code>gender</code>：</p>
<p>旧版本代码示例：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line">  Gender gender = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">enum </span><span class="title class_">Gender</span> &#123;</span><br><span class="line">    UNKNOWN = <span class="number">0</span>;</span><br><span class="line">    MALE = <span class="number">1</span>;</span><br><span class="line">    FEMALE = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们要更新消息类型，将 <code>gender</code> 字段的类型从枚举类型改为 int32 类型。根据规范，在更新时需要注意以下几点：</p>
<ul>
<li><p>消息中的已存在的枚举值应该能够使用整型类型进行兼容处理。例如，如果枚举值在新的消息类型中使用了 int32 类型，并且其值在原枚举类型的取值范围内，那么解析时不会出现问题。</p>
</li>
<li><p>对于没有定义的枚举值，旧代码保留未识别的枚举值并将其作为整型类型存储在消息中。但是，它们的表示方式会因语言而异，因此客户端在反序列化后需要注意处理这些未识别值。</p>
</li>
</ul>
<p>更新后的新版本代码示例：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int32</span> gender = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述新版本的代码中，我们将 <code>gender</code> 字段的类型由枚举类型改为了 int32 类型。</p>
<p>通过这样的更新，在新消息类型中，整型类型可以与旧消息类型中的枚举类型兼容。已定义的枚举值可以正常解析，并且未定义的枚举值会以整型类型的形式保留在消息中，但是它们的具体表示方式可能因语言而异。</p>
<p>尽管如此，应该注意的是，客户端在反序列化后需要特别处理这些未识别的整型值，以避免出现意外行为。</p>
<h1 id="Any-类似Java的泛型或Object"><a href="#Any-类似Java的泛型或Object" class="headerlink" title="Any(类似Java的泛型或Object)"></a>Any(类似Java的泛型或Object)</h1><p>尽管存在一些类比，但请注意 Any 类型与泛型和 Object 类型之间的差异：</p>
<ul>
<li>Any 类型是一种特殊的消息类型，需要在 .proto 文件中导入 <code>google/protobuf/any.proto</code>，以便使用。</li>
<li>Any 类型通过序列化和反序列化的方式来存储和传递消息。它不仅存储了序列化后的字节，还包括一个 URL 用于解析消息的类型。</li>
<li>Any 类型需要根据 URL 去解析和处理相应的消息类型，而不是简单地将其视为 Object 类型。</li>
</ul>
<p>Any类型消息允许你在没有指定他们的.proto定义的情况下使用消息作为一个嵌套类型。一个Any类型包括一个可以被序列化bytes类型的任意消息，以及一个URL作为一个全局标识符和解析消息类型。为了使用Any类型，你需要导入import google&#x2F;protobuf&#x2F;any.proto</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/any.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ErrorStatus</span> &#123;</span><br><span class="line">  <span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">repeated</span> google.protobuf.Any details = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于给定的消息类型的默认类型URL是type.googleapis.com&#x2F;packagename.messagename。</p>
<p>不同语言的实现会支持动态库以线程安全的方式去帮助封装或者解封装Any值。例如在java中，Any类型会有特殊的pack()和unpack()访问器，在C++中会有PackFrom()和UnpackTo()方法。</p>
<p>目前，用于Any类型的动态库仍在开发之中<br>如果你已经很熟悉proto2语法，使用Any替换拓展</p>
<h1 id="Oneof"><a href="#Oneof" class="headerlink" title="Oneof"></a>Oneof</h1><p>如果你的消息中有很多可选字段，并且同时最多只会有一个字段被设置，为了节省内存，你可以使用 oneof 特性来增强这种行为。</p>
<p>oneof 字段类似于可选字段，但与可选字段不同的是，它们会共享同一块内存空间，最多只会有一个字段被设置。当设置其中一个字段时，会清除其他已设置的字段。你可以通过使用 <code>case()</code> 或 <code>WhichOneof()</code> 方法（具体取决于你使用的编程语言）来检查哪个 oneof 字段被设置。</p>
<h2 id="使用Oneof"><a href="#使用Oneof" class="headerlink" title="使用Oneof"></a>使用Oneof</h2><p>为了在.proto定义Oneof字段， 你需要在名字前面加上oneof关键字, 比如下面例子的test_oneof:</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SampleMessage</span> &#123;</span><br><span class="line">  <span class="keyword">oneof</span> test_oneof &#123;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">4</span>;</span><br><span class="line">    SubMessage sub_message = <span class="number">9</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后你可以增加oneof字段到 oneof 定义中. 你可以增加任意类型的字段, 但是不能使用repeated 关键字.</p>
<p>在产生的代码中, oneof字段拥有同样的 getters 和setters， 就像正常的可选字段一样. 也有一个特殊的方法来检查到底那个字段被设置. 你可以在相应的语言API指南中找到oneof API介绍.</p>
<h2 id="Oneof-特性"><a href="#Oneof-特性" class="headerlink" title="Oneof 特性"></a>Oneof 特性</h2><ul>
<li>设置oneof会自动清除其它oneof字段的值. 所以设置多次后，只有最后一次设置的字段有值.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SampleMessage message;</span><br><span class="line">message.<span class="built_in">set_name</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="built_in">CHECK</span>(message.<span class="built_in">has_name</span>());</span><br><span class="line">message.<span class="built_in">mutable_sub_message</span>();   <span class="comment">// Will clear name field.</span></span><br><span class="line"><span class="built_in">CHECK</span>(!message.<span class="built_in">has_name</span>());</span><br></pre></td></tr></table></figure>

<ul>
<li>如果解析器遇到同一个oneof中有多个成员，只有最会一个会被解析成消息。</li>
<li>oneof不支持repeated.</li>
<li>反射API对oneof 字段有效.</li>
<li>如果使用C++,需确保代码不会导致内存泄漏. 下面的代码会崩溃， 因为sub_message 已经通过set_name()删除了</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SampleMessage message;</span><br><span class="line">SubMessage* sub_message = message.<span class="built_in">mutable_sub_message</span>();</span><br><span class="line">message.<span class="built_in">set_name</span>(<span class="string">&quot;name&quot;</span>);      <span class="comment">// Will delete sub_message</span></span><br><span class="line">sub_message-&gt;set_...            <span class="comment">// Crashes here</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在C++中，如果你使用Swap()两个oneof消息，每个消息，两个消息将拥有对方的值，例如在下面的例子中，msg1会拥有sub_message并且msg2会有name。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SampleMessage msg1;</span><br><span class="line">msg1.<span class="built_in">set_name</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">SampleMessage msg2;</span><br><span class="line">msg2.<span class="built_in">mutable_sub_message</span>();</span><br><span class="line">msg1.<span class="built_in">swap</span>(&amp;msg2);</span><br><span class="line"><span class="built_in">CHECK</span>(msg1.<span class="built_in">has_sub_message</span>());</span><br><span class="line"><span class="built_in">CHECK</span>(msg2.<span class="built_in">has_name</span>());</span><br></pre></td></tr></table></figure>

<h2 id="向后兼容性问题"><a href="#向后兼容性问题" class="headerlink" title="向后兼容性问题"></a>向后兼容性问题</h2><p>当增加或者删除oneof字段时一定要小心. 如果检查oneof的值返回None&#x2F;NOT_SET, 它意味着oneof字段没有被赋值或者在一个不同的版本中赋值了。 你不会知道是哪种情况，因为没有办法判断如果未识别的字段是一个oneof字段。</p>
<p>Tage 重用问题：</p>
<ul>
<li>将字段移入或移除oneof：在消息被序列号或者解析后，你也许会失去一些信息（有些字段也许会被清除）</li>
<li>删除一个字段或者加入一个字段：在消息被序列号或者解析后，这也许会清除你现在设置的oneof字段</li>
<li>分离或者融合oneof：行为与移动常规字段相似。</li>
</ul>
<h1 id="映射（Maps）"><a href="#映射（Maps）" class="headerlink" title="映射（Maps）"></a>映射（Maps）</h1><p>如果你希望创建一个关联映射，protocol buffer提供了一种快捷的语法：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;key_type, value_type&gt; map_field = N;</span><br></pre></td></tr></table></figure>

<p>其中key_type可以是任意Integer或者string类型（所以，除了floating和bytes的任意标量类型都是可以的）value_type可以是任意类型。</p>
<p>例如，如果你希望创建一个project的映射，每个Projecct使用一个string作为key，你可以像下面这样定义：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">string</span>, Project&gt; projects = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>Map的字段可以是repeated。</li>
<li>序列化后的顺序和map迭代器的顺序是不确定的，所以你不要期望以固定顺序处理Map</li>
<li>当为.proto文件产生生成文本格式的时候，map会按照key 的顺序排序，数值化的key会按照数值排序。</li>
<li>从序列化中解析或者融合时，如果有重复的key则后一个key不会被使用，当从文本格式中解析map时，如果存在重复的key。</li>
</ul>
<p>生成map的API现在对于所有proto3支持的语言都可用了，你可以从API指南找到更多信息。</p>
<h2 id="向后兼容性问题-1"><a href="#向后兼容性问题-1" class="headerlink" title="向后兼容性问题"></a>向后兼容性问题</h2><p>map语法序列化后等同于如下内容，因此即使是不支持map语法的protocol buffer实现也是可以处理你的数据的：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">MapFieldEntry</span> &#123;</span><br><span class="line">  key_type key = <span class="number">1</span>;</span><br><span class="line">  value_type value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">repeated</span> MapFieldEntry map_field = N;</span><br></pre></td></tr></table></figure>

<h1 id="包（Packages）"><a href="#包（Packages）" class="headerlink" title="包（Packages）"></a>包（Packages）</h1><p>当然可以为.proto文件新增一个可选的package声明符，用来防止不同的消息类型有命名冲突。如：</p>
<p>package foo.bar;<br>message Open { … }</p>
<p>在其他的消息格式定义中可以使用包名+消息名的方式来定义域的类型，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Foo</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">required</span> foo.bar.Open open = <span class="number">1</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包的声明符会根据使用语言的不同影响生成的代码。</p>
<ul>
<li>对于C++，产生的类会被包装在C++的命名空间中，如上例中的Open会被封装在 foo::bar空间中； - 对于Java，包声明符会变为java的一个包，除非在.proto文件中提供了一个明确有java_package；</li>
<li>对于 Python，这个包声明符是被忽略的，因为Python模块是按照其在文件系统中的位置进行组织的。</li>
<li>对于Go，包可以被用做Go包名称，除非你显式的提供一个option go_package在你的.proto文件中。</li>
<li>对于Ruby，生成的类可以被包装在内置的Ruby名称空间中，转换成Ruby所需的大小写样式 （首字母大写；如果第一个符号不是一个字母，则使用PB_前缀），例如Open会在Foo::Bar名称空间中。</li>
<li>对于javaNano包会使用Java包，除非你在你的文件中显式的提供一个option java_package。</li>
<li>对于C#包可以转换为PascalCase后作为名称空间，除非你在你的文件中显式的提供一个option csharp_namespace，例如，Open会在Foo.Bar名称空间中</li>
</ul>
<h2 id="包及名称的解析"><a href="#包及名称的解析" class="headerlink" title="包及名称的解析"></a>包及名称的解析</h2><p>Protocol buffer语言中类型名称的解析与C++是一致的：首先从最内部开始查找，依次向外进行，每个包会被看作是其父类包的内部类。当然对于 （foo.bar.Baz）这样以“.”分隔的意味着是从最外围开始的。</p>
<p>ProtocolBuffer编译器会解析.proto文件中定义的所有类型名。 对于不同语言的代码生成器会知道如何来指向每个具体的类型，即使它们使用了不同的规则。</p>
<h1 id="定义服务-service接口"><a href="#定义服务-service接口" class="headerlink" title="定义服务(service接口)"></a>定义服务(service接口)</h1><p>当然，具体的实现类要我们自己写</p>
<p>如果想要将消息类型用在RPC(远程方法调用)系统中，可以在.proto文件中定义一个RPC服务接口，protocol buffer编译器将会根据所选择的不同语言生成服务接口代码及存根。如，想要定义一个RPC服务并具有一个方法，该方法能够接收 SearchRequest并返回一个SearchResponse，此时可以在.proto文件中进行如下定义：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">service </span><span class="title class_">SearchService</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> Search (SearchRequest) <span class="keyword">returns</span> (SearchResponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最直观的使用protocol buffer的RPC系统是gRPC一个由谷歌开发的语言和平台中的开源的PRC系统，gRPC在使用protocl buffer时非常有效，如果使用特殊的protocol buffer插件可以直接为您从.proto文件中产生相关的RPC代码。</p>
<p>如果你不想使用gRPC，也可以使用protocol buffer用于自己的RPC实现，你可以从proto2语言指南中找到更多信息</p>
<p>还有一些第三方开发的PRC实现使用Protocol Buffer。参考第三方插件wiki查看这些实现的列表。</p>
<h1 id="JSON-映射"><a href="#JSON-映射" class="headerlink" title="JSON 映射"></a>JSON 映射</h1><p>Proto3 支持JSON的编码规范，使他更容易在不同系统之间共享数据，在下表中逐个描述类型。</p>
<p>如果JSON编码的数据丢失或者其本身就是null，这个数据会在解析成protocol buffer的时候被表示成默认值。如果一个字段在protocol buffer中表示为默认值，体会在转化成JSON的时候编码的时候忽略掉以节省空间。具体实现可以提供在JSON编码中可选的默认值。</p>
<table>
<thead>
<tr>
<th>proto3</th>
<th>JSON</th>
<th>JSON示例</th>
<th>注意</th>
</tr>
</thead>
<tbody><tr>
<td>message</td>
<td>object</td>
<td>{“fBar”: v, “g”: null, …}</td>
<td>产生JSON对象，消息字段名可以被映射成lowerCamelCase形式，并且成为JSON对象键，null被接受并成为对应字段的默认值</td>
</tr>
<tr>
<td>enum</td>
<td>string</td>
<td>“FOO_BAR”</td>
<td>枚举值的名字在proto文件中被指定</td>
</tr>
<tr>
<td>map</td>
<td>object</td>
<td>{“k”: v, …}</td>
<td>所有的键都被转换成string</td>
</tr>
<tr>
<td>repeated V</td>
<td>array</td>
<td>[v, …]</td>
<td>null被视为空列表</td>
</tr>
<tr>
<td>bool</td>
<td>true, false</td>
<td>true, false</td>
<td></td>
</tr>
<tr>
<td>string</td>
<td>string</td>
<td>“Hello World!”</td>
<td></td>
</tr>
<tr>
<td>bytes</td>
<td>base64 string</td>
<td>“YWJjMTIzIT8kKiYoKSctPUB+”</td>
<td></td>
</tr>
<tr>
<td>int32, fixed32, uint32</td>
<td>number</td>
<td>1, -10, 0</td>
<td>JSON值会是一个十进制数，数值型或者string类型都会接受</td>
</tr>
<tr>
<td>int64, fixed64, uint64</td>
<td>string</td>
<td>“1”, “-10”</td>
<td>JSON值会是一个十进制数，数值型或者string类型都会接受</td>
</tr>
<tr>
<td>float, double</td>
<td>number</td>
<td>1.1, -10.0, 0, “NaN”, “Infinity”</td>
<td>JSON值会是一个数字或者一个指定的字符串如”NaN”,”infinity”或者”-Infinity”，数值型或者字符串都是可接受的，指数符号也可以接受</td>
</tr>
<tr>
<td>Any</td>
<td>object</td>
<td>{“@type”: “url”, “f”: v, … }</td>
<td>如果一个Any保留一个特上述的JSON映射，则它会转换成一个如下形式：{“@type”: xxx, “value”: yyy}否则，该值会被转换成一个JSON对象，@type字段会被插入所指定的确定的值</td>
</tr>
<tr>
<td>Timestamp</td>
<td>string</td>
<td>“1972-01-01T10:00:20.021Z”</td>
<td>使用RFC 339，其中生成的输出将始终是Z-归一化啊的，并且使用0，3，6或者9位小数</td>
</tr>
<tr>
<td>Duration</td>
<td>string</td>
<td>“1.000340012s”, “1s”</td>
<td>生成的输出总是0，3，6或者9位小数，具体依赖于所需要的精度，接受所有可以转换为纳秒级的精度</td>
</tr>
<tr>
<td>Struct</td>
<td>object</td>
<td>{ … }</td>
<td>任意的JSON对象，见struct.proto</td>
</tr>
<tr>
<td>Wrapper types</td>
<td>various types</td>
<td>2, “2”, “foo”, true, “true”, null, 0, …</td>
<td>包装器在JSON中的表示方式类似于基本类型，但是允许nulll，并且在转换的过程中保留null</td>
</tr>
<tr>
<td>FieldMask</td>
<td>string</td>
<td>“f.fooBar,h”</td>
<td>见fieldmask.proto</td>
</tr>
<tr>
<td>ListValue</td>
<td>array</td>
<td>[foo, bar, …]</td>
<td></td>
</tr>
<tr>
<td>Value</td>
<td>value</td>
<td></td>
<td>任意JSON值</td>
</tr>
<tr>
<td>NullValue</td>
<td>null</td>
<td></td>
<td>JSON null</td>
</tr>
</tbody></table>
<h1 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h1><p>在定义.proto文件时能够标注一系列的options。Options并不改变整个文件声明的含义，但却能够影响特定环境下处理方式。完整的可用选项可以在google&#x2F;protobuf&#x2F;descriptor.proto找到。</p>
<p>一些选项是文件级别的，意味着它可以作用于最外范围，不包含在任何消息内部、enum或服务定义中。一些选项是消息级别的，意味着它可以用在消息定义的内部。当然有些选项可以作用在域、enum类型、enum值、服务类型及服务方法中。到目前为止，并没有一种有效的选项能作用于所有的类型。</p>
<p>如下就是一些常用的选择：</p>
<ul>
<li>java_package (文件选项) :这个选项表明生成java类所在的包。如果在.proto文件中没有明确的声明java_package，就采用默认的包名。当然了，默认方式产生的 java包名并不是最好的方式，按照应用名称倒序方式进行排序的。如果不需要产生java代码，则该选项将不起任何作用。如：</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span> java_package = <span class="string">&quot;com.example.foo&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>java_outer_classname (文件选项): 该选项表明想要生成Java类的名称。如果在.proto文件中没有明确的java_outer_classname定义，生成的class名称将会根据.proto文件的名称采用驼峰式的命名方式进行生成。如（foo_bar.proto生成的java类名为FooBar.java）,如果不生成java代码，则该选项不起任何作用。如：</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">&quot;Ponycopter&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>optimize_for(文件选项): 可以被设置为 SPEED, CODE_SIZE,或者LITE_RUNTIME。这些值将通过如下的方式影响C++及java代码的生成： <ul>
<li>SPEED (default): protocol buffer编译器将通过在消息类型上执行序列化、语法分析及其他通用的操作。这种代码是最优的。</li>
<li>CODE_SIZE: protocol buffer编译器将会产生最少量的类，通过共享或基于反射的代码来实现序列化、语法分析及各种其它操作。采用该方式产生的代码将比SPEED要少得多， 但是操作要相对慢些。当然实现的类及其对外的API与SPEED模式都是一样的。这种方式经常用在一些包含大量的.proto文件而且并不盲目追求速度的 应用中。</li>
<li>LITE_RUNTIME: protocol buffer编译器依赖于运行时核心类库来生成代码（即采用libprotobuf-lite 替代libprotobuf）。这种核心类库由于忽略了一 些描述符及反射，要比全类库小得多。这种模式经常在移动手机平台应用多一些。编译器采用该模式产生的方法实现与SPEED模式不相上下，产生的类通过实现 MessageLite接口，但它仅仅是Messager接口的一个子集。</li>
</ul>
</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span> optimize_for = CODE_SIZE;</span><br></pre></td></tr></table></figure>

<ul>
<li>cc_enable_arenas(文件选项):对于C++产生的代码启用<a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/reference/arenas?hl=zh-cn">arena allocation</a>。</li>
<li>objc_class_prefix(文件选项):设置Objective-C类的前缀，添加到所有Objective-C从此.proto文件产生的类和枚举类型。没有默认值，所使用的前缀应该是苹果推荐的3-5个大写字符，注意2个字节的前缀是苹果所保留的。</li>
<li>deprecated(字段选项):如果设置为true则表示该字段已经被废弃，并且不应该在新的代码中使用。在大多数语言中没有实际的意义。在java中，这回变成@Deprecated注释，在未来，其他语言的代码生成器也许会在字标识符中产生废弃注释，废弃注释会在编译器尝试使用该字段时发出警告。如果字段没有被使用你也不希望有新用户使用它，尝试使用保留语句替换字段声明。</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32</span> old_field = <span class="number">6</span> [deprecated=<span class="literal">true</span>];</span><br></pre></td></tr></table></figure>

<h2 id="自定义选项"><a href="#自定义选项" class="headerlink" title="自定义选项"></a>自定义选项</h2><p>ProtocolBuffers允许自定义并使用选项。该功能应该属于一个高级特性，对于大部分人是用不到的。如果你的确希望创建自己的选项，请参看<a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/proto?hl=zh-cn#customoptions">Proto2 Language Guide</a>。注意创建自定义选项使用了拓展，拓展只在proto3中可用。</p>
<h1 id="生成你的类"><a href="#生成你的类" class="headerlink" title="生成你的类"></a>生成你的类</h1><p>在pom.xml中：</p>
<ol>
<li>引入 <a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/io.grpc/grpc-protobuf"><code>grpc-protobuf</code></a> 依赖，使用 Protobuf 作为序列化库。引入 <a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/io.grpc/grpc-stub"><code>grpc-stub</code></a> 依赖，使用 gRPC Stub 作为客户端。</li>
<li>引入 <a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/kr.motd.maven/os-maven-plugin"><code>os-maven-plugin</code></a> 插件，从 OS 系统中获取参数。因为需要通过它，从 OS 系统中获取 <code>os.detected.classifier</code> 参数，稍后使用到 <code>protobuf-maven-plugin</code> 插件和 OS 系统相关。</li>
<li>引入 <a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/org.xolstice.maven.plugins/protobuf-maven-plugin"><code>protobuf-maven-plugin</code></a> 插件，实现通过 <code>proto</code> 目录下的 protobuf 文件，生成 Service 和 Message 类。</li>
</ol>
<p>然后，我们点击 IDEA 的「compile」按钮，编译该 API 项目，并同时执行 <code>protobuf-maven-plugin</code> 插件进行生成。</p>
<p>具体依赖可以参考<a target="_blank" rel="noopener" href="https://github.com/OrionLi/spring-boot-demo/blob/master/demo-rpc-grpc/grpc-userservice-api/pom.xml">我的GitHub中使用gRPC的api模块demo</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://orionli.gitee.io/blog">OrionLi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://orionli.gitee.io/blog/2023/06/21/protobuf3-guide/">https://orionli.gitee.io/blog/2023/06/21/protobuf3-guide/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://orionli.gitee.io/blog" target="_blank">OrionLi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blog/tags/gRPC/">gRPC</a><a class="post-meta__tags" href="/blog/tags/Protobuf3/">Protobuf3</a></div><div class="post_share"><div class="social-share" data-image="https://avatars.githubusercontent.com/OrionLi" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/2023/05/16/jvm/" title="Java 虚拟机"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java 虚拟机</div></div></a></div><div class="next-post pull-right"><a href="/blog/2023/07/06/programming-beginner-guide/" title="编程入门"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">编程入门</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8protobuf"><span class="toc-text">为什么使用protobuf</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="toc-text">定义一个消息类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B"><span class="toc-text">指定字段类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E6%A0%87%E8%AF%86%E5%8F%B7"><span class="toc-text">分配标识号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5%E8%A7%84%E5%88%99"><span class="toc-text">指定字段规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%9B%B4%E5%A4%9A%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="toc-text">添加更多消息类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A"><span class="toc-text">添加注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E7%95%99%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%88Reserved%EF%BC%89"><span class="toc-text">保留标识符（Reserved）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E-proto%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">从.proto文件生成了什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%87%E9%87%8F%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-text">标量数值类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-text">默认值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%85%B6%E4%BB%96%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B-%E5%AF%B9%E5%BA%94Java%E7%9A%84%E5%B5%8C%E5%A5%97"><span class="toc-text">使用其他消息类型(对应Java的嵌套)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%AE%9A%E4%B9%89"><span class="toc-text">导入定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8proto2%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="toc-text">使用proto2消息类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%B1%BB%E5%9E%8B-%E5%AF%B9%E5%BA%94Java%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">嵌套类型(对应Java的内部类)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="toc-text">更新一个消息类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Any-%E7%B1%BB%E4%BC%BCJava%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%88%96Object"><span class="toc-text">Any(类似Java的泛型或Object)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Oneof"><span class="toc-text">Oneof</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Oneof"><span class="toc-text">使用Oneof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Oneof-%E7%89%B9%E6%80%A7"><span class="toc-text">Oneof 特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-text">向后兼容性问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%EF%BC%88Maps%EF%BC%89"><span class="toc-text">映射（Maps）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98-1"><span class="toc-text">向后兼容性问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%85%EF%BC%88Packages%EF%BC%89"><span class="toc-text">包（Packages）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E5%8F%8A%E5%90%8D%E7%A7%B0%E7%9A%84%E8%A7%A3%E6%9E%90"><span class="toc-text">包及名称的解析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1-service%E6%8E%A5%E5%8F%A3"><span class="toc-text">定义服务(service接口)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JSON-%E6%98%A0%E5%B0%84"><span class="toc-text">JSON 映射</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%89%E9%A1%B9"><span class="toc-text">选项</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%80%89%E9%A1%B9"><span class="toc-text">自定义选项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E4%BD%A0%E7%9A%84%E7%B1%BB"><span class="toc-text">生成你的类</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By OrionLi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/blog/js/utils.js"></script><script src="/blog/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/blog/js/search/local-search.js"></script></div></div></body></html>